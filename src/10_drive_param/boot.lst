     1                                  ;boot()
     2                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     3                                  ; マクロ
     4                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                          %include "/home/m8ku/prog/src/include/macro.asm"
     1                              <1> ;cdecl(),drive()
     2                              <1> %macro  cdecl   1-*.nolist
     3                              <1> 
     4                              <1>     %rep %0 - 1
     5                              <1> 
     6                              <1>         push    %{-1 : -1}
     7                              <1>         %rotate -1
     8                              <1> 
     9                              <1>     %endrep
    10                              <1> 
    11                              <1>     %rotate -1
    12                              <1>     call    %1
    13                              <1> 
    14                              <1>     %if 1 < %0
    15                              <1> 
    16                              <1>         add     sp , (__BITS__>>3) * (%0 - 1)
    17                              <1> 
    18                              <1>     %endif
    19                              <1> 
    20                              <1> %endmacro
    21                              <1> ;(マクロの概要(関数呼び出しのための関数です))
    22                              <1> ; 1.cdeclとしてマクロを定義して、引数は１からの可変長として、リスト出力の抑止を指定する(.lst)
    23                              <1> ; 2.%repから、もらった引数から関数分を差し引いた %0 - 1 回として %endrep まで繰り返します
    24                              <1> ; 3.関数呼び出しに備えるために引数をスタックに積んでいきます、%{-1 : -1 }はもらった引数全体の
    25                              <1> ;   終端を表しています ですので、受け取った引数が putc , ax , bx だとして一回目のループでbx
    26                              <1> ;   がスタックに積ます、次の%rotateは引数を回転します例えば (1,2,3)が(3,1,2)になります今回
    27                              <1> ;   は右に回転させたいので-1と指定していますが左に回転させたい場合は+を指定してやります、そして
    28                              <1> ;   (bx,putc,ax)になり次のループで引数の終端axが積んでから引数を回転(ax,bx,putc)となります
    29                              <1> ;   そして今回の例だとここで繰り返しが終了します
    30                              <1> ; 3.今回の例の続きで引数を回転させて(putc,ax,bx)となって
    31                              <1> ; 4.第一引数の名前の関数を呼び出します、今回の例では第一引数はputcとなっているのでputcという関
    32                              <1> ;   数が呼び出されることとなります
    33                              <1> ; 5.後に関数に引数として積んだスタックを調整してやるのですがマクロに引数を一つもしてしていないの
    34                              <1> ;   にもかかわらずスタックポインタを調節されては困るから条件式に当てはまったら処理をするようにし
    35                              <1> ;   てあげます今回だと一つ以上の引数が指定されたらです
    36                              <1> ; 6.関数を呼び出したら呼び出し側がスタックを調節してやらなければいけないのでスタックを調節します
    37                              <1> ;   スタックポインタレジスタに,(__BITS__>>3)*(%0 - 1 )を計算して書き込みます、__BITS__の
    38                              <1> ;   意味はNASMに元々組み込まれているマクロで16bit,32bit,64bitの判定を行います、16bitのプロ
    39                              <1> ;   グラムだったとして16を左へ3回シフトして(>>のところ)2が得られます32だったら4、64だったら8
    40                              <1> ;   、そしてCPUアーキテクチャ単位でスタックの料理ができるようになります、(%0 - 1)で引数の数を
    41                              <1> ;   だして、さきほどだした2と今回出した2をかけて4,積んだ引数は2つなのでビンゴです、spに4を加算
    42                              <1> ;   して関数呼び出しのすべての処理が終わりました
    43                              <1> ; 7.条件処理を終えます
    44                              <1> ; 8.マクロの終了です
    45                              <1> 
    46                              <1> struc drive
    47 00000000 <res 00000002>      <1>         .no     resw    1                               ; ドライブ番号
    48 00000002 <res 00000002>      <1>         .cyln   resw    1                               ; シリンダ
    49 00000004 <res 00000002>      <1>         .head   resw    1                               ; ヘッド
    50 00000006 <res 00000002>      <1>         .sect   resw    1                               ; セクタ
    51                              <1> 
    52                              <1> endstruc
    53                              <1> ;(マクロの概要(構造体の定義をしています))
    54                              <1> ; 0. ディスクアクセスに必要な情報をソースコードに更新する形で利用します、
    55                              <1> ;    次に更新する例を示します
    56                              <1> ;   istruc drive
    57                              <1> ;       at .sect dw 2                                   ; S:セクタ
    58                              <1> ;   iend
     6                                          %include "/home/m8ku/prog/src/include/define.asm"
     1                              <1> ;define()
     2                              <1>         BOOT_LOAD       equ     (0x7C00)                ; ブートプログラムロード位置
     3                              <1>         BOOT_SIZE       equ     (1024 * 8)              ; ブートコードサイズ
     4                              <1>         SECT_SIZE       equ     (512)                   ; セクタサイズ 512B
     5                              <1>         BOOT_SECT       equ     (BOOT_SIZE / SECT_SIZE) ; ブートプログラムのセクタ数
     6                              <1> 
     7                              <1> ; (定義の概要)
     8                              <1> ; 0. それぞれdefineしています、ソースコードにうまく取り込もう
     7                                  
     8                                          ORG     BOOT_LOAD                               ; プログラムの開始位置を設定
     9                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    10                                  ; エントリポイント
    11                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    12                                  entry:
    13                                  
    14                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    15                                          ; BPB( BIOS Parameter Block )
    16                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    17 00000000 EB58                            jmp     IPL                                     ; IPLラベルへ移動
    18 00000002 90<rept>                        times  90 - ( $ - $$ ) db 0x90                  ; BPB領域を確保
    19                                  IPL:
    20                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    21                                          ; IPL( Initial Program Loader )
    22                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    23 0000005A FA                              cli                                             ; //割り込み禁止
    24                                  
    25 0000005B B80000                          mov     ax , 0x0000                             ; AX=0x0000s
    26 0000005E 8ED8                            mov     ds , ax                                 ; DS=0x0000
    27 00000060 8EC0                            mov     es , ax                                 ; ES=0x0000
    28 00000062 8ED0                            mov     ss , ax                                 ; SS=0x0000
    29 00000064 BC007C                          mov     sp , BOOT_LOAD                          ; SP=0x7c00
    30                                  
    31 00000067 FB                              sti                                             ; //割り込み許可
    32                                  
    33 00000068 8816[B800]                      mov     [BOOT + drive.no] , dl                  ; ドライブ番号
    34                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    35                                          ; 文字列を表示
    36                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37 0000006C 68[9900]E84E0083C4-             cdecl   puts , .s0                              ; puts(.s0);//Booting...
    37 00000074 02                 
    38                                  
    39                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    40                                          ; 次の５１２バイトを読み込む
    41                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    42 00000075 BB0F00                          mov     bx , BOOT_SECT - 1                      ; BX = 残りのブートセクタ数
    43 00000078 B9007E                          mov     cx , BOOT_LOAD + SECT_SIZE              ; CX = 次のロードアドレス
    44                                  
    45 0000007B 515368[B800]E89D00-             cdecl   read_chs, BOOT,  bx, cx                 ; セクタ読み出し関数の発行
    45 00000083 83C406             
    46                                  
    47                                  
    48 00000086 39D8                            cmp     ax , bx                                 ; if(AX!=BX)
    49 00000088 740C                    .10Q:   jz      .10E                                    ; {
    50 0000008A 68[A600]E8300083C4-     .10T:   cdecl   puts, .e0                               ; puts(.e0); //メッセージ
    50 00000092 02                 
    51 00000093 E84B00                          call    reboot                                  ; reboot();  //再起動
    52                                  .10E:                                                   ; }
    53                                  
    54                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    55                                          ; 次のステージへ移行
    56                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    57 00000096 E93302                          jmp     stage_2                                 ; ブート処理の第二ステージ
    58                                  
    59                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    60                                          ; データ
    61                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    62 00000099 426F6F74696E672E2E-     .s0     db  "Booting..." , 0x0A , 0x0D , 0              ;
    62 000000A2 2E0A0D00           
    63 000000A6 4572726F723A736563-     .e0     db  "Error:sector read", 0                      ;
    63 000000AF 746F72207265616400 
    64                                  
    65                                          align       2       , db 0                      ;
    66                                  BOOT:
    67                                          istruc  drive
    68 000000B8 0000                                at drive.no,    dw  0                       ; ドライブ番号
    69 000000BA 0000                                at drive.cyln,  dw  0                       ; S:シリンダー
    70 000000BC 0000                                at drive.head,  dw  0                       ; H:ヘッド
    71 000000BE 0200                                at drive.sect,  dw  2                       ; S:セクタ
    72                                          iend
    73                                  
    74                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    75                                      ; モジュール
    76                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    77                                      %include "/home/m8ku/prog/src/modules/real/puts.asm"
     1                              <1> ;puts(str)
     2                              <1> puts:
     3 000000C0 55                  <1>         push    bp                                      ; スタックフレームを構築
     4 000000C1 89E5                <1>         mov     bp , sp                                 ;
     5                              <1> 
     6 000000C3 50                  <1>         push    ax                                      ; 各レジスタの退避
     7 000000C4 53                  <1>         push    bx                                      ;
     8 000000C5 56                  <1>         push    si                                      ;
     9 000000C6 9C                  <1>         pushf                                           ;
    10                              <1> 
    11 000000C7 8B7604              <1>         mov     si , [bp + 4]                           ; 第一引数へアクセス
    12 000000CA B40E                <1>         mov     ah , 0x0E                               ; AH=0x0E
    13 000000CC BB0000              <1>         mov     bx , 0x0000                             ; BX=0x0000
    14 000000CF FC                  <1>         cld                                             ; DF=0
    15                              <1> 
    16                              <1> .10L:                                                   ; do{
    17 000000D0 AC                  <1>         lodsb                                           ; AL = *SI++;
    18                              <1> 
    19 000000D1 3C00                <1>         cmp     al , 0                                  ; if(0 == AL)
    20 000000D3 7404                <1>         je      .10E                                    ; break;
    21                              <1> 
    22 000000D5 CD10                <1>         int     0x10                                    ; Int10(0x0E,AL)//文字出力
    23                              <1> 
    24 000000D7 EBF7                <1>         jmp     .10L                                    ; while (1);
    25                              <1> .10E:
    26                              <1> 
    27 000000D9 9D                  <1>         popf                                            ; 各レジスタの復帰
    28 000000DA 5E                  <1>         pop     si                                      ;
    29 000000DB 5B                  <1>         pop     bx                                      ;
    30 000000DC 58                  <1>         pop     ax                                      ;
    31                              <1> 
    32 000000DD 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    33 000000DF 5D                  <1>         pop     bp                                      ;
    34                              <1> 
    35 000000E0 C3                  <1>         ret                                             ; もとの処へ
    36                              <1> 
    37                              <1> ;(関数の概要(文字列を表示する関数です))
    38                              <1> ; 1. スタックフレームを構築します
    39                              <1> ; 2. 各レジスタを退避します
    40                              <1> ; 3. SIレジスタには後ほど利用する値を、AHレジスタに0x0EをBXレジスタには0をBIOSコールに備えて
    41                              <1> ;    書き込んでおきます
    42                              <1> ; 3. ストリング命令に備えてDFフラグを０を書き込みます
    43                              <1> ; 4. 先に引数の転送元をSIレジスタに書き込んだので転送元(メモリ)から転送先(ALレジスタ)へ値をを
    44                              <1> ;    転送します、この時にDIレジスタの値がインクリメントされます、
    45                              <1> ; 5. もしALレジスタに0が入ったら関数の終了アドレスへ移動します
    46                              <1> ; 6. そしたらALレジスタにはきっとASCII文字が書かれているので0x10番でBIOSコールをし表示します
    47                              <1> ; 7. .10Eのアドレスへ移動してALレジスタに0が入るまで文字を表示して結果的に文字列が表示できます
    48                              <1> ; 8. 各レジスタ復帰します
    49                              <1> ; 9. スッタックフレームを取り除いて
    50                              <1> ;10. 呼び出し元のアドレスまで移動します
    78                                      %include "/home/m8ku/prog/src/modules/real/reboot.asm"
     1                              <1> ;reboot()
     2                              <1> reboot:
     3                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1>         ; メッセージを表示
     5                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     6 000000E1 68[FD00]E8D9FF83C4- <1>         cdecl   puts, .s0                               ; //再起動メッセージを表示
     6 000000E9 02                  <1>
     7                              <1> 
     8                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     9                              <1>         ; キー入力待ち
    10                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    11                              <1> .10L:
    12                              <1> ;                                                       ; do
    13 000000EA B410                <1>         mov     ah , 0x10                               ; {
    14 000000EC CD16                <1>         int     0x16                                    ;   // キー入力待ち
    15                              <1> ;                                                       ;   AL=BIOS(0x16,0x10);
    16 000000EE 3C20                <1>         cmp     al , ' '                                ;   ZF = AL == ' ';
    17 000000F0 75F8                <1>         jne     .10L                                    ; } while(!ZF)
    18                              <1> 
    19                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    20                              <1>         ; 改行を出力
    21                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    22 000000F2 68[1B01]E8C8FF83C4- <1>         cdecl   puts, .s1                               ; //改行
    22 000000FA 02                  <1>
    23                              <1> 
    24                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    25                              <1>         ; 再起動
    26                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    27 000000FB CD19                <1>         int     0x19                                    ; BIOS(0x19); //reboot()
    28                              <1> 
    29                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1>         ; 文字列データ
    31                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32 000000FD 0A0D50757368205350- <1> .s0 db 0x0A, 0x0D, "Push SPACE Key to Reboot...", 0     ;
    32 00000106 414345204B65792074- <1>
    32 0000010F 6F205265626F6F742E- <1>
    32 00000118 2E2E00              <1>
    33 0000011B 0A0D0A0D00          <1> .s1 db 0x0A, 0x0D, 0x0A, 0x0D, 0                        ;
    34                              <1> 
    35                              <1> ; (関数の概要(コンピューターを再起動する関数です))
    36                              <1> ; 1. "cdecl puts,.s0" 突然再起動されたらビックリするので再起動をする旨を伝えます
    37                              <1> ; 2. "10L" もしスペースキーが押下されたら再起動ができるように繰り返しを行います"mov ah,0x10"
    38                              <1> ;    は拡張キーボード用です
    39                              <1> ;   | int 0x16 | |      AH      | |      AL      |
    40                              <1> ;   |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    41                              <1> ;   |    入力   | |     0x00     |       ---      |
    42                              <1> ;   |    出力   | | スキャンコード |   アスキーコード  |
    43                              <1> ; 3. "cdecl puts,.s1" 改行を出力します
    44                              <1> ; 4. "int 0x19" 再起動をするBIOSコールを発行します
    45                              <1> ; 5. ".s0" ".s1" 表示する文字列をそれぞれ定義しています
    79                                      %include "/home/m8ku/prog/src/modules/real/read_chs.asm"
     1                              <1> ;read_chs(drive,sect,dst)
     2                              <1> read_chs:
     3                              <1>         ;________________________________________________
     4                              <1>         ; スタックフレームの構築
     5                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     6 00000120 55                  <1>         push    bp                                      ;
     7 00000121 89E5                <1>         mov     bp , sp                                 ;
     8 00000123 6A03                <1>         push    3                                       ; int retry = 3;
     9 00000125 6A00                <1>         push    0                                       ; int sect  = 0;
    10                              <1> 
    11                              <1>         ;________________________________________________
    12                              <1>         ;　レジスタの保存
    13                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    14 00000127 53                  <1>         push    bx                                      ;
    15 00000128 51                  <1>         push    cx                                      ;
    16 00000129 52                  <1>         push    dx                                      ;
    17 0000012A 06                  <1>         push    es                                      ;
    18 0000012B 56                  <1>         push    si                                      ;
    19 0000012C 9C                  <1>         pushf                                           ;
    20                              <1> 
    21                              <1>         ;________________________________________________
    22                              <1>         ; メインプログラム開始！
    23                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    24 0000012D 8B7604              <1>         mov     si , [bp + 4]                           ; SI = SRCバッファ;
    25                              <1> 
    26                              <1>         ;________________________________________________
    27                              <1>         ; CXレジスタの設定 (BIOSコールの呼び出しに適した形に変換)
    28                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    29 00000130 8A6C02              <1>         mov     ch , [si + drive.cyln + 0]              ; CH=シリンダ番号(下位バイト)
    30 00000133 8A4C03              <1>         mov     cl , [si + drive.cyln + 1]              ; CL=シリンダ番号(上位バイト)
    31 00000136 C0E106              <1>         shl     cl , 6                                  ; CL<<=6;//6ビット左へシフト
    32 00000139 0A4C06              <1>         or      cl , [si + drive.sect]                  ; CL|=セクタ番号;
    33                              <1> 
    34                              <1>         ;________________________________________________
    35                              <1>         ; DHレジスタの設定とコピー先の設定
    36                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    37 0000013C 8A7404              <1>         mov     dh , [si + drive.head ]                 ; DH = ヘッド番号;
    38 0000013F 8A14                <1>         mov     dl , [si + 0]                           ; DL = ドライブ番号;
    39                              <1> 
    40 00000141 B80000              <1>         mov     ax ,0x0000                              ; AX = 0x0000;
    41 00000144 8EC0                <1>         mov     es , ax                                 ; EX = セグメント
    42 00000146 8B5E08              <1>         mov     bx , [bp + 8]                           ; BX = コピー先
    43                              <1> 
    44                              <1>         ;________________________________________________
    45                              <1>         ; セクタの読み込み
    46                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    47                              <1> .10L:
    48 00000149 8A4606              <1>         mov     al , [bp + 6]                           ; AL = セクタ数
    49 0000014C B402                <1>         mov     ah , 0x02                               ; AH = セクタ読み込み;
    50                              <1> 
    51 0000014E CD13                <1>         int     0x13                                    ; CF = BIOS(0x13,0x02);
    52 00000150 7304                <1>         jnc     .11E                                    ; if(CF)
    53                              <1> ;                                                       ; {
    54 00000152 B000                <1>         mov     al , 0                                  ;   AL = 0;
    55 00000154 EB0C                <1>         jmp     .10E                                    ;   break;
    56                              <1> .11E:                                                   ; }
    57                              <1> 
    58 00000156 3C00                <1>         cmp     al , 0                                  ; if(セクタ読み込んだなら){
    59 00000158 7508                <1>         jne     .10E                                    ;   break;
    60                              <1> 
    61 0000015A B80000              <1>         mov     ax , 0                                  ;   ret = 0;//戻り値を設定
    62 0000015D FF4EFE              <1>         dec     word [bp - 2]                           ; }
    63 00000160 75E7                <1>         jnz     .10L                                    ; while (--retry)
    64                              <1> .10E:
    65 00000162 B400                <1>         mov     ah , 0                                  ; AH=0;//ステータス情報破棄
    66                              <1> 
    67                              <1>         ;________________________________________________
    68                              <1>         ; レジスタの復帰
    69                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    70 00000164 9D                  <1>         popf                                            ;
    71 00000165 5E                  <1>         pop     si                                      ;
    72 00000166 07                  <1>         pop     es                                      ;
    73 00000167 5A                  <1>         pop     dx                                      ;
    74 00000168 59                  <1>         pop     cx                                      ;
    75 00000169 5B                  <1>         pop     bx                                      ;
    76                              <1> 
    77                              <1>         ;________________________________________________
    78                              <1>         ; スタックフレームの破棄
    79                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    80 0000016A 89EC                <1>         mov     sp , bp                                 ;
    81 0000016C 5D                  <1>         pop     bp                                      ;
    82                              <1> 
    83 0000016D C3                  <1>         ret                                             ; もとのとこへ
    84                              <1> 
    85                              <1> ; (関数の概要(セクタを読み出す関数です))
    86                              <1> ; 0. BIOS(0x13,0x02)はAH(セクタ読み込み数),AL(0x13の引数),CH(シリンダ),CL(セクタ番号,な
    87                              <1> ;    お上位二ビットはシリンダ(CH)の9,10ビット目の役割),DH(ヘッド番号),DL(ドライブ番号)
    88                              <1> ;    driveは第一引数であるが(ドライブ番号,シリンダ,ヘッド,セクタ)への配列を渡す
    89                              <1> ; 1. スタックフレームの構築をして
    90                              <1> ; 2. レジスタの保存をして
    91                              <1> ; 3. "mov si,[bp+4]" 第一引数へアクセスします、受け取る引数には(nomber,cyln,head,sect)の
    92                              <1> ;    パラメーターが入ったアドレスが含まれています、siレジスを基にそれぞれの値へ次アクセスします
    93                              <1> ; 4. (CXレジスタの設定(BIOSコールへの準備))
    94                              <1> ;    CXレジスタの設定を行います、86CPUはリトルエディアンなプロセッサなので
    95                              <1> ;    メモリアクセスの際、上位レジスタが下位バイトへ下位レジスタが上位バイトへとメインメモリへと
    96                              <1> ;    書きこまれるので一バイトアクセスのときに注意します
    97                              <1> ; 5. (DHレジスタの設定とコピー先の設定(BIOSコールへの準備))
    98                              <1> ;    先程得たパラメーターを参照してBIOSコールを発行する準備をDHレジスタに施します
    99                              <1> ; 6. (セクタの読み込み(いざBIOSコールを発行します))
   100                              <1> ;    ALレジスタをそれぞれ設定してBIOSを呼び覚まします、発行したらCFを確認して成功したか非かを
   101                              <1> ;    確かめ、CFが0すなわち成功だったらALレジスタのセクタ読み込み数を確認し読み込んだセクタがあ
   102                              <1> ;    ったなら読み込みセクタ数を保持して関数の終了へ、もしALレジスタが0だったらセクタ読み出し数の
   103                              <1> ;    参照からretry変数分だけやり直します、戻り値は、AXレジスタが0です、CFが1すなわち失敗だった
   104                              <1> ;    ら戻り値に0を設定して関数の終了です
   105                              <1> ; 7. レジスタの復帰をして
   106                              <1> ; 8. スタックフレームを破棄して
   107                              <1> ; 9. もとのところへ戻っていきます
    80                                  
    81                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    82                                      ; ブートフラグの設定 (先頭512バイトの終了)
    83                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;p;;;;;;;;;;;;;;;;;;;;;;;;;;
    84 0000016E 00<rept>                        times 510 - ($ - $$) db 0x00                    ; IPL領域を浸す
    85 000001FE 55AA                            db      0x55 , 0xAA                             ; 0x55 0xAA
    86                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    87                                      ; モジュール (先頭512バイト以降に配置)
    88                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    89                                      %include "/home/m8ku/prog/src/modules/real/itoa.asm"
     1                              <1> ;itoa(num,buff,size,radix,flags) //B0,値を符号付か  B1,+-付加するか B2,0で空白埋めるか
     2                              <1> itoa:
     3                              <1> ;                                                       ;    +12| フラグ
     4                              <1> ;                                                       ;    +10| 基数
     5                              <1> ;                                                       ;    + 8| バッファサイズ
     6                              <1> ;                                                       ;    + 6| バッファアドレス
     7                              <1> ;                                                       ;    + 4| 数値
     8                              <1> ;                                                       ;    + 2| IP(元の値)
     9 00000200 55                  <1>         push    bp                                      ; BP + 0| BP(元の値)
    10 00000201 89E5                <1>         mov     bp , sp                                 ; ------+--------
    11                              <1> 
    12 00000203 50                  <1>         push    ax                                      ; //各レジスタの保存
    13 00000204 53                  <1>         push    bx                                      ;
    14 00000205 51                  <1>         push    cx                                      ;
    15 00000206 52                  <1>         push    dx                                      ;
    16 00000207 56                  <1>         push    si                                      ;
    17 00000208 57                  <1>         push    di                                      ;
    18 00000209 9C                  <1>         pushf                                           ;
    19                              <1> 
    20 0000020A 8B4604              <1>         mov     ax , [bp + 4]                           ; // 第一引数へアクセス
    21 0000020D 8B7606              <1>         mov     si , [bp + 6]                           ; // 第二引数へアクセス
    22 00000210 8B4E08              <1>         mov     cx , [bp + 8]                           ; // 第三引数へアクセス
    23                              <1> 
    24 00000213 89F7                <1>         mov     di , si                                 ; // バッファの終端
    25 00000215 01CF                <1>         add     di , cx                                 ; //dst = &dst-[size-1]
    26 00000217 4F                  <1>         dec     di                                      ; //buffを超えないようdec
    27                              <1> 
    28 00000218 8B5E0C              <1>         mov     bx , [bp + 12]                          ; //第五引数へアクセス
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> ; 符号付き判定
    31                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32 0000021B F7C30100            <1>         test    bx , 0b0001                             ; if(flags & 0x01)//判定
    33 0000021F 7408                <1> .10Q:   je      .10E                                    ; {
    34 00000221 83F800              <1>         cmp     ax , 0                                  ;   if(val < 0)
    35 00000224 7D03                <1> .12Q:   jge     .10E                                    ;   {
    36 00000226 83CB02              <1>         or      bx , 0b0010                             ;     flags |= 2; //表示
    37                              <1> .12E:                                                   ;   }
    38                              <1> .10E:                                                   ; }
    39                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    40                              <1> ; 符号出力判定
    41                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    42 00000229 F7C30200            <1>         test    bx , 0b0010                             ; if(flags & 0x02)出力判定
    43 0000022D 7410                <1> .20Q:   je      .20E                                    ; {
    44 0000022F 83F800              <1>         cmp     ax , 0                                  ;   if(val < 0)
    45 00000232 7D07                <1> .22Q:   jge     .22F                                    ;   {
    46 00000234 F7D8                <1>         neg     ax                                      ;   val *= -1;//符号反転
    47 00000236 C6042D              <1>         mov     [si] , byte '-'                         ;   *dst = '-';//符号表示
    48 00000239 EB03                <1>         jmp     .22E                                    ;   }
    49                              <1> .22F:                                                   ;   else{
    50 0000023B C6042B              <1>         mov     [si] , byte '+'                         ;   　*dst = '+';//符号表示
    51                              <1> .22E:                                                   ;   }
    52 0000023E 49                  <1>         dec     cx                                      ;   size --;//バッファ減算
    53                              <1> .20E:                                                   ; }
    54                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    55                              <1> ; ASCII変換
    56                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    57 0000023F 8B5E0A              <1>         mov     bx , [bp+10]                            ; //第四引数へアクセス
    58                              <1> .30L:                                                   ; do
    59                              <1> ;                                                       ; {
    60 00000242 BA0000              <1>         mov     dx , 0                                  ;　
    61 00000245 F7F3                <1>         div     bx                                      ; AX=DX:AX / BX(基数);
    62                              <1> ;                                                       ; DX=DX:AX % BX(基数);
    63                              <1> ;                                                       ;
    64 00000247 89D6                <1>         mov     si , dx                                 ; // テーブル参照
    65 00000249 8A94[7202]          <1>         mov     dl , byte [.ascii + si]                 ; DL=ASCII[DX];
    66                              <1> 
    67 0000024D 8815                <1>         mov     [di] , dl                               ; dst* = DL;
    68 0000024F 4F                  <1>         dec     di                                      ; dst--    ;
    69                              <1> 
    70 00000250 83F800              <1>         cmp     ax , 0                                  ;
    71 00000253 E0ED                <1>         loopnz .30L                                     ; } while (AX);
    72                              <1> .30E:
    73                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    74                              <1> ; 空白を埋める
    75                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    76 00000255 83F900              <1> .40Q:   cmp     cx , 0                                  ; if(size)
    77 00000258 740D                <1>         je      .40E                                    ; {
    78 0000025A B020                <1>         mov     al , ' '                                ; AL = ' ';//' 'で埋める
    79 0000025C 837E0C04            <1>         cmp     [bp + 12] , word 0b0100                 ;  if(flags & 0x04)
    80 00000260 7502                <1> .42Q:   jne     .42E                                    ;  {
    81 00000262 B030                <1>         mov     al , '0'                                ;  AL = '0';//'0'で埋める
    82                              <1> .42E:                                                   ;  }
    83 00000264 FD                  <1>         std                                             ; //DF = 1//(-方向)
    84 00000265 F3AA                <1>         rep     stosb                                   ; while(--CX) *DI--=' ';
    85                              <1> .40E:                                                   ; }
    86                              <1> 
    87 00000267 9D                  <1>     popf                                                ; //各レジスタの復帰
    88 00000268 5F                  <1>     pop     di                                          ;
    89 00000269 5E                  <1>     pop     si                                          ;
    90 0000026A 5A                  <1>     pop     dx                                          ;
    91 0000026B 59                  <1>     pop     cx                                          ;
    92 0000026C 5B                  <1>     pop     bx                                          ;
    93 0000026D 58                  <1>     pop     ax                                          ;
    94                              <1> 
    95 0000026E 89EC                <1>     mov     sp , bp                                     ; //スタックフレームの破棄
    96 00000270 5D                  <1>     pop     bp                                          ;
    97                              <1> 
    98 00000271 C3                  <1>     ret                                                 ; //もとのとこへ
    99                              <1> 
   100 00000272 303132333435363738- <1> .ascii: db      "0123456789ABCDEF"                      ; 変換テーブル
   100 0000027B 39414243444546      <1>
   101                              <1> 
   102                              <1> ;(関数の概要(数値を文字列に変換する関数です))
   103                              <1> ; 1. スタックフレームを構築します
   104                              <1> ; 2. 各レジスタを保存します
   105                              <1> ; 3. 各引数へアクセスすると共に後に利用する値を練ります、この関数は右詰めに文字コードを保存して
   106                              <1> ;    いき左側を空白などで埋めます、そのためにバッファアドレスからバッファサイズを足して右端へア
   107                              <1> ;    ドレスを設定します、しかしこのままだと指定されたサイズを超えて一文字目を保存してしまいます
   108                              <1> ;    もし保存先バッファアドレスが0x3000保存先バッファサイズが3Byteだったとして下の図で考えて
   109                              <1> ;    いくと3000+3で3003になってバッファを超えた∇へアクセスしてオーバーフローが起きてしまうので
   110                              <1> ;    作った数値からデクリメントしてあげます     ↓
   111                              <1> ;    __________ __________ __________ __________
   112                              <1> ;   | 3000番地 || 3001番地 || 3002番地 ||3003番地 |
   113                              <1> ;    ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^
   114                              <1> ; (符号付き判定)
   115                              <1> ; 1. 引数として受け取る値の中にビット定義のフラグが含まれていますフォーマットはB0が"値を符号付
   116                              <1> ;    き変数として扱う"B1が"'+/-'記号を付加する"B2が"空白を'0'で埋める"です、そしてこれらの前
   117                              <1> ;    準備をこちらでします、ビット定義のフラグの引数はbxレジスタへ転送してあります
   118                              <1> ; 2. 'test bx,0b0001'ではフラグのB0を検査し符号付き整数として扱うかどうかを判断します、test
   119                              <1> ;    命令はdstとsrcのAND演算を行い結果に応じてZF(ゼロフラグ)を設定します'test 0b01,0b01'だ
   120                              <1> ;    ったらZFは1,"test 0b01,0b00"だったらZFは0が設定されます、そして"je .10E"で分岐をしま
   121                              <1> ;    す、jeはZFを検査して0だったらそのまま続いて1だったらオペランドのアドレスへジャンプします、
   122                              <1> ;    次'cmp ax,0'で比較して'jge .10E'で条件分岐を行いますjgeは符号付き条件分岐命令ですので
   123                              <1> ;    負の数値でも条件分岐ができます、もしaxが0より小さかったらbxレジスタを0b0010でor演算しB1
   124                              <1> ;    を設定します
   125                              <1> ; (符号出力判定)
   126                              <1> ; 1. test命令でB1を検査しB1が立っていたら後へ続きます、次'cmp ax,0'で比較して'jge .22F'
   127                              <1> ;    で条件分岐を行いますjgeは符号付き条件分岐命令ですので負の数値でも条件分岐ができます、もし
   128                              <1> ;    axが0より小さかったら'-'符号をもしaxが0より大きいなら'+'符号を付加します、もし負の数だっ
   129                              <1> ; 　 たとしては負の数値のままだと後のASCII変換で期待した値を取得できないのでneg命令で二の補数反
   130                              <1> ; 　 転をして符号を反転します、そしてバッファを一つ利用したので残りバッファ数を保持しているcxレジ
   131                              <1> ;    スタをデクリメントします
   132                              <1> ; (ASCII変換)
   133                              <1> ; 1. 基数を取得して後続のプログラムへ備えます
   134                              <1> ; 2. 数値を文字列に変換する系統です、どうやって変換するかというと、数値を基数で除算し数値が0とな
   135                              <1> ; 　 るまで繰り返します、基数が2なら2進数の値、奇数が10なら10進数の値といった具合で文字列が得ら
   136                              <1> ;    れます、そのとき除算の余りを元に文字列を組み立てていくのですが、ある数値を除算して得られた
   137                              <1> ;    余りの数を変換テーブルへの索引として文字変換しLOOPNZ命令により残りバッファサイズ(cx)と変
   138                              <1> ;    換する値(ax)がが0になるまで繰り返します加えてその時必要となる文字列変換テーブルをソースコ
   139                              <1> ;    ードの一番最後、関数の最後付近に定義しています
   140                              <1> ; 3. 'mov dx,0'でdxレジスタに0を転送していますがこれは繰り返し行う過程で除算による余りがdxレ
   141                              <1> ;    ジスタに転送されるのですがx86CPUの除算では"AX=DX:AX/オペランド"という具合に被演算子にdx
   142                              <1> ;    レジスタが含まれているので繰り返しの過程でdxレジスタを初期化してやります
   143                              <1> ; 4. 'div bx'でaxレジスタの値をbxレジスタの値(基数)で除算します、このとき余りはdxレジスタへ商
   144                              <1> ;     はaxレジスタへそれぞれ格納されます、得られた商をまた次の繰り返しで除算します
   145                              <1> ; 5. 'mov si,dx'で先程の除算で得られた余剰をsiレジスタへ転送します、
   146                              <1> ; 6. 'mov dl,byte [.ascii+si]'で得られた余剰から文字コードを取得します、余剰をインデックス
   147                              <1> ;    として[.axcii+si]といった具合で変換テーブルへアクセスして得られるASCII文字をdlレジスタ
   148                              <1> ;    へ書き込みます
   149                              <1> ; 7. 'mov [di],dl'として先程得た文字コードを転送先アドレスを保持するdiレジスタをメモリオペラ
   150                              <1> ;    ンドにしてメモリへ文字コードを転送します
   151                              <1> ; 8. 'dec di'で次に保存する値へ備えてアドレスをデクリメントして保存位置を左へ一つずらします
   152                              <1> ; 9. 'cmp ax,0'で比較をして次のloopnzへ備えます
   153                              <1> ;10. 'loopnz .30L'では繰り返しを続けるかの有無を判断します、loopnzはCX=0,ZF=0の時オペランド
   154                              <1> ;    で指定したオフセットへジャンプします、ですのでバッファを使い切るか数値が0になるまで除算した
   155                              <1> ;    なら文字変換の繰り返しは終了します、先のことを言い換えてloopnzの終了条件はCX=0,ZF=1とな
   156                              <1> ;    ります加えてloopzの終了条件はCX=0,ZF=0、また1/2をすると0になります、
   157                              <1> ;11. そして3から10を繰り返したならば文字列が出来上がります
   158                              <1> ; (空白を埋める);
   159                              <1> ; 1. 'cmp cx,0'で比較をして条件分岐に備えます
   160                              <1> ; 2. 'je .40E'で残りのバッファがなかったらそのまま関数の終了へ移動します
   161                              <1> ; 3. 'cmp [bp+12,word 0b0100]'と'jne .42E'でもしビット定義のフラグ,B3が立っていたら'0'で
   162                              <1> ;     残りバッファを埋めて立っていなかったら空白で埋める条件分岐をJump If not equal(ZF=0)で
   163                              <1> ;     します
   164                              <1> ; 4. 'std'と'rep stosb'で残りのバッファを埋めます、stdでDFフラグをセットして後続のストリング
   165                              <1> ;    命令へ備えます、stosbはalレジスタの内容をdiレジスタのメモリアドレスを一バイトずつ転送する
   166                              <1> ;    と共にDFフラグが1ならdiレジスタをインクリメントし0だったらデクリメントへすることでアドレス
   167                              <1> ;    の増減をサポートする命令でrepはcxレジスタの値が0だったら転送を止めるプレフィックスで、そう
   168                              <1> ;    して残りのバッファ分を埋めることができるようになります
   169                              <1> 
   170                              <1> ; 4. スタックを復帰して
   171                              <1> ; 5. スタックフレームを取り外して
   172                              <1> ; 6. 'ret'で前にいた番地へ戻ります
    90                                      %include "/home/m8ku/prog/src/modules/real/get_drive_param.asm"
     1                              <1> ;get_drive_para(drive) 引数((× AX=0) (〇 AX≠0))
     2                              <1> get_drive_param:
     3 00000282 55                  <1>         push    bp                                      ; スタックフレームの構築
     4 00000283 89E5                <1>         mov     bp , sp                                 ;
     5 00000285 6A03                <1>         push    3                                       ; int retry = 3;
     6                              <1> 
     7 00000287 53                  <1>         push    bx                                      ; 格レジスタの保存
     8 00000288 51                  <1>         push    cx                                      ;
     9 00000289 06                  <1>         push    es                                      ;
    10 0000028A 56                  <1>         push    si                                      ;
    11 0000028B 57                  <1>         push    di                                      ;
    12 0000028C 9C                  <1>         pushf                                           ;
    13                              <1> 
    14 0000028D 8B7604              <1>         mov     si , [bp + 4]                           ; SI = バッファ
    15 00000290 B80000              <1>         mov     ax , 0                                  ; DiskBaseTablePointer=0
    16 00000293 8EC0                <1>         mov     es , ax                                 ; ES = 0;
    17 00000295 89C7                <1>         mov     di , ax                                 ; DI = 0;
    18                              <1> 
    19                              <1> .10L:
    20 00000297 B408                <1>         mov     ah , 0x8                                ; //Get drive parameters
    21 00000299 8A14                <1>         mov     dl , [si + drive.no]                    ; DL = drive.no;
    22 0000029B CD13                <1>         int     0x13                                    ; CF = BIOS(0x13,8);
    23 0000029D 721B                <1> .10Q:   jc      .10F                                    ; if (0 == CF)
    24                              <1> .10T:                                                   ; {
    25 0000029F 88C8                <1>         mov     al , cl                                 ;   AX = セクタ数
    26 000002A1 83E03F              <1>         and     ax , 0x3F                               ;   //下位6ビットのみ有効
    27                              <1> 
    28 000002A4 C0E906              <1>         shr     cl , 6                                  ;   CX = シリンダ数
    29 000002A7 C1C908              <1>         ror     cx , 8                                  ;
    30 000002AA 41                  <1>         inc     cx                                      ;
    31                              <1> 
    32 000002AB 0FB6DE              <1>         movzx   bx , dh                                 ;   BX = ヘッド数
    33 000002AE 43                  <1>         inc     bx                                      ;
    34                              <1> 
    35 000002AF 894C02              <1>         mov     [si + drive.cyln + 0] , cx              ;   drive.syln = CX; //C
    36 000002B2 895C04              <1>         mov     [si + drive.head] , bx                  ;   drive.head = BX; //H
    37 000002B5 894406              <1>         mov     [si + drive.sect] , ax                  ;   drive.sect = ax; //S
    38                              <1> 
    39 000002B8 EB08                <1>         jmp     .10E                                    ;   break;
    40                              <1> ;                                                         }elese{
    41                              <1> .10F:                                                   ;   AX = 0;
    42 000002BA B80000              <1>         mov     ax , 0                                  ; }
    43 000002BD FF4EFE              <1>         dec     word [bp - 2]                           ;
    44 000002C0 75D5                <1>         jnz     .10L                                    ; while (retry--)
    45                              <1> .10E:                                                   ;
    46                              <1> 
    47 000002C2 9D                  <1>         popf                                            ; レジスタの復帰
    48 000002C3 5F                  <1>         pop     di                                      ;　
    49 000002C4 5E                  <1>         pop     si                                      ;
    50 000002C5 07                  <1>         pop     es                                      ;
    51 000002C6 59                  <1>         pop     cx                                      ;
    52 000002C7 5B                  <1>         pop     bx                                      ;
    53                              <1> 
    54 000002C8 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    55 000002CA 5D                  <1>         pop     bp                                      ;
    56                              <1> 
    57 000002CB C3                  <1>         ret                                             ; ただいま
    58                              <1> 
    59                              <1> ; 関数の概要(ドライブパラメータを取得する関数です)
    60                              <1> ; 0. AHレジスタに0x8番,0x13番のBIOSコールでディスクの情報をCX,DXレジスタにそれぞれ書き込んで
    61                              <1> ;    くれます、CF==0が成功です、ソースコード中ではAX,BX,CXレジスタに値を移動し上手く値を練って
    62                              <1> ;    最後にしてのメモリ領域に値を返します、そして引数はセクタ数が返され読込できなかったら0を返し
    63                              <1> ;    ます.
    64                              <1> ; 1. スタックフレームを作って.
    65                              <1> ; 2. レジスタを保存して.
    66                              <1> ; 3. 'mov si,[bp+4]'で取得した値を指定の領域に書き込むのための準備をします.
    67                              <1> ; 4. 'mov ah,0x8'でドライブパラメータの取得'mov dl,[si+drive.no]'でブートプログラムで既に
    68                              <1> ;     知っているドライブ番号を指定してバイオスコール12番を発行します、成功か否かで分岐します.
    69                              <1> ; 5.  'jc .10F'で成功か否かで行く先を決めてあげます、〇だったら後続のアドレスへ×だったなら当該
    70                              <1> ;     アドレスへジャンプします.
    71                              <1> ; 5. <ここからは、レジスタのビット単位で指定されている変則的な値を上手く整理していきます>
    72                              <1> 
    73                              <1> ;    (AX = セクタ数)
    74                              <1> ;    'mov al,cl'でセクタ数をALレジスタに連れてきます.
    75                              <1> ;    'and ax 0x3F'で下位6ビットのみ有効にします、なぜならばCLレジスタの6,7ビット目にシリンダ
    76                              <1> ;    の値をも含まれているからです、0x3Fは二進数で表すと 00111111 です.これでセクタの値だけを
    77                              <1> ;    取り出す事ができます.
    78                              <1> ;        ________     ________     ________
    79                              <1> ;       |11111111| × |00111111| = |00111111|
    80                              <1> ;        ^^^^^^^^     ^^^^^^^^     ^^^^^^^^
    81                              <1> 
    82                              <1> ;    (CX = シリンダ数)
    83                              <1> ;    シリンダ数はCXレジスタに含まれているのでCXレジスタの値をそのまま流用します
    84                              <1> ;    'shr cl,6'で6回ビットをシフトします、なぜならばCLレジスタの6,7ビット目に全体で見るシリン
    85                              <1> ;    ダ数の9,10ビット目が含まれているからです.
    86                              <1> ;    'ror cx,6'ではシリンダ数の真なる値をつくります、ror命令はシフトにより押し出された最上位
    87                              <1> ;    ビットを再下位ビットへ順次コピーしていく命令です、これによりビット循環を実現できます.
    88                              <1> ;          CH         CL                        CH         CL
    89                              <1> ;        ________   ________                  ________   ________
    90                              <1> ;       |11111111| |11000000| 'shl cl,6' →   |11111111| |00000011|
    91                              <1> ;        ^^^^^^^^   ^^^^^^^^                  ^^^^^^^^   ^^^^^^^^
    92                              <1> ;          CH         CL                              CX
    93                              <1> ;        ________   ________                  ________   ________
    94                              <1> ;       |11111111| |00000011| 'ror cx,8' →   |00000011| |11111111|
    95                              <1> ;        ^^^^^^^^   ^^^^^^^^                  ^^^^^^^^   ^^^^^^^^
    96                              <1> ;                                                    ∧ こっちに移動した
    97                              <1> ;    'inc cx'でCXレジスタの値をインクリメントします、というのもシリンダの番号の指定は0始まり
    98                              <1> ;    なのですが対してセクタの番号の指定は1始まりです、ですのでシリンダ数を一つ足してやります、
    99                              <1> ;    シリンダの最終番号ではなくシリンダがいくつ存在するかを知りたいためだと思います//.
   100                              <1> 
   101                              <1> ;    (BX = ヘッド数)
   102                              <1> ;    'movzx bx,dh'ではDHレジスタからBXレジスタへゼロ拡張転送を行います、movzx命令は1バイト
   103                              <1> ;    の第二オペランドを2バイトの第一オペランドへ拡大コピーします.拡大というのは1バイトレジスタ
   104                              <1> ;    の値を2バイトレジスタの下位バイトへ移動して空きを0で埋めことです.
   105                              <1> ;    "inc bx"で先程の(CX = シリンダ数)と同様の理由でインクリメントしてやります.
   106                              <1> ;          DH         DL                              BX
   107                              <1> ;        ________   ________                   ________________
   108                              <1> ;       |11111111| |00000000| 'movzx bx,dh' → |0000000011111111|
   109                              <1> ;        ^^^^^^^^   ^^^^^^^^                   ^^^^^^^^^^^^^^^^
   110                              <1> ; 6. 既に.3で書き込み場所は取得しているのでに定義している構造体の＜syln,head,sect＞を利用しな
   111                              <1> ;    がら整理した値をいよいよメモリへ書き込みます.
   112                              <1> ; 7. 'jmp .10E'CF==0だったときにすることはこれで終了ですので関数の終了まで連れていきます.
   113                              <1> ; 8. 'mov ax,0'~'jnz .10L'CF==1だったときはretry変数分だけバイオスコールから回るようにして
   114                              <1> ;     みました.
   115                              <1> ; 9. レジスタを復帰して.
   116                              <1> ;10. スタックフレームを壊して.
   117                              <1> ;11. ただいま.
    91                                  
    92                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    93                                      ; ブートプログラムの第二ステージ ▽
    94                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    95                                  stage_2:
    96                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    97                                          ; 文字列を表示
    98                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    99 000002CC 68[6203]E8EEFD83C4-             cdecl puts, .s0                                 ; puts(.s0);
    99 000002D4 02                 
   100                                  
   101                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   102                                          ; ドライブ情報を取得
   103                                          ;;;:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   104 000002D5 68[B800]E8A7FF83C4-             cdecl   get_drive_param, BOOT                   ; get_drive_param(BOOT);
   104 000002DD 02                 
   105 000002DE 83F800                          cmp     ax , 0                                  ; if (0 == AX)
   106 000002E1 750C                    .10Q:   jnz     .10E                                    ; {
   107 000002E3 68[A403]E8D7FD83C4-     .10T:   cdecl   puts, .e0                               ;   puts(.e0);
   107 000002EB 02                 
   108 000002EC E8F2FD                          call    reboot                                  ;   reboot(); //再起動
   109                                  .10E:                                                   ; }
   110                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   111                                          ; ドライブ情報を表示
   112                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   113 000002EF A1[B800]                        mov     ax , [BOOT + drive.no]                  ; AX = ブートドライブ
   114 000002F2 6A046A106A0268-                 cdecl   itoa, ax, .p1, 2, 16, 0b0100            ;
   114 000002F9 [8503]50E801FF83C4-
   114 00000301 0A                 
   115                                  
   116 00000302 A1[BA00]                        mov     ax , [BOOT + drive.cyln]                ; AX = シリンダ(トラック)数
   117 00000305 6A046A106A0468-                 cdecl   itoa, ax, .p2, 4, 16, 0b0100            ;
   117 0000030C [8D03]50E8EEFE83C4-
   117 00000314 0A                 
   118                                  
   119 00000315 A1[BC00]                        mov     ax , [BOOT + drive.head]                ; AX = ヘッド数
   120 00000318 6A046A106A0268-                 cdecl   itoa, ax, .p3, 2, 16, 0b0100            ;
   120 0000031F [9703]50E8DBFE83C4-
   120 00000327 0A                 
   121                                  
   122 00000328 A1[BE00]                        mov     ax , [BOOT + drive.sect]                ; AX=トラックあたりのセクタ数
   123 0000032B 6A046A106A0268-                 cdecl   itoa, ax, .p4, 2, 16, 0b0100            ;
   123 00000332 [9F03]50E8C8FE83C4-
   123 0000033A 0A                 
   124                                  
   125 0000033B 68[7C03]E87FFD83C4-             cdecl   puts, .s2                               ; puts(.s2); //情報を表示
   125 00000343 02                 
   126                                  
   127                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   128                                          ; 数値を表示
   129                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   130 00000344 B8630F                          mov     ax , 3939                               ;
   131 00000347 6A016A0A6A0868-                 cdecl itoa, ax, .s1, 8, 10, 0b0001              ;
   131 0000034E [7103]50E8ACFE83C4-
   131 00000356 0A                 
   132 00000357 68[7103]E863FD83C4-             cdecl puts, .s1                                 ; puts(.s1);
   132 0000035F 02                 
   133                                  
   134                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   135                                          ; プログラムの終了
   136                                          ;;;;;;.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   137 00000360 EBFE                            jmp     $                                       ; while (1) ; // ∞
   138                                  
   139                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   140                                          ; データ
   141                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   142 00000362 326E64207374616765-     .s0     db  "2nd stage...", 0x0A, 0x0D, 0
   142 0000036B 2E2E2E0A0D00       
   143 00000371 2D2D2D2D2D2D2D2D0A-     .s1     db  "--------", 0x0A , 0x0D , 0
   143 0000037A 0D00               
   144 0000037C 2044726976653A3078      .s2     db  " Drive:0x"
   145 00000385 2D2D2C20433A3078        .p1     db  "--, C:0x"
   146 0000038D 2D2D2D2D2C20483A30-     .p2     db  "----, H:0x"
   146 00000396 78                 
   147 00000397 2D2D2C20533A3078        .p3     db  "--, S:0x"
   148 0000039F 2D2D0A0D00              .p4     db  "--", 0x0A, 0x0D, 0
   149                                  
   150 000003A4 4572726F723A43616E-     .e0     db  "Error:Can't get parameter.", 0
   150 000003AD 277420676574207061-
   150 000003B6 72616D657465722E00 
   151                                  
   152                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   153                                          ; パディング (このファイルは8Kバイトとする)
   154                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   155 000003BF 00<rept>                        times (BOOT_SIZE - ($ - $$)) db 0x00            ; 8KByte
