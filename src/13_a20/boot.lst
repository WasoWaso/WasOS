     1                                  ;boot()
     2                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     3                                  ; マクロ
     4                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                          %include "/home/m8ku/prog/src/include/macro.asm"
     1                              <1> ;cdecl(),drive()
     2                              <1> %macro  cdecl   1-*.nolist
     3                              <1> 
     4                              <1>     %rep %0 - 1
     5                              <1> 
     6                              <1>         push    %{-1 : -1}
     7                              <1>         %rotate -1
     8                              <1> 
     9                              <1>     %endrep
    10                              <1> 
    11                              <1>     %rotate -1
    12                              <1>     call    %1
    13                              <1> 
    14                              <1>     %if 1 < %0
    15                              <1> 
    16                              <1>         add     sp , (__BITS__>>3) * (%0 - 1)
    17                              <1> 
    18                              <1>     %endif
    19                              <1> 
    20                              <1> %endmacro
    21                              <1> ;(マクロの概要(関数呼び出しのための関数です))
    22                              <1> ; 1.cdeclとしてマクロを定義して、引数は１からの可変長として、リスト出力の抑止を指定する(.lst)
    23                              <1> ; 2.%repから、もらった引数から関数分を差し引いた %0 - 1 回として %endrep まで繰り返します
    24                              <1> ; 3.関数呼び出しに備えるために引数をスタックに積んでいきます、%{-1 : -1 }はもらった引数全体の
    25                              <1> ;   終端を表しています ですので、受け取った引数が putc , ax , bx だとして一回目のループでbx
    26                              <1> ;   がスタックに積ます、次の%rotateは引数を回転します例えば (1,2,3)が(3,1,2)になります今回
    27                              <1> ;   は右に回転させたいので-1と指定していますが左に回転させたい場合は+を指定してやります、そして
    28                              <1> ;   (bx,putc,ax)になり次のループで引数の終端axが積んでから引数を回転(ax,bx,putc)となります
    29                              <1> ;   そして今回の例だとここで繰り返しが終了します
    30                              <1> ; 3.今回の例の続きで引数を回転させて(putc,ax,bx)となって
    31                              <1> ; 4.第一引数の名前の関数を呼び出します、今回の例では第一引数はputcとなっているのでputcという関
    32                              <1> ;   数が呼び出されることとなります
    33                              <1> ; 5.後に関数に引数として積んだスタックを調整してやるのですがマクロに引数を一つもしてしていないの
    34                              <1> ;   にもかかわらずスタックポインタを調節されては困るから条件式に当てはまったら処理をするようにし
    35                              <1> ;   てあげます今回だと一つ以上の引数が指定されたらです
    36                              <1> ; 6.関数を呼び出したら呼び出し側がスタックを調節してやらなければいけないのでスタックを調節します
    37                              <1> ;   スタックポインタレジスタに,(__BITS__>>3)*(%0 - 1 )を計算して書き込みます、__BITS__の
    38                              <1> ;   意味はNASMに元々組み込まれているマクロで16bit,32bit,64bitの判定を行います、16bitのプロ
    39                              <1> ;   グラムだったとして16を左へ3回シフトして(>>のところ)2が得られます32だったら4、64だったら8
    40                              <1> ;   、そしてCPUアーキテクチャ単位でスタックの料理ができるようになります、(%0 - 1)で引数の数を
    41                              <1> ;   だして、さきほどだした2と今回出した2をかけて4,積んだ引数は2つなのでビンゴです、spに4を加算
    42                              <1> ;   して関数呼び出しのすべての処理が終わりました
    43                              <1> ; 7.条件処理を終えます
    44                              <1> ; 8.マクロの終了です
    45                              <1> 
    46                              <1> struc drive
    47 00000000 <res 00000002>      <1>         .no     resw    1                               ; ドライブ番号
    48 00000002 <res 00000002>      <1>         .cyln   resw    1                               ; シリンダ
    49 00000004 <res 00000002>      <1>         .head   resw    1                               ; ヘッド
    50 00000006 <res 00000002>      <1>         .sect   resw    1                               ; セクタ
    51                              <1> 
    52                              <1> endstruc
    53                              <1> ;(マクロの概要(構造体の定義をしています))
    54                              <1> ; 0. ディスクアクセスに必要な情報をソースコードに更新する形で利用します、
    55                              <1> ;    次に更新する例を示します
    56                              <1> ;   istruc drive
    57                              <1> ;       at .sect dw 2                                   ; S:セクタ
    58                              <1> ;   iend
     6                                          %include "/home/m8ku/prog/src/include/define.asm"
     1                              <1> ;define()
     2                              <1>         BOOT_LOAD       equ     (0x7C00)                ; ブートプログラムロード位置
     3                              <1>         BOOT_SIZE       equ     (1024 * 8)              ; ブートコードサイズ
     4                              <1>         SECT_SIZE       equ     (512)                   ; セクタサイズ 512B
     5                              <1>         BOOT_SECT       equ     (BOOT_SIZE / SECT_SIZE) ; ブートプログラムのセクタ数
     6                              <1>         E820_RECORD_SIZE    equ 20                      ; メモリ情報の格納サイズ20B
     7                              <1> ; (定義の概要)
     8                              <1> ; 0. それぞれdefineしています、ソースコードにうまく取り込もう
     7                                  
     8                                          ORG     BOOT_LOAD                               ; プログラムの開始位置を設定
     9                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    10                                  ; エントリポイント
    11                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    12                                  entry:
    13                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                                          ; BPB( BIOS Parameter Block )
    15                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    16 00000000 EB58                            jmp     ipl                                     ; IPLラベルへ移動
    17 00000002 90<rept>                        times  90 - ( $ - $$ ) db 0x90                  ; BPB領域を確保
    18                                  ipl:
    19                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    20                                          ; IPL( Initial Program Loader )
    21                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    22 0000005A FA                              cli                                             ; //割り込み禁止
    23                                  
    24 0000005B B80000                          mov     ax , 0x0000                             ; AX=0x0000
    25 0000005E 8ED8                            mov     ds , ax                                 ; DS=0x0000
    26 00000060 8EC0                            mov     es , ax                                 ; ES=0x0000
    27 00000062 8ED0                            mov     ss , ax                                 ; SS=0x0000
    28 00000064 BC007C                          mov     sp , BOOT_LOAD                          ; SP=0x7c00
    29                                  
    30 00000067 FB                              sti                                             ; //割り込み許可
    31                                  
    32 00000068 8816[B800]                      mov     [BOOT + drive.no] , dl                  ; ドライブ番号
    33                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    34                                          ; 文字列を表示
    35                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    36 0000006C 68[9900]E84E0083C4-             cdecl   puts , .s0                              ; puts(.s0);//Booting...
    36 00000074 02                 
    37                                  
    38                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                                          ; 次の５１２バイトを読み込む
    40                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    41 00000075 BB0F00                          mov     bx , BOOT_SECT - 1                      ; BX = 残りのブートセクタ数
    42 00000078 B9007E                          mov     cx , BOOT_LOAD + SECT_SIZE              ; CX = 次のロードアドレス
    43                                  
    44 0000007B 515368[B800]E89D00-             cdecl   read_chs, BOOT,  bx, cx                 ; セクタ読み出し関数の発行
    44 00000083 83C406             
    45                                  
    46                                  
    47 00000086 39D8                            cmp     ax , bx                                 ; if(AX!=BX)
    48 00000088 740C                    .10Q:   jz      .10E                                    ; {
    49 0000008A 68[A600]E8300083C4-     .10T:   cdecl   puts, .e0                               ; puts(.e0); //メッセージ
    49 00000092 02                 
    50 00000093 E84B00                          call    reboot                                  ; reboot();  //再起動
    51                                  .10E:                                                   ; }
    52                                  
    53                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    54                                          ; 次のステージへ移行
    55                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    56 00000096 E97E05                          jmp     stage_2nd                               ;
    57                                  
    58                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    59                                          ; データ
    60                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    61 00000099 426F6F74696E672E2E-     .s0:    db  "Booting..." , 0x0A , 0x0D , 0              ;
    61 000000A2 2E0A0D00           
    62 000000A6 4572726F723A736563-     .e0:    db  "Error:sector read", 0                      ;
    62 000000AF 746F72207265616400 
    63                                  
    64                                          align       2       , db 0                      ;
    65                                  BOOT:
    66                                          istruc  drive
    67 000000B8 0000                                at drive.no,    dw  0                       ; ドライブ番号
    68 000000BA 0000                                at drive.cyln,  dw  0                       ; S:シリンダー
    69 000000BC 0000                                at drive.head,  dw  0                       ; H:ヘッド
    70 000000BE 0200                                at drive.sect,  dw  2                       ; S:セクタ
    71                                          iend
    72                                  
    73                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    74                                      ; モジュール
    75                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    76                                      %include "/home/m8ku/prog/src/modules/real/puts.asm"
     1                              <1> ;puts(str)
     2                              <1> puts:
     3 000000C0 55                  <1>         push    bp                                      ; スタックフレームを構築
     4 000000C1 89E5                <1>         mov     bp , sp                                 ;
     5                              <1> 
     6 000000C3 50                  <1>         push    ax                                      ; 各レジスタの退避
     7 000000C4 53                  <1>         push    bx                                      ;
     8 000000C5 56                  <1>         push    si                                      ;
     9 000000C6 9C                  <1>         pushf                                           ;
    10                              <1> 
    11 000000C7 8B7604              <1>         mov     si , [bp + 4]                           ; 第一引数へアクセス
    12 000000CA B40E                <1>         mov     ah , 0x0E                               ; AH=0x0E
    13 000000CC BB0000              <1>         mov     bx , 0x0000                             ; BX=0x0000
    14 000000CF FC                  <1>         cld                                             ; DF=0
    15                              <1> 
    16                              <1> .10L:                                                   ; do{
    17 000000D0 AC                  <1>         lodsb                                           ; AL = *SI++;
    18                              <1> 
    19 000000D1 3C00                <1>         cmp     al , 0                                  ; if(0 == AL)
    20 000000D3 7404                <1>         je      .10E                                    ; break;
    21                              <1> 
    22 000000D5 CD10                <1>         int     0x10                                    ; Int10(0x0E,AL)//文字出力
    23                              <1> 
    24 000000D7 EBF7                <1>         jmp     .10L                                    ; while (1);
    25                              <1> .10E:
    26                              <1> 
    27 000000D9 9D                  <1>         popf                                            ; 各レジスタの復帰
    28 000000DA 5E                  <1>         pop     si                                      ;
    29 000000DB 5B                  <1>         pop     bx                                      ;
    30 000000DC 58                  <1>         pop     ax                                      ;
    31                              <1> 
    32 000000DD 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    33 000000DF 5D                  <1>         pop     bp                                      ;
    34                              <1> 
    35 000000E0 C3                  <1>         ret                                             ; もとの処へ
    36                              <1> 
    37                              <1> ;(関数の概要(文字列を表示する関数です))
    38                              <1> ; 1. スタックフレームを構築します
    39                              <1> ; 2. 各レジスタを退避します
    40                              <1> ; 3. SIレジスタには後ほど利用する値を、AHレジスタに0x0EをBXレジスタには0をBIOSコールに備えて
    41                              <1> ;    書き込んでおきます
    42                              <1> ; 3. ストリング命令に備えてDFフラグを０を書き込みます
    43                              <1> ; 4. 先に引数の転送元をSIレジスタに書き込んだので転送元(メモリ)から転送先(ALレジスタ)へ値をを
    44                              <1> ;    転送します、この時にDIレジスタの値がインクリメントされます、
    45                              <1> ; 5. もしALレジスタに0が入ったら関数の終了アドレスへ移動します
    46                              <1> ; 6. そしたらALレジスタにはきっとASCII文字が書かれているので0x10番でBIOSコールをし表示します
    47                              <1> ; 7. .10Eのアドレスへ移動してALレジスタに0が入るまで文字を表示して結果的に文字列が表示できます
    48                              <1> ; 8. 各レジスタ復帰します
    49                              <1> ; 9. スッタックフレームを取り除いて
    50                              <1> ;10. 呼び出し元のアドレスまで移動します
    77                                      %include "/home/m8ku/prog/src/modules/real/reboot.asm"
     1                              <1> ;reboot()
     2                              <1> reboot:
     3                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1>         ; メッセージを表示
     5                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     6 000000E1 68[FD00]E8D9FF83C4- <1>         cdecl   puts, .s0                               ; //再起動メッセージを表示
     6 000000E9 02                  <1>
     7                              <1> 
     8                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     9                              <1>         ; キー入力待ち
    10                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    11                              <1> .10L:
    12                              <1> ;                                                       ; do
    13 000000EA B410                <1>         mov     ah , 0x10                               ; {
    14 000000EC CD16                <1>         int     0x16                                    ;   // キー入力待ち
    15                              <1> ;                                                       ;   AL=BIOS(0x16,0x10);
    16 000000EE 3C20                <1>         cmp     al , ' '                                ;   ZF = AL == ' ';
    17 000000F0 75F8                <1>         jne     .10L                                    ; } while(!ZF)
    18                              <1> 
    19                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    20                              <1>         ; 改行を出力
    21                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    22 000000F2 68[1B01]E8C8FF83C4- <1>         cdecl   puts, .s1                               ; //改行
    22 000000FA 02                  <1>
    23                              <1> 
    24                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    25                              <1>         ; 再起動
    26                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    27 000000FB CD19                <1>         int     0x19                                    ; BIOS(0x19); //reboot()
    28                              <1> 
    29                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1>         ; 文字列データ
    31                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32 000000FD 0A0D50757368205350- <1> .s0 db 0x0A, 0x0D, "Push SPACE Key to Reboot...", 0     ;
    32 00000106 414345204B65792074- <1>
    32 0000010F 6F205265626F6F742E- <1>
    32 00000118 2E2E00              <1>
    33 0000011B 0A0D0A0D00          <1> .s1 db 0x0A, 0x0D, 0x0A, 0x0D, 0                        ;
    34                              <1> 
    35                              <1> ; (関数の概要(コンピューターを再起動する関数です))
    36                              <1> ; 1. "cdecl puts,.s0" 突然再起動されたらビックリするので再起動をする旨を伝えます
    37                              <1> ; 2. "10L" もしスペースキーが押下されたら再起動ができるように繰り返しを行います"mov ah,0x10"
    38                              <1> ;    は拡張キーボード用です
    39                              <1> ;   | int 0x16 | |      AH      | |      AL      |
    40                              <1> ;   |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    41                              <1> ;   |    入力   | |     0x00     |       ---      |
    42                              <1> ;   |    出力   | | スキャンコード |   アスキーコード  |
    43                              <1> ; 3. "cdecl puts,.s1" 改行を出力します
    44                              <1> ; 4. "int 0x19" 再起動をするBIOSコールを発行します
    45                              <1> ; 5. ".s0" ".s1" 表示する文字列をそれぞれ定義しています
    78                                      %include "/home/m8ku/prog/src/modules/real/read_chs.asm"
     1                              <1> ;read_chs(drive,sect,dst)
     2                              <1> read_chs:
     3                              <1>         ;________________________________________________
     4                              <1>         ; スタックフレームの構築
     5                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     6 00000120 55                  <1>         push    bp                                      ;
     7 00000121 89E5                <1>         mov     bp , sp                                 ;
     8 00000123 6A03                <1>         push    3                                       ; int retry = 3;
     9 00000125 6A00                <1>         push    0                                       ; int sect  = 0;
    10                              <1> 
    11                              <1>         ;________________________________________________
    12                              <1>         ;　レジスタの保存
    13                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    14 00000127 53                  <1>         push    bx                                      ;
    15 00000128 51                  <1>         push    cx                                      ;
    16 00000129 52                  <1>         push    dx                                      ;
    17 0000012A 06                  <1>         push    es                                      ;
    18 0000012B 56                  <1>         push    si                                      ;
    19 0000012C 9C                  <1>         pushf                                           ;
    20                              <1> 
    21                              <1>         ;________________________________________________
    22                              <1>         ; メインプログラム開始！
    23                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    24 0000012D 8B7604              <1>         mov     si , [bp + 4]                           ; SI = SRCバッファ;
    25                              <1> 
    26                              <1>         ;________________________________________________
    27                              <1>         ; CXレジスタの設定 (BIOSコールの呼び出しに適した形に変換)
    28                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    29 00000130 8A6C02              <1>         mov     ch , [si + drive.cyln + 0]              ; CH=シリンダ番号(下位バイト)
    30 00000133 8A4C03              <1>         mov     cl , [si + drive.cyln + 1]              ; CL=シリンダ番号(上位バイト)
    31 00000136 C0E106              <1>         shl     cl , 6                                  ; CL<<=6;//6ビット左へシフト
    32 00000139 0A4C06              <1>         or      cl , [si + drive.sect]                  ; CL|=セクタ番号;
    33                              <1> 
    34                              <1>         ;________________________________________________
    35                              <1>         ; DHレジスタの設定とコピー先の設定
    36                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    37 0000013C 8A7404              <1>         mov     dh , [si + drive.head ]                 ; DH = ヘッド番号;
    38 0000013F 8A14                <1>         mov     dl , [si + 0]                           ; DL = ドライブ番号;
    39                              <1> 
    40 00000141 B80000              <1>         mov     ax ,0x0000                              ; AX = 0x0000;
    41 00000144 8EC0                <1>         mov     es , ax                                 ; EX = セグメント
    42 00000146 8B5E08              <1>         mov     bx , [bp + 8]                           ; BX = コピー先
    43                              <1> 
    44                              <1>         ;________________________________________________
    45                              <1>         ; セクタの読み込み
    46                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    47                              <1> .10L:
    48 00000149 8A4606              <1>         mov     al , [bp + 6]                           ; AL = セクタ数
    49 0000014C B402                <1>         mov     ah , 0x02                               ; AH = セクタ読み込み;
    50                              <1> 
    51 0000014E CD13                <1>         int     0x13                                    ; CF = BIOS(0x13,0x02);
    52 00000150 7304                <1>         jnc     .11E                                    ; if(CF)
    53                              <1> ;                                                       ; {
    54 00000152 B000                <1>         mov     al , 0                                  ;   AL = 0;
    55 00000154 EB0C                <1>         jmp     .10E                                    ;   break;
    56                              <1> .11E:                                                   ; }
    57                              <1> 
    58 00000156 3C00                <1>         cmp     al , 0                                  ; if(セクタ読み込んだなら){
    59 00000158 7508                <1>         jne     .10E                                    ;   break;
    60                              <1> 
    61 0000015A B80000              <1>         mov     ax , 0                                  ;   ret = 0;//戻り値を設定
    62 0000015D FF4EFE              <1>         dec     word [bp - 2]                           ; }
    63 00000160 75E7                <1>         jnz     .10L                                    ; while (--retry)
    64                              <1> .10E:
    65 00000162 B400                <1>         mov     ah , 0                                  ; AH=0;//ステータス情報破棄
    66                              <1> 
    67                              <1>         ;________________________________________________
    68                              <1>         ; レジスタの復帰
    69                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    70 00000164 9D                  <1>         popf                                            ;
    71 00000165 5E                  <1>         pop     si                                      ;
    72 00000166 07                  <1>         pop     es                                      ;
    73 00000167 5A                  <1>         pop     dx                                      ;
    74 00000168 59                  <1>         pop     cx                                      ;
    75 00000169 5B                  <1>         pop     bx                                      ;
    76                              <1> 
    77                              <1>         ;________________________________________________
    78                              <1>         ; スタックフレームの破棄
    79                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    80 0000016A 89EC                <1>         mov     sp , bp                                 ;
    81 0000016C 5D                  <1>         pop     bp                                      ;
    82                              <1> 
    83 0000016D C3                  <1>         ret                                             ; もとのとこへ
    84                              <1> 
    85                              <1> ; (関数の概要(セクタを読み出す関数です))
    86                              <1> ; 0. BIOS(0x13,0x02)はAH(セクタ読み込み数),AL(0x13の引数),CH(シリンダ),CL(セクタ番号,な
    87                              <1> ;    お上位二ビットはシリンダ(CH)の9,10ビット目の役割),DH(ヘッド番号),DL(ドライブ番号)
    88                              <1> ;    driveは第一引数であるが(ドライブ番号,シリンダ,ヘッド,セクタ)への配列を渡す
    89                              <1> ; 1. スタックフレームの構築をして
    90                              <1> ; 2. レジスタの保存をして
    91                              <1> ; 3. "mov si,[bp+4]" 第一引数へアクセスします、受け取る引数には(nomber,cyln,head,sect)の
    92                              <1> ;    パラメーターが入ったアドレスが含まれています、siレジスを基にそれぞれの値へ次アクセスします
    93                              <1> ; 4. (CXレジスタの設定(BIOSコールへの準備))
    94                              <1> ;    CXレジスタの設定を行います、86CPUはリトルエディアンなプロセッサなので
    95                              <1> ;    メモリアクセスの際、上位レジスタが下位バイトへ下位レジスタが上位バイトへとメインメモリへと
    96                              <1> ;    書きこまれるので一バイトアクセスのときに注意します
    97                              <1> ; 5. (DHレジスタの設定とコピー先の設定(BIOSコールへの準備))
    98                              <1> ;    先程得たパラメーターを参照してBIOSコールを発行する準備をDHレジスタに施します
    99                              <1> ; 6. (セクタの読み込み(いざBIOSコールを発行します))
   100                              <1> ;    ALレジスタをそれぞれ設定してBIOSを呼び覚まします、発行したらCFを確認して成功したか非かを
   101                              <1> ;    確かめ、CFが0すなわち成功だったらALレジスタのセクタ読み込み数を確認し読み込んだセクタがあ
   102                              <1> ;    ったなら読み込みセクタ数を保持して関数の終了へ、もしALレジスタが0だったらセクタ読み出し数の
   103                              <1> ;    参照からretry変数分だけやり直します、戻り値は、AXレジスタが0です、CFが1すなわち失敗だった
   104                              <1> ;    ら戻り値に0を設定して関数の終了です
   105                              <1> ; 7. レジスタの復帰をして
   106                              <1> ; 8. スタックフレームを破棄して
   107                              <1> ; 9. もとのところへ戻っていきます
    79                                  
    80                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    81                                      ; ブートフラグの設定 (先頭512バイトの終了)
    82                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;p;;;;;;;;;;;;;;;;;;;;;;;;;;
    83 0000016E 00<rept>                        times 510 - ($ - $$) db 0x00                    ; IPL領域を浸す
    84 000001FE 55AA                            db      0x55 , 0xAA                             ; 0x55 0xAA
    85                                  
    86                                      ;****************************************************
    87                                      ; リアルモード時に取得した情報 絶対参照するため0x7E00へ配置
    88                                      ;****************************************************
    89                                  FONT:
    90 00000200 0000                    .seg:   dw  0                                           ; フォントadrの保存先(seg)
    91 00000202 0000                    .off:   dw  0                                           ; フォントadrの保存先(off)
    92                                  
    93                                  ACPI_DATA:                                              ; ACPI data
    94 00000204 00000000                .adr:   dd  0                                           ; ACPI data address
    95 00000208 00000000                .len:   dd  0                                           ; ACPI data lenght
    96                                  
    97                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    98                                      ; モジュール (先頭512バイト以降に配置)
    99                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   100                                      %include "/home/m8ku/prog/src/modules/real/itoa.asm"
     1                              <1> ;itoa(num,buff,size,radix,flags) //B0,値を符号付か  B1,+-付加するか B2,0で空白埋めるか
     2                              <1> itoa:
     3                              <1> ;                                                       ;    +12| フラグ
     4                              <1> ;                                                       ;    +10| 基数
     5                              <1> ;                                                       ;    + 8| バッファサイズ
     6                              <1> ;                                                       ;    + 6| バッファアドレス
     7                              <1> ;                                                       ;    + 4| 数値
     8                              <1> ;                                                       ;    + 2| IP(元の値)
     9 0000020C 55                  <1>         push    bp                                      ; BP + 0| BP(元の値)
    10 0000020D 89E5                <1>         mov     bp , sp                                 ; ------+--------
    11                              <1> 
    12 0000020F 50                  <1>         push    ax                                      ; //各レジスタの保存
    13 00000210 53                  <1>         push    bx                                      ;
    14 00000211 51                  <1>         push    cx                                      ;
    15 00000212 52                  <1>         push    dx                                      ;
    16 00000213 56                  <1>         push    si                                      ;
    17 00000214 57                  <1>         push    di                                      ;
    18 00000215 9C                  <1>         pushf                                           ;
    19                              <1> 
    20 00000216 8B4604              <1>         mov     ax , [bp + 4]                           ; // 第一引数へアクセス
    21 00000219 8B7606              <1>         mov     si , [bp + 6]                           ; // 第二引数へアクセス
    22 0000021C 8B4E08              <1>         mov     cx , [bp + 8]                           ; // 第三引数へアクセス
    23                              <1> 
    24 0000021F 89F7                <1>         mov     di , si                                 ; // バッファの終端
    25 00000221 01CF                <1>         add     di , cx                                 ; //dst = &dst-[size-1]
    26 00000223 4F                  <1>         dec     di                                      ; //buffを超えないようdec
    27                              <1> 
    28 00000224 8B5E0C              <1>         mov     bx , [bp + 12]                          ; //第五引数へアクセス
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> ; 符号付き判定
    31                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32 00000227 F7C30100            <1>         test    bx , 0b0001                             ; if(flags & 0x01)//判定
    33 0000022B 7408                <1> .10Q:   je      .10E                                    ; {
    34 0000022D 83F800              <1>         cmp     ax , 0                                  ;   if(val < 0)
    35 00000230 7D03                <1> .12Q:   jge     .10E                                    ;   {
    36 00000232 83CB02              <1>         or      bx , 0b0010                             ;     flags |= 2; //表示
    37                              <1> .12E:                                                   ;   }
    38                              <1> .10E:                                                   ; }
    39                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    40                              <1> ; 符号出力判定
    41                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    42 00000235 F7C30200            <1>         test    bx , 0b0010                             ; if(flags & 0x02)出力判定
    43 00000239 7410                <1> .20Q:   je      .20E                                    ; {
    44 0000023B 83F800              <1>         cmp     ax , 0                                  ;   if(val < 0)
    45 0000023E 7D07                <1> .22Q:   jge     .22F                                    ;   {
    46 00000240 F7D8                <1>         neg     ax                                      ;   val *= -1;//符号反転
    47 00000242 C6042D              <1>         mov     [si] , byte '-'                         ;   *dst = '-';//符号表示
    48 00000245 EB03                <1>         jmp     .22E                                    ;   }
    49                              <1> .22F:                                                   ;   else{
    50 00000247 C6042B              <1>         mov     [si] , byte '+'                         ;   　*dst = '+';//符号表示
    51                              <1> .22E:                                                   ;   }
    52 0000024A 49                  <1>         dec     cx                                      ;   size --;//バッファ減算
    53                              <1> .20E:                                                   ; }
    54                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    55                              <1> ; ASCII変換
    56                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    57 0000024B 8B5E0A              <1>         mov     bx , [bp+10]                            ; //第四引数へアクセス
    58                              <1> .30L:                                                   ; do
    59                              <1> ;                                                       ; {
    60 0000024E BA0000              <1>         mov     dx , 0                                  ;　
    61 00000251 F7F3                <1>         div     bx                                      ; AX=DX:AX / BX(基数);
    62                              <1> ;                                                       ; DX=DX:AX % BX(基数);
    63                              <1> ;                                                       ;
    64 00000253 89D6                <1>         mov     si , dx                                 ; // テーブル参照
    65 00000255 8A94[7E02]          <1>         mov     dl , byte [.ascii + si]                 ; DL=ASCII[DX];
    66                              <1> 
    67 00000259 8815                <1>         mov     [di] , dl                               ; dst* = DL;
    68 0000025B 4F                  <1>         dec     di                                      ; dst--    ;
    69                              <1> 
    70 0000025C 83F800              <1>         cmp     ax , 0                                  ;
    71 0000025F E0ED                <1>         loopnz .30L                                     ; } while (AX);
    72                              <1> .30E:
    73                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    74                              <1> ; 空白を埋める
    75                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    76 00000261 83F900              <1> .40Q:   cmp     cx , 0                                  ; if(size)
    77 00000264 740D                <1>         je      .40E                                    ; {
    78 00000266 B020                <1>         mov     al , ' '                                ; AL = ' ';//' 'で埋める
    79 00000268 837E0C04            <1>         cmp     [bp + 12] , word 0b0100                 ;  if(flags & 0x04)
    80 0000026C 7502                <1> .42Q:   jne     .42E                                    ;  {
    81 0000026E B030                <1>         mov     al , '0'                                ;  AL = '0';//'0'で埋める
    82                              <1> .42E:                                                   ;  }
    83 00000270 FD                  <1>         std                                             ; //DF = 1//(-方向)
    84 00000271 F3AA                <1>         rep     stosb                                   ; while(--CX) *DI--=' ';
    85                              <1> .40E:                                                   ; }
    86                              <1> 
    87 00000273 9D                  <1>     popf                                                ; //各レジスタの復帰
    88 00000274 5F                  <1>     pop     di                                          ;
    89 00000275 5E                  <1>     pop     si                                          ;
    90 00000276 5A                  <1>     pop     dx                                          ;
    91 00000277 59                  <1>     pop     cx                                          ;
    92 00000278 5B                  <1>     pop     bx                                          ;
    93 00000279 58                  <1>     pop     ax                                          ;
    94                              <1> 
    95 0000027A 89EC                <1>     mov     sp , bp                                     ; //スタックフレームの破棄
    96 0000027C 5D                  <1>     pop     bp                                          ;
    97                              <1> 
    98 0000027D C3                  <1>     ret                                                 ; //もとのとこへ
    99                              <1> 
   100 0000027E 303132333435363738- <1> .ascii: db      "0123456789ABCDEF"                      ; 変換テーブル
   100 00000287 39414243444546      <1>
   101                              <1> 
   102                              <1> ;(関数の概要(数値を文字列に変換する関数です))
   103                              <1> ; 1. スタックフレームを構築します
   104                              <1> ; 2. 各レジスタを保存します
   105                              <1> ; 3. 各引数へアクセスすると共に後に利用する値を練ります、この関数は右詰めに文字コードを保存して
   106                              <1> ;    いき左側を空白などで埋めます、そのためにバッファアドレスからバッファサイズを足して右端へア
   107                              <1> ;    ドレスを設定します、しかしこのままだと指定されたサイズを超えて一文字目を保存してしまいます
   108                              <1> ;    もし保存先バッファアドレスが0x3000保存先バッファサイズが3Byteだったとして下の図で考えて
   109                              <1> ;    いくと3000+3で3003になってバッファを超えた∇へアクセスしてオーバーフローが起きてしまうので
   110                              <1> ;    作った数値からデクリメントしてあげます     ↓
   111                              <1> ;    __________ __________ __________ __________
   112                              <1> ;   | 3000番地 || 3001番地 || 3002番地 ||3003番地 |
   113                              <1> ;    ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^
   114                              <1> ; (符号付き判定)
   115                              <1> ; 1. 引数として受け取る値の中にビット定義のフラグが含まれていますフォーマットはB0が"値を符号付
   116                              <1> ;    き変数として扱う"B1が"'+/-'記号を付加する"B2が"空白を'0'で埋める"です、そしてこれらの前
   117                              <1> ;    準備をこちらでします、ビット定義のフラグの引数はbxレジスタへ転送してあります
   118                              <1> ; 2. 'test bx,0b0001'ではフラグのB0を検査し符号付き整数として扱うかどうかを判断します、test
   119                              <1> ;    命令はdstとsrcのAND演算を行い結果に応じてZF(ゼロフラグ)を設定します'test 0b01,0b01'だ
   120                              <1> ;    ったらZFは1,"test 0b01,0b00"だったらZFは0が設定されます、そして"je .10E"で分岐をしま
   121                              <1> ;    す、jeはZFを検査して0だったらそのまま続いて1だったらオペランドのアドレスへジャンプします、
   122                              <1> ;    次'cmp ax,0'で比較して'jge .10E'で条件分岐を行いますjgeは符号付き条件分岐命令ですので
   123                              <1> ;    負の数値でも条件分岐ができます、もしaxが0より小さかったらbxレジスタを0b0010でor演算しB1
   124                              <1> ;    を設定します
   125                              <1> ; (符号出力判定)
   126                              <1> ; 1. test命令でB1を検査しB1が立っていたら後へ続きます、次'cmp ax,0'で比較して'jge .22F'
   127                              <1> ;    で条件分岐を行いますjgeは符号付き条件分岐命令ですので負の数値でも条件分岐ができます、もし
   128                              <1> ;    axが0より小さかったら'-'符号をもしaxが0より大きいなら'+'符号を付加します、もし負の数だっ
   129                              <1> ; 　 たとしては負の数値のままだと後のASCII変換で期待した値を取得できないのでneg命令で二の補数反
   130                              <1> ; 　 転をして符号を反転します、そしてバッファを一つ利用したので残りバッファ数を保持しているcxレジ
   131                              <1> ;    スタをデクリメントします
   132                              <1> ; (ASCII変換)
   133                              <1> ; 1. 基数を取得して後続のプログラムへ備えます
   134                              <1> ; 2. 数値を文字列に変換する系統です、どうやって変換するかというと、数値を基数で除算し数値が0とな
   135                              <1> ; 　 るまで繰り返します、基数が2なら2進数の値、奇数が10なら10進数の値といった具合で文字列が得ら
   136                              <1> ;    れます、そのとき除算の余りを元に文字列を組み立てていくのですが、ある数値を除算して得られた
   137                              <1> ;    余りの数を変換テーブルへの索引として文字変換しLOOPNZ命令により残りバッファサイズ(cx)と変
   138                              <1> ;    換する値(ax)がが0になるまで繰り返します加えてその時必要となる文字列変換テーブルをソースコ
   139                              <1> ;    ードの一番最後、関数の最後付近に定義しています
   140                              <1> ; 3. 'mov dx,0'でdxレジスタに0を転送していますがこれは繰り返し行う過程で除算による余りがdxレ
   141                              <1> ;    ジスタに転送されるのですがx86CPUの除算では"AX=DX:AX/オペランド"という具合に被演算子にdx
   142                              <1> ;    レジスタが含まれているので繰り返しの過程でdxレジスタを初期化してやります
   143                              <1> ; 4. 'div bx'でaxレジスタの値をbxレジスタの値(基数)で除算します、このとき余りはdxレジスタへ商
   144                              <1> ;     はaxレジスタへそれぞれ格納されます、得られた商をまた次の繰り返しで除算します
   145                              <1> ; 5. 'mov si,dx'で先程の除算で得られた余剰をsiレジスタへ転送します、
   146                              <1> ; 6. 'mov dl,byte [.ascii+si]'で得られた余剰から文字コードを取得します、余剰をインデックス
   147                              <1> ;    として[.axcii+si]といった具合で変換テーブルへアクセスして得られるASCII文字をdlレジスタ
   148                              <1> ;    へ書き込みます
   149                              <1> ; 7. 'mov [di],dl'として先程得た文字コードを転送先アドレスを保持するdiレジスタをメモリオペラ
   150                              <1> ;    ンドにしてメモリへ文字コードを転送します
   151                              <1> ; 8. 'dec di'で次に保存する値へ備えてアドレスをデクリメントして保存位置を左へ一つずらします
   152                              <1> ; 9. 'cmp ax,0'で比較をして次のloopnzへ備えます
   153                              <1> ;10. 'loopnz .30L'では繰り返しを続けるかの有無を判断します、loopnzはCX=0,ZF=0の時オペランド
   154                              <1> ;    で指定したオフセットへジャンプします、ですのでバッファを使い切るか数値が0になるまで除算した
   155                              <1> ;    なら文字変換の繰り返しは終了します、先のことを言い換えてloopnzの終了条件はCX=0,ZF=1とな
   156                              <1> ;    ります加えてloopzの終了条件はCX=0,ZF=0、また1/2をすると0になります、
   157                              <1> ;11. そして3から10を繰り返したならば文字列が出来上がります
   158                              <1> ; (空白を埋める);
   159                              <1> ; 1. 'cmp cx,0'で比較をして条件分岐に備えます
   160                              <1> ; 2. 'je .40E'で残りのバッファがなかったらそのまま関数の終了へ移動します
   161                              <1> ; 3. 'cmp [bp+12,word 0b0100]'と'jne .42E'でもしビット定義のフラグ,B3が立っていたら'0'で
   162                              <1> ;     残りバッファを埋めて立っていなかったら空白で埋める条件分岐をJump If not equal(ZF=0)で
   163                              <1> ;     します
   164                              <1> ; 4. 'std'と'rep stosb'で残りのバッファを埋めます、stdでDFフラグをセットして後続のストリング
   165                              <1> ;    命令へ備えます、stosbはalレジスタの内容をdiレジスタのメモリアドレスを一バイトずつ転送する
   166                              <1> ;    と共にDFフラグが1ならdiレジスタをインクリメントし0だったらデクリメントへすることでアドレス
   167                              <1> ;    の増減をサポートする命令でrepはcxレジスタの値が0だったら転送を止めるプレフィックスで、そう
   168                              <1> ;    して残りのバッファ分を埋めることができるようになります
   169                              <1> 
   170                              <1> ; 4. スタックを復帰して
   171                              <1> ; 5. スタックフレームを取り外して
   172                              <1> ; 6. 'ret'で前にいた番地へ戻ります
   101                                      %include "/home/m8ku/prog/src/modules/real/get_drive_param.asm"
     1                              <1> ;get_drive_para(drive) 引数((× AX=0) (〇 AX≠0))
     2                              <1> get_drive_param:
     3 0000028E 55                  <1>         push    bp                                      ; スタックフレームの構築
     4 0000028F 89E5                <1>         mov     bp , sp                                 ;
     5 00000291 6A03                <1>         push    3                                       ; int retry = 3;
     6                              <1> 
     7 00000293 53                  <1>         push    bx                                      ; 格レジスタの保存
     8 00000294 51                  <1>         push    cx                                      ;
     9 00000295 06                  <1>         push    es                                      ;
    10 00000296 56                  <1>         push    si                                      ;
    11 00000297 57                  <1>         push    di                                      ;
    12 00000298 9C                  <1>         pushf                                           ;
    13                              <1> 
    14 00000299 8B7604              <1>         mov     si , [bp + 4]                           ; SI = バッファ
    15 0000029C B80000              <1>         mov     ax , 0                                  ; DiskBaseTablePointer=0
    16 0000029F 8EC0                <1>         mov     es , ax                                 ; ES = 0;
    17 000002A1 89C7                <1>         mov     di , ax                                 ; DI = 0;
    18                              <1> 
    19                              <1> .10L:
    20 000002A3 B408                <1>         mov     ah , 0x8                                ; //Get drive parameters
    21 000002A5 8A14                <1>         mov     dl , [si + drive.no]                    ; DL = drive.no;
    22 000002A7 CD13                <1>         int     0x13                                    ; CF = BIOS(0x13,8);
    23 000002A9 721B                <1> .10Q:   jc      .10F                                    ; if (0 == CF)
    24                              <1> .10T:                                                   ; {
    25 000002AB 88C8                <1>         mov     al , cl                                 ;   AX = セクタ数
    26 000002AD 83E03F              <1>         and     ax , 0x3F                               ;   //下位6ビットのみ有効
    27                              <1> 
    28 000002B0 C0E906              <1>         shr     cl , 6                                  ;   CX = シリンダ数
    29 000002B3 C1C908              <1>         ror     cx , 8                                  ;
    30 000002B6 41                  <1>         inc     cx                                      ;
    31                              <1> 
    32 000002B7 0FB6DE              <1>         movzx   bx , dh                                 ;   BX = ヘッド数
    33 000002BA 43                  <1>         inc     bx                                      ;
    34                              <1> 
    35 000002BB 894C02              <1>         mov     [si + drive.cyln + 0] , cx              ;   drive.syln = CX; //C
    36 000002BE 895C04              <1>         mov     [si + drive.head] , bx                  ;   drive.head = BX; //H
    37 000002C1 894406              <1>         mov     [si + drive.sect] , ax                  ;   drive.sect = ax; //S
    38                              <1> 
    39 000002C4 EB08                <1>         jmp     .10E                                    ;   break;
    40                              <1> ;                                                         }elese{
    41                              <1> .10F:                                                   ;   AX = 0;
    42 000002C6 B80000              <1>         mov     ax , 0                                  ; }
    43 000002C9 FF4EFE              <1>         dec     word [bp - 2]                           ;
    44 000002CC 75D5                <1>         jnz     .10L                                    ; while (retry--)
    45                              <1> .10E:                                                   ;
    46                              <1> 
    47 000002CE 9D                  <1>         popf                                            ; レジスタの復帰
    48 000002CF 5F                  <1>         pop     di                                      ;　
    49 000002D0 5E                  <1>         pop     si                                      ;
    50 000002D1 07                  <1>         pop     es                                      ;
    51 000002D2 59                  <1>         pop     cx                                      ;
    52 000002D3 5B                  <1>         pop     bx                                      ;
    53                              <1> 
    54 000002D4 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    55 000002D6 5D                  <1>         pop     bp                                      ;
    56                              <1> 
    57 000002D7 C3                  <1>         ret                                             ; ただいま
    58                              <1> 
    59                              <1> ; 関数の概要(ドライブパラメータを取得する関数です)
    60                              <1> ; 0. AHレジスタに0x8番,0x13番のBIOSコールでディスクの情報をCX,DXレジスタにそれぞれ書き込んで
    61                              <1> ;    くれます、CF==0が成功です、ソースコード中ではAX,BX,CXレジスタに値を移動し上手く値を練って
    62                              <1> ;    最後にしてのメモリ領域に値を返します、そして引数はセクタ数が返され読込できなかったら0を返し
    63                              <1> ;    ます.
    64                              <1> ; 1. スタックフレームを作って.
    65                              <1> ; 2. レジスタを保存して.
    66                              <1> ; 3. 'mov si,[bp+4]'で取得した値を指定の領域に書き込むのための準備をします.
    67                              <1> ; 4. 'mov ah,0x8'でドライブパラメータの取得'mov dl,[si+drive.no]'でブートプログラムで既に
    68                              <1> ;     知っているドライブ番号を指定してバイオスコール12番を発行します、成功か否かで分岐します.
    69                              <1> ; 5.  'jc .10F'で成功か否かで行く先を決めてあげます、〇だったら後続のアドレスへ×だったなら当該
    70                              <1> ;     アドレスへジャンプします.
    71                              <1> ; 5. <ここからは、レジスタのビット単位で指定されている変則的な値を上手く整理していきます>
    72                              <1> 
    73                              <1> ;    (AX = セクタ数)
    74                              <1> ;    'mov al,cl'でセクタ数をALレジスタに連れてきます.
    75                              <1> ;    'and ax 0x3F'で下位6ビットのみ有効にします、なぜならばCLレジスタの6,7ビット目にシリンダ
    76                              <1> ;    の値をも含まれているからです、0x3Fは二進数で表すと 00111111 です.これでセクタの値だけを
    77                              <1> ;    取り出す事ができます.
    78                              <1> ;        ________     ________     ________
    79                              <1> ;       |11111111| × |00111111| = |00111111|
    80                              <1> ;        ^^^^^^^^     ^^^^^^^^     ^^^^^^^^
    81                              <1> 
    82                              <1> ;    (CX = シリンダ数)
    83                              <1> ;    シリンダ数はCXレジスタに含まれているのでCXレジスタの値をそのまま流用します
    84                              <1> ;    'shr cl,6'で6回ビットをシフトします、なぜならばCLレジスタの6,7ビット目に全体で見るシリン
    85                              <1> ;    ダ数の9,10ビット目が含まれているからです.
    86                              <1> ;    'ror cx,6'ではシリンダ数の真なる値をつくります、ror命令はシフトにより押し出された最上位
    87                              <1> ;    ビットを再下位ビットへ順次コピーしていく命令です、これによりビット循環を実現できます.
    88                              <1> ;          CH         CL                        CH         CL
    89                              <1> ;        ________   ________                  ________   ________
    90                              <1> ;       |11111111| |11000000| 'shl cl,6' →   |11111111| |00000011|
    91                              <1> ;        ^^^^^^^^   ^^^^^^^^                  ^^^^^^^^   ^^^^^^^^
    92                              <1> ;          CH         CL                              CX
    93                              <1> ;        ________   ________                  ________   ________
    94                              <1> ;       |11111111| |00000011| 'ror cx,8' →   |00000011| |11111111|
    95                              <1> ;        ^^^^^^^^   ^^^^^^^^                  ^^^^^^^^   ^^^^^^^^
    96                              <1> ;                                                    ∧ こっちに移動した
    97                              <1> ;    'inc cx'でCXレジスタの値をインクリメントします、というのもシリンダの番号の指定は0始まり
    98                              <1> ;    なのですが対してセクタの番号の指定は1始まりです、ですのでシリンダ数を一つ足してやります、
    99                              <1> ;    シリンダの最終番号ではなくシリンダがいくつ存在するかを知りたいためだと思います//.
   100                              <1> 
   101                              <1> ;    (BX = ヘッド数)
   102                              <1> ;    'movzx bx,dh'ではDHレジスタからBXレジスタへゼロ拡張転送を行います、movzx命令は1バイト
   103                              <1> ;    の第二オペランドを2バイトの第一オペランドへ拡大コピーします.拡大というのは1バイトレジスタ
   104                              <1> ;    の値を2バイトレジスタの下位バイトへ移動して空きを0で埋めことです.
   105                              <1> ;    "inc bx"で先程の(CX = シリンダ数)と同様の理由でインクリメントしてやります.
   106                              <1> ;          DH         DL                              BX
   107                              <1> ;        ________   ________                   ________________
   108                              <1> ;       |11111111| |00000000| 'movzx bx,dh' → |0000000011111111|
   109                              <1> ;        ^^^^^^^^   ^^^^^^^^                   ^^^^^^^^^^^^^^^^
   110                              <1> ; 6. 既に.3で書き込み場所は取得しているのでに定義している構造体の＜syln,head,sect＞を利用しな
   111                              <1> ;    がら整理した値をいよいよメモリへ書き込みます.
   112                              <1> ; 7. 'jmp .10E'CF==0だったときにすることはこれで終了ですので関数の終了まで連れていきます.
   113                              <1> ; 8. 'mov ax,0'~'jnz .10L'CF==1だったときはretry変数分だけバイオスコールから回るようにして
   114                              <1> ;     みました.
   115                              <1> ; 9. レジスタを復帰して.
   116                              <1> ;10. スタックフレームを壊して.
   117                              <1> ;11. ただいま.
   102                                      %include "/home/m8ku/prog/src/modules/real/get_font_adr.asm"
     1                              <1> ;get_font_adr(adr)
     2                              <1> get_font_adr:
     3 000002D8 55                  <1>         push    bp                                      ; スタックフレームの構築
     4 000002D9 89E5                <1>         mov     bp , sp                                 ;
     5                              <1> 
     6 000002DB 50                  <1>         push    ax                                      ; 各レジスタの保存
     7 000002DC 53                  <1>         push    bx                                      ;
     8 000002DD 56                  <1>         push    si                                      ;
     9 000002DE 06                  <1>         push    es                                      ;
    10 000002DF 55                  <1>         push    bp                                      ;
    11                              <1> 
    12                              <1> 
    13 000002E0 8B7604              <1>         mov     si , [bp + 4]                           ; dst=FONTアドレスの保存先;
    14                              <1> 
    15 000002E3 B83011              <1>         mov     ax , 0x1130                             ; //フォントアドレスの取得
    16 000002E6 B706                <1>         mov     bh , 0x06                               ; 8x16 font (vga/mcga)
    17 000002E8 CD10                <1>         int     10h                                     ; ES:BP=FONT ADDRESS;
    18                              <1> 
    19 000002EA 8C04                <1>         mov     [si + 0] , es                           ; dst[0]=セグメント;
    20 000002EC 896C02              <1>         mov     [si + 2] , bp                           ; dst[1]=オフセット;
    21                              <1> 
    22 000002EF 5D                  <1>         pop     bp                                      ; 各レジスタの復帰
    23 000002F0 07                  <1>         pop     es                                      ;
    24 000002F1 5E                  <1>         pop     si                                      ;
    25 000002F2 5B                  <1>         pop     bx                                      ;
    26 000002F3 58                  <1>         pop     ax                                      ;
    27                              <1> 
    28 000002F4 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    29 000002F6 5D                  <1>         pop     bp                                      ;
    30                              <1> 
    31 000002F7 C3                  <1>         ret                                             ; //もどっていきなさい
    32                              <1> 
    33                              <1> ;(関数の概要(フォントアドレスを所得する関数です))
    34                              <1> ; 0. BIOSサービスを利用してフォントアドレスを貰い指定の場所へ書き込みます.
    35                              <1> ; 1. スタックフレームの構築とレジスタの保存をし引数のアクセスへ備えます.
    36                              <1> ; 2. 'mov si,[bp+4]' フォンアドレスはES:BPへ書き込まれるので引数としてもらった[保存先+0]が
    37                              <1> ;    セグメントアドレス,[保存先+2]がオフセットアドレスとして書き込むこととします.
    38                              <1> ; 3. 'mov [si+x],XX'でBIOSからもらったフォントアドレスを書き込ます.
    39                              <1> ; 4. スタックの復帰とスタックフレームを破棄して関数の終了へ備えます.
    40                              <1> ; 5. もどっていきなさい.
   103                                      %include "/home/m8ku/prog/src/modules/real/get_mem_info.asm"
     1                              <1> ;get_mem_info()
     2                              <1> get_mem_info:
     3 000002F8 6650                <1>         push    eax                                     ; 各レジスタの保存
     4 000002FA 6653                <1>         push    ebx                                     ;
     5 000002FC 6651                <1>         push    ecx                                     ;
     6 000002FE 6652                <1>         push    edx                                     ;
     7 00000300 56                  <1>         push    si                                      ;
     8 00000301 57                  <1>         push    di                                      ;
     9 00000302 55                  <1>         push    bp                                      ;
    10 00000303 9C                  <1>         pushf                                           ;
    11                              <1> 
    12 00000304 BD0000              <1>         mov     bp , 0                                  ; lines = 0; //行数
    13 00000307 66BB00000000        <1>         mov     ebx , 0                                 ; index = 0; //インデックス
    14                              <1> 
    15 0000030D 68[9903]E8ADFD83C4- <1>         cdecl   puts, .s0                               ;
    15 00000315 02                  <1>
    16                              <1> .10L:                                                   ; do
    17                              <1> ;                                                       ; {
    18 00000316 66B820E80000        <1>         mov     eax , 0x0000E820                        ; EAX = 0x0000E820;
    19                              <1> ;                                                       ; EBX = インデックス
    20 0000031C 66B914000000        <1>         mov     ecx , E820_RECORD_SIZE                  ; ECX = 要求バイト数;
    21 00000322 66BA50414D53        <1>         mov     edx , 0x534D4150                        ; EDX = 'SMAP';
    22 00000328 BF[3004]            <1>         mov     di , .b0                                ; ES：DI ＝ バッファ;
    23 0000032B CD15                <1>         int     0x15                                    ; BIOS(0x15,0xE820);
    24                              <1> 
    25 0000032D 663D50414D53        <1>         cmp     eax , 'PAMS'                            ;
    26 00000333 7402                <1>         je      .12E                                    ;
    27 00000335 EB4C                <1>         jmp     .10E                                    ;
    28                              <1> .12E:
    29 00000337 7302                <1>         jnc     .14E                                    ; if (CF){
    30 00000339 EB48                <1>         jmp     .10E                                    ;   break;
    31                              <1> .14E:                                                   ; } //エラーなし?
    32 0000033B 57E8050183C402      <1>         cdecl   put_mem_info , di                       ; 1レコードのメモリ情報を表示
    33                              <1> 
    34                              <1> 
    35 00000342 668B4510            <1>         mov     eax , [di + 16]                         ; EAX = レコードタイプ;
    36 00000346 6683F803            <1>         cmp     eax , 3                                 ; if (3 == EAX)//ACPIData
    37 0000034A 750F                <1>         jne     .15E                                    ; {
    38                              <1> 
    39 0000034C 668B05              <1>         mov     eax , [di + 0]                          ; EAX = BASEアドレス
    40 0000034F 66A3[0402]          <1>         mov     [ACPI_DATA.adr] , eax                   ; ACPI_DATA.adr = EAX;
    41                              <1> 
    42 00000353 668B4508            <1>         mov     eax , [di + 8]                          ; EAX = Lenght;
    43 00000357 66A3[0802]          <1>         mov     [ACPI_DATA.len] , eax                   ; ACPI_DATA.len = EAX;
    44                              <1> .15E:                                                   ; }
    45 0000035B 6683FB00            <1>         cmp     ebx , 0                                 ; if (0 != EBX)
    46 0000035F 741C                <1> .16Q:   jz      .16E                                    ; {
    47                              <1> 
    48 00000361 45                  <1>         inc     bp                                      ;   lines++;
    49 00000362 83E507              <1>         and     bp , 0x07                               ;   lines &= 0x07;
    50 00000365 7516                <1>         jnz     .16E                                    ;   if (0 == lines)
    51                              <1> ;                                                       ;   {
    52 00000367 68[0D04]E853FD83C4- <1>         cdecl   puts, .s2                               ;       puts(.s2);
    52 0000036F 02                  <1>
    53 00000370 B410                <1>         mov     ah , 0x10                               ;       //キー入力待ち
    54 00000372 CD16                <1>         int     0x16                                    ;       AL=BIOS(0x16,0x10)
    55                              <1> 
    56 00000374 68[1804]E846FD83C4- <1>         cdecl   puts, .s3                               ;       puts(.s3);
    56 0000037C 02                  <1>
    57                              <1> ;                                                       ;   }
    58                              <1> .16E:                                                   ; }
    59 0000037D 6683FB00            <1>         cmp     ebx , 0                                 ;
    60 00000381 7593                <1> .10Q:   jne     .10L                                    ;
    61                              <1> .10E:                                                   ; while (0 != EBX)
    62 00000383 68[DD03]E837FD83C4- <1>         cdecl   puts, .s1                               ;
    62 0000038B 02                  <1>
    63                              <1> 
    64 0000038C 9D                  <1>         popf                                            ; 各レジスタの復帰
    65 0000038D 5D                  <1>         pop     bp                                      ;
    66 0000038E 5F                  <1>         pop     di                                      ;
    67 0000038F 5E                  <1>         pop     si                                      ;
    68 00000390 665A                <1>         pop     edx                                     ;
    69 00000392 6659                <1>         pop     ecx                                     ;
    70 00000394 665B                <1>         pop     ebx                                     ;
    71 00000396 6658                <1>         pop     eax                                     ;
    72                              <1> 
    73 00000398 C3                  <1>         ret                                             ; もとのとこへ
    74                              <1> 
    75 00000399 20453832305F524543- <1> .s0:    db  " E820_RECORD_SIZE:", 0x0A, 0x0D
    75 000003A2 4F52445F53495A453A- <1>
    75 000003AB 0A0D                <1>
    76 000003AD 20426173655F5F5F5F- <1>         db  " Base_____________ Length___________ Type____", 0x0A, 0x0D, 0
    76 000003B6 5F5F5F5F5F5F5F5F5F- <1>
    76 000003BF 204C656E6774685F5F- <1>
    76 000003C8 5F5F5F5F5F5F5F5F5F- <1>
    76 000003D1 20547970655F5F5F5F- <1>
    76 000003DA 0A0D00              <1>
    77 000003DD 202D2D2D2D2D2D2D2D- <1> .s1:    db  " --------------------------------------------", 0x0A, 0x0D, 0
    77 000003E6 2D2D2D2D2D2D2D2D2D- <1>
    77 000003EF 2D2D2D2D2D2D2D2D2D- <1>
    77 000003F8 2D2D2D2D2D2D2D2D2D- <1>
    77 00000401 2D2D2D2D2D2D2D2D2D- <1>
    77 0000040A 0A0D00              <1>
    78 0000040D 203C6D6F72652E2E2E- <1> .s2:    db  " <more...>", 0
    78 00000416 3E00                <1>
    79 00000418 0D2020202020202020- <1> .s3:    db  0x0D, "          ", 0x0D, 0
    79 00000421 20200D00            <1>
    80 00000425 414350496E6F770A0D- <1> .t1:    db  "ACPInow", 0x0A, 0x0D, 0
    80 0000042E 00                  <1>
    81                              <1> 
    82 0000042F 00                  <1>         align   4, db   0
    83 00000430 00<rept>            <1> .b0:    times E820_RECORD_SIZE db 0
    84                              <1> 
    85                              <1> ;put_mem_info(adr)
    86                              <1> put_mem_info:
    87 00000444 55                  <1>         push    bp                                      ; スタックフレームの構築
    88 00000445 89E5                <1>         mov     bp , sp                                 ;
    89                              <1> 
    90 00000447 53                  <1>         push    bx                                      ; 各レジスタの保存
    91 00000448 56                  <1>         push    si                                      ;
    92                              <1> 
    93 00000449 8B7604              <1>         mov     si , [bp + 4]                           ; SI = バッファアドレス;
    94                              <1> 
    95                              <1>         ;Base(64bit)                                    ; //ここから変換していく
    96 0000044C 6A046A106A0468-     <1>         cdecl itoa, word [si + 6], .p2 + 0, 4, 16, 0b0100
    96 00000453 [2305]FF7406E8B1FD- <1>
    96 0000045B 83C40A              <1>
    97 0000045E 6A046A106A0468-     <1>         cdecl itoa, word [si + 4], .p2 + 4, 4, 16, 0b0100
    97 00000465 [2705]FF7404E89FFD- <1>
    97 0000046D 83C40A              <1>
    98 00000470 6A046A106A0468-     <1>         cdecl itoa, word [si + 2], .p3 + 0, 4, 16, 0b0100
    98 00000477 [2C05]FF7402E88DFD- <1>
    98 0000047F 83C40A              <1>
    99 00000482 6A046A106A0468-     <1>         cdecl itoa, word [si + 0], .p3 + 4, 4, 16, 0b0100
    99 00000489 [3005]FF34E87CFD83- <1>
    99 00000491 C40A                <1>
   100                              <1> 
   101                              <1>         ;Length(64bit)
   102 00000493 6A046A106A0468-     <1>         cdecl itoa, word [si + 14], .p4 + 0, 4, 16, 0b0100
   102 0000049A [3505]FF740EE86AFD- <1>
   102 000004A2 83C40A              <1>
   103 000004A5 6A046A106A0468-     <1>         cdecl itoa, word [si + 12], .p4 + 4, 4, 16, 0b0100
   103 000004AC [3905]FF740CE858FD- <1>
   103 000004B4 83C40A              <1>
   104 000004B7 6A046A106A0468-     <1>         cdecl itoa, word [si + 10], .p5 + 0, 4, 16, 0b0100
   104 000004BE [3E05]FF740AE846FD- <1>
   104 000004C6 83C40A              <1>
   105 000004C9 6A046A106A0468-     <1>         cdecl itoa, word [si + 08], .p5 + 4, 4, 16, 0b0100
   105 000004D0 [4205]FF7408E834FD- <1>
   105 000004D8 83C40A              <1>
   106                              <1> 
   107                              <1>         ;Type(32bit)
   108 000004DB 6A046A106A0468-     <1>         cdecl itoa, word [si + 18], .p6 + 0, 4, 16, 0b0100
   108 000004E2 [4705]FF7412E822FD- <1>
   108 000004EA 83C40A              <1>
   109 000004ED 6A046A106A0468-     <1>         cdecl itoa, word [si + 16], .p6 + 4, 4, 16, 0b0100
   109 000004F4 [4B05]FF7410E810FD- <1>
   109 000004FC 83C40A              <1>
   110                              <1> 
   111 000004FF 68[2205]E8BBFB83C4- <1>         cdecl puts, .s1                                 ; レコード情報を表示
   111 00000507 02                  <1>
   112                              <1> ;                                                       ;
   113 00000508 8B5C10              <1>         mov     bx , [si + 16]                          ; 2バイトアドレス変換↓
   114 0000050B 83E307              <1>         and     bx , 0x07                               ; BX = Type(1 ~ 5)
   115 0000050E D1E3                <1>         shl     bx , 1                                  ; BX *= 2;
   116 00000510 81C3[A505]          <1>         add     bx , .t0                                ; BX += .t0;
   117 00000514 FF37E8A7FB83C402    <1>         cdecl puts, word [bx]                           ; puts(*BX);
   118                              <1> 
   119 0000051C 5E                  <1>         pop     si                                      ; 各レジスタの復帰
   120 0000051D 5B                  <1>         pop     bx                                      ;
   121                              <1> 
   122 0000051E 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
   123 00000520 5D                  <1>         pop     bp                                      ;
   124                              <1> 
   125 00000521 C3                  <1>         ret                                             ; おりゃー
   126                              <1> 
   127 00000522 20                  <1> .s1:    db  " "                                         ; 一レコード分のメモリ情報
   128 00000523 5A5A5A5A5A5A5A5A5F  <1> .p2:    db  "ZZZZZZZZ_"                                 ; ベース上位32ビット
   129 0000052C 5A5A5A5A5A5A5A5A20  <1> .p3:    db  "ZZZZZZZZ "                                 ; ベース下位32ビット
   130 00000535 5A5A5A5A5A5A5A5A5F  <1> .p4:    db  "ZZZZZZZZ_"                                 ; バイト長上位32ビット
   131 0000053E 5A5A5A5A5A5A5A5A20  <1> .p5:    db  "ZZZZZZZZ "                                 ; バイト長下位32ビット
   132 00000547 5A5A5A5A5A5A5A5A20- <1> .p6:    db  "ZZZZZZZZ ", 0                              ;　データタイプ32ビット
   132 00000550 00                  <1>
   133                              <1> 
   134 00000551 2028556E6B6E6F776E- <1> .s4:    db  " (Unknown)", 0x0A, 0x0D, 0
   134 0000055A 290A0D00            <1>
   135 0000055E 2028757361626C6529- <1> .s5:    db  " (usable)", 0x0A, 0x0D, 0
   135 00000567 0A0D00              <1>
   136 0000056A 202872657365727665- <1> .s6:    db  " (reserved)", 0x0A, 0x0D, 0
   136 00000573 64290A0D00          <1>
   137 00000578 202841435049206461- <1> .s7:    db  " (ACPI data)", 0x0A, 0x0D, 0
   137 00000581 7461290A0D00        <1>
   138 00000587 202841435049204E56- <1> .s8:    db  " (ACPI NVS)", 0x0A, 0x0D, 0
   138 00000590 53290A0D00          <1>
   139 00000595 2028626164206D656D- <1> .s9:    db  " (bad memory)", 0x0A, 0x0D, 0
   139 0000059E 6F7279290A0D00      <1>
   140                              <1> 
   141 000005A5 [5105][5E05][6A05]- <1> .t0:    dw  .s4, .s5, .s6, .s7, .s8, .s9
   141 000005AB [7805][8705][9505]  <1>
   142                              <1> 
   143                              <1> ;(関数の概要(メモリ情報の取得と表示をします))
   144                              <1> ; 0. 一つのソースファイルの中に２つの関数をつくっています.
   145                              <1> 
   146                              <1> ; <get_mem_info>
   147                              <1> ; 0. レコード情報の取得を行います、専用の表示関数のソースはこちらの関数の下につくっています.
   148                              <1> ; 1. 引数は貰わないのでレジスタの保存だけしちゃいます.
   149                              <1> ; 2. 'mov bp,0''mov ebx,0' 変数の初期化をします.
   150                              <1> ; 3. 'cdecl puts,.s0' ヘッダを表示します.
   151                              <1> ; 4. 'int 0x15' メモリ情報を取得するためにBIOSコールを呼びます、EAXにE820h、ECXに書き込み先
   152                              <1> ;     バイト数、EDXに"SMAP"が引数です.
   153                              <1> ; 5. コマンドが対応しているか検査してEBXが3だったらACPIのテーブルなので値を所定の位置へ書き込
   154                              <1> ;    みます.
   155                              <1> ; 6. 'cdecl put_mem_info,di' テーブル情報のアドレスを引数に専用の表示関数を呼び出します.
   156                              <1> ; 7. '.16Q' メモリ情報を8行分表示するたび注意を促します、ページ数をマスクして非零分岐をします
   157                              <1> ;    lineが8になる度にand命令によって4ビット目が0になり、0からまたlineが加算されていくことに
   158                              <1> ;    なるので8ページずつ文字列を表示することができます.
   159                              <1> ;     line(BP)       0x07
   160                              <1> ;     ________     ________
   161                              <1> ;    |00000001| X |00000111| → ZF = 0                           (ページが1)
   162                              <1> ;     ^^^^^^^^     ^^^^^^^^
   163                              <1> ;     ________     ________
   164                              <1> ;    |00001000| X |00000111| → ZF = 1   → "<more...>"を表示.     (ページが8)
   165                              <1> ;     ^^^^^^^^     ^^^^^^^^
   166                              <1> ;     ________     ________
   167                              <1> ;    |00000001| X |00000111| → ZF = 0                           (ページが9)
   168                              <1> ;     ^^^^^^^^     ^^^^^^^^
   169                              <1> ;     ________     ________
   170                              <1> ;    |00001000| X |00000111| → ZF = 1   → "<more...>"を表示.     (ページが16)
   171                              <1> ;     ^^^^^^^^     ^^^^^^^^
   172                              <1> ; 8. '.10Q' EBXに0が入ると最終レコードなので、それまでレコードの取得を繰り返しをします.
   173                              <1> ; 9. 'cdecl puts,.s1' フッダを表示します
   174                              <1> ;10. 保存しておいたレジスタの復帰をします
   175                              <1> ;11. 'ret' 関数の終了です.
   176                              <1> 
   177                              <1> ; <put_mem_info>
   178                              <1> ; 0. メモリ情報の表示をします、引数にレコードを取ります.
   179                              <1> ;    レコードの構造 > 0 ~ 8(BASEAdr) 8 ~ 16(Len) 16 ~ 20(Type)
   180                              <1> ; 1. スタックフレームの構築をします.
   181                              <1> ; 2. レジスタの保存をします.
   182                              <1> ; 3. 'mov si,[bp+4]' 第一引数をとります.
   183                              <1> ; 4. 'cdecl itoa,xxx' レコード情報を文字列に変換します、レコード長が64bitの値が書き込まれて
   184                              <1> ;    いてx86はリトルエディアンなので後ろから徐々に変換していき変換した文字列は前から配置していき
   185                              <1> ;    ます.
   186                              <1> ; 5. 'cdecl  puts,.s1' 変換した文字列を表示します.
   187                              <1> ; 6. 'mov bx,[si+16]' タイプ情報をとります、知りたいのは下位2Bなので左です.
   188                              <1> ; 7. 'and bx,0x07' マスクします.
   189                              <1> ; 8. 'shl bx,1' タイプ情報を左シフトして2バイトアドレッシングのインデックスにします.
   190                              <1> ; 9. 'add bx,.t0' 事前に定義している各文字列へのアドレスの始端(.t0)に先程つくった値を加算する
   191                              <1> ;    ことで対応した文字列のアドレスを得ることができます.
   192                              <1> ;10. 'cdecl puts,word[bx]' 文字列表示関数に先程つくった値を引数にわたします.
   193                              <1> ;11. お邪魔したのでレジスタを復帰します.
   194                              <1> ;12. 前関数に戻るためにスタックフレームを壊します.
   195                              <1> ;13. 'ret' 前関数へ戻ります.
   104                                      %include "/home/m8ku/prog/src/modules/real/kbc.asm"
     1                              <1> ;int KBC_Data_Write(data)
     2                              <1> KBC_Data_Write:
     3 000005B1 55                  <1>         push    bp                                      ; スタックフレームの構築
     4 000005B2 89E5                <1>         mov     bp , sp                                 ;
     5                              <1> 
     6 000005B4 51                  <1>         push    cx                                      ; 各レジスタの保存
     7 000005B5 9C                  <1>         pushf                                           ;
     8                              <1> 
     9 000005B6 B90300              <1>         mov     cx , 3                                  ; CX = 3; //最大カウント数
    10                              <1> .10L:                                                   ; do
    11                              <1> ;                                                       ; {
    12 000005B9 E464                <1>         in      al , 0x64                               ;   AL = inp(0x64);
    13 000005BB A802                <1>         test    al , 0x02                               ;   ZF = AL & 0x2;
    14                              <1> 
    15 000005BD E0FA                <1>         loopnz  .10L                                    ; } while (--CX && !ZF);
    16                              <1> 
    17 000005BF 83F900              <1>         cmp     cx , 0                                  ; if (CX)
    18 000005C2 7407                <1> .20Q:   jz      .20E                                    ; {
    19                              <1> 
    20 000005C4 8A4604              <1>         mov     al , [bp + 4]                           ;   AL = データ;
    21 000005C7 E660                <1>         out     0x60 , al                               ;   outp(0x60, AL);
    22                              <1> 
    23 000005C9 89C8                <1>         mov     ax , cx                                 ;   return CX;
    24                              <1> .20E:                                                   ; }
    25                              <1> 
    26 000005CB 9D                  <1>         popf                                            ; 各レジスタの復帰
    27 000005CC 59                  <1>         pop     cx                                      ;
    28                              <1> 
    29 000005CD 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    30 000005CF 5D                  <1>         pop     bp                                      ;
    31                              <1> 
    32 000005D0 C3                  <1>         ret                                             ; もとのとこへ
    33                              <1> 
    34                              <1> ;int KBC_Data_Read(data)
    35                              <1> KBC_Data_Read:
    36 000005D1 55                  <1>         push    bp                                      ; スタックフレームの構築
    37 000005D2 89E5                <1>         mov     bp , sp                                 ;
    38                              <1> 
    39 000005D4 51                  <1>         push    cx                                      ; 各レジスタの保存
    40 000005D5 57                  <1>         push    di                                      ;
    41 000005D6 9C                  <1>         pushf                                           ;
    42                              <1> 
    43 000005D7 B90300              <1>         mov     cx , 3                                  ; CX = 3; //最大カウント数
    44                              <1> .10L:                                                   ; do
    45                              <1> ;                                                       ; {
    46 000005DA E464                <1>         in      al , 0x64                               ; AL = inp(0x64);
    47 000005DC A801                <1>         test    al , 0x01                               ; ZF = AL & 0x1;
    48                              <1> 
    49 000005DE E1FA                <1>         loopz  .10L                                     ; } while (CX-- && !ZF);
    50                              <1> 
    51 000005E0 83F900              <1>         cmp     cx , 0                                  ; if (CX)
    52 000005E3 740B                <1> .20Q:   jz      .20E                                    ; {
    53                              <1> 
    54 000005E5 B400                <1>         mov     ah , 0x00                               ; AH = 0;
    55 000005E7 E460                <1>         in      al , 0x60                               ; AL = inp(0x60);
    56                              <1> 
    57 000005E9 8B7E04              <1>         mov     di , [bp + 4]                           ;
    58 000005EC 8905                <1>         mov     [di + 0] , ax                           ;
    59                              <1> 
    60 000005EE 89C8                <1>         mov     ax , cx                                 ; return CX;
    61                              <1> .20E:
    62 000005F0 9D                  <1>         popf                                            ; 各レジスタの復帰
    63 000005F1 5F                  <1>         pop     di                                      ;
    64 000005F2 59                  <1>         pop     cx                                      ;
    65                              <1> 
    66 000005F3 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    67 000005F5 5D                  <1>         pop     bp                                      ;
    68                              <1> 
    69 000005F6 C3                  <1>         ret                                             ; もとのとこへ
    70                              <1> 
    71                              <1> ;int KBC_Cmd_Write(cmd)
    72                              <1> KBC_Cmd_Write:
    73 000005F7 55                  <1>         push    bp                                      ; スタックフレームの構築
    74 000005F8 89E5                <1>         mov     bp , sp                                 ;
    75                              <1> 
    76 000005FA 51                  <1>         push    cx                                      ; 各レジスタの保存
    77 000005FB 9C                  <1>         pushf                                           ;
    78                              <1> 
    79 000005FC B90300              <1>         mov     cx , 3                                  ; CX = 3;//最大カウント数
    80                              <1> .10L:                                                   ; do
    81                              <1> ;                                                       ; {
    82 000005FF E464                <1>         in      al , 0x64                               ; AL = inp(0x64);
    83 00000601 A802                <1>         test    al , 0x02                               ; ZF = AL & 0x2;
    84                              <1> 
    85 00000603 E0FA                <1>         loopnz  .10L                                    ; } while (--CX && !ZF);
    86                              <1> 
    87 00000605 83F900              <1>         cmp     cx , 0                                  ; if(CX)
    88 00000608 7407                <1> .20Q:   jz      .20E                                    ; {
    89                              <1> 
    90 0000060A 8A4604              <1>         mov     al , [bp + 4]                           ; AL = コマンド;
    91 0000060D E664                <1>         out     0x64 , al                               ; outp(0x64, AL)
    92                              <1> 
    93 0000060F 89C8                <1>         mov     ax , cx                                 ; return CX;
    94                              <1> .20E:
    95 00000611 59                  <1>         pop     cx                                      ; 各レジスタの復帰
    96 00000612 9C                  <1>         pushf                                           ;
    97                              <1> 
    98 00000613 89EC                <1>         mov     sp , bp                                 ; スタックフレームの構築
    99 00000615 5D                  <1>         pop     bp                                      ;
   100                              <1> 
   101 00000616 C3                  <1>         ret                                             ; もとのとこへ
   102                              <1> 
   103                              <1> ; (関数の概要())
   104                              <1> ; 0. キーボードドライバの関数を集めました.
   105                              <1> ; <KBC_Data_Write>
   106                              <1> ; 0. KBCが接続されている0x60番のポートへデータを書き込む関数です.
   107                              <1> ; 1. スタックフレームを構築します.
   108                              <1> ; 2. 各レジスタを保存します.
   109                              <1> ; 3. '.10L' 実際にKBCへデータを送る前にするべきことがありそれは、KBCにデータを現在書き込める
   110                              <1> ;    かどうかを検査することです.
   111                              <1> ;    そしてそれを確認するためにはKBCのステータス・レジスタのビット1を確認して入力バッファが空か
   112                              <1> ;    どうかを検査します.
   113                              <1> ;    そのとき(BIT1==0)のときは入力バッファが空つまりKBCへデータを書き込むことができる状態そし
   114                              <1> ;    て(BIT1==1)のときは入力バッファにデータありつまりKBCへデータを書き込むことができない状態
   115                              <1> ;    となります.
   116                              <1> ;    'in al,0x64' KBCのステータス・レジスタを読み込みます.
   117                              <1> ;    'test al,0x02' 読み込んだ値のB1を検査します.
   118                              <1> ;    'loopnz .10L' もし入力バッファが空だったら先へ進みます.
   119                              <1> ;    B1==0 → and 1, 0 → ZF==1 → loopnzをスルー.
   120                              <1> ;    B1==1 → and 1, 1 → ZF==0 → loopnzに引っかかる.
   121                              <1> ;    入力バッファにデータありだったのなら、入力バッファが空になるまでウェイトします、このときCX
   122                              <1> ;    レジスタをカウンターとして3を設定しているので3回検査してバッファが空になるのを確認できなか
   123                              <1> ;    ったら関数の終了となります.
   124                              <1> ; 4. '.20Q' 入力バッファを検査する過程でタイムアウトしたか検査します.
   125                              <1> ;    タイムアウトしたのならCX==0となりKBCへデータを書き込むことができないので関数を終了します.
   126                              <1> ;    バッファが空だったのならKBCへデータを書き込むことができるので引数に書き込む値をとりKBCへ
   127                              <1> ;    データを書き込んだ後、戻り値にカウント数を渡して関数の終了となります.
   128                              <1> ; 5. 各レジスタを復帰します.
   129                              <1> ; 6. スタックフレームを破棄します.
   130                              <1> ; 7. スタックに積まれている戻り番地を基にもとのとこへ.
   131                              <1> 
   132                              <1> ; <KBC_Data_Read>
   133                              <1> ; 0. KBCが接続されている0x60番のポートからデータを読み込む関数です.
   134                              <1> ; 1. スタックフレームを構築します.
   135                              <1> ; 2. 各レジスタを保存します.
   136                              <1> ; 3. '.10L' 実際にKBCからデータを読み込む前にするべきことがありそれは、KBCからデータを現在読み
   137                              <1> ;    込めるかどうかを検査することです.
   138                              <1> ;    そしてそれを確認するためにはKBCのステータス・レジスタのビット0を確認して出力バッファに現在
   139                              <1> ;    読むこむべきデータがあるかどうかを検査します.
   140                              <1> ;    そのとき(BIT0==0)のときは出力バッファが空つまりKBCから読み込むべきデータがない状態そして
   141                              <1> ;    (BIT0==1)のときは出力バッファにデータありつまりKBCから読み込むべきデータがある状態となる
   142                              <1> ;    に加えてここでの読むこむべきデータとはキーボードからのデータがある状態やKBCからのレスポンス
   143                              <1> ;    がある状態をさします.
   144                              <1> ;    'in al,0x64' KBCのステータス・レジスタを読み込みます.
   145                              <1> ;    'test al,0x02' 読み込んだ値のB0を検査します.
   146                              <1> ;    'loopz .10L' もし出力バッファがデータありだったら先へ進みます.
   147                              <1> ;    B0==0 → and 1, 0 → ZF==1 → loopzに引っかかる.
   148                              <1> ;    B0==1 → and 1, 1 → ZF==0 → loopzをスルー.
   149                              <1> ;    出力バッファにデータがなかったのなら、出力バッファにデータありになるまでウェイトします、こ
   150                              <1> ;    のときCXレジスタをカウンターとして3を設定しているので3回検査してバッファにデータありになる
   151                              <1> ;    のを確認できなかったら関数の終了となります.
   152                              <1> ; 4. '.20Q' 出力バッファを検査する過程でタイムアウトしたか検査します.
   153                              <1> ;    タイムアウトしたのならCX==0となりKBCから読むこむべきデータがないので関数を終了します.
   154                              <1> ;    バッファにデータありだったのならKBCから読み込むべきデータがあるのでKBCからデータを読み込み
   155                              <1> ;    引数にアドレスをとり読み込んだ値を所定の位置へ書き込んだ後、戻り地にカウント数を渡して関数
   156                              <1> ;    の終了となります.
   157                              <1> ; 5. 各レジスタを復帰します.
   158                              <1> ; 6. スタックフレームを破棄します.
   159                              <1> ; 7. もとのとこへ.
   160                              <1> 
   161                              <1> ; <KBC_Cmd_Write>
   162                              <1> ; 0. コマンドを書き込みたいので'out 0x64 ,al'としました.
   105                                  
   106                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   107                                      ; ブートプログラムの第二ステージ ▽
   108                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   109                                  stage_2nd:
   110                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   111                                          ; 文字列を表示
   112                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   113 00000617 68[9106]E8A3FA83C4-             cdecl puts, .s0                                 ; puts(.s0);
   113 0000061F 02                 
   114                                  
   115                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   116                                          ; ドライブ情報を取得
   117                                          ;;;:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   118 00000620 68[B800]E868FC83C4-             cdecl   get_drive_param, BOOT                   ; get_drive_param(BOOT);
   118 00000628 02                 
   119 00000629 83F800                          cmp     ax , 0                                  ; if (0 == AX)
   120 0000062C 750C                    .10Q:   jnz     .10E                                    ; {
   121 0000062E 68[C806]E88CFA83C4-     .10T:   cdecl   puts, .e0                               ;   puts(.e0);
   121 00000636 02                 
   122 00000637 E8A7FA                          call    reboot                                  ;   reboot(); //再起動
   123                                  .10E:                                                   ; }
   124                                  
   125                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   126                                          ; ドライブ情報を表示
   127                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   128 0000063A A1[B800]                        mov     ax , [BOOT + drive.no]                  ; AX = ブートドライブ
   129 0000063D 6A046A106A0268-                 cdecl   itoa, ax, .p1, 2, 16, 0b0100            ;
   129 00000644 [A906]50E8C2FB83C4-
   129 0000064C 0A                 
   130                                  
   131 0000064D A1[BA00]                        mov     ax , [BOOT + drive.cyln]                ; AX = シリンダ(トラック)数
   132 00000650 6A046A106A0468-                 cdecl   itoa, ax, .p2, 4, 16, 0b0100            ;
   132 00000657 [B106]50E8AFFB83C4-
   132 0000065F 0A                 
   133                                  
   134 00000660 A1[BC00]                        mov     ax , [BOOT + drive.head]                ; AX = ヘッド数
   135 00000663 6A046A106A0268-                 cdecl   itoa, ax, .p3, 2, 16, 0b0100            ;
   135 0000066A [BB06]50E89CFB83C4-
   135 00000672 0A                 
   136                                  
   137 00000673 A1[BE00]                        mov     ax , [BOOT + drive.sect]                ; AX=トラックあたりのセクタ数
   138 00000676 6A046A106A0268-                 cdecl   itoa, ax, .p4, 2, 16, 0b0100            ;
   138 0000067D [C306]50E889FB83C4-
   138 00000685 0A                 
   139                                  
   140 00000686 68[A006]E834FA83C4-             cdecl   puts, .s2                               ; puts(.s2); //情報を表示
   140 0000068E 02                 
   141                                  
   142                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   143                                          ; 次のステージへ移行
   144                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   145 0000068F EB52                            jmp     stage_3rd                               ; 第三ステージへ移行
   146                                  
   147                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   148                                          ; データ
   149                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   150 00000691 326E64207374616765-     .s0:    db  "2nd stage...", 0x0A, 0x0D, 0
   150 0000069A 2E2E2E0A0D00       
   151 000006A0 2044726976653A3078      .s2:    db  " Drive:0x"
   152 000006A9 2D2D2C20433A3078        .p1:    db  "--, C:0x"
   153 000006B1 2D2D2D2D2C20483A30-     .p2:    db  "----, H:0x"
   153 000006BA 78                 
   154 000006BB 2D2D2C20533A3078        .p3:    db  "--, S:0x"
   155 000006C3 2D2D0A0D00              .p4:    db  "--", 0x0A, 0x0D, 0
   156 000006C8 4572726F723A43616E-     .e0:    db  "Error:Can't get parameter.", 0
   156 000006D1 277420676574207061-
   156 000006DA 72616D657465722E00 
   157                                  
   158                                      ;****************************************************
   159                                      ; ブートプログラムの第三ステージ ▽
   160                                      ;****************************************************
   161                                  stage_3rd:
   162                                          ;************************************************
   163                                          ; 文字列を表示
   164                                          ;************************************************
   165 000006E3 68[6B07]E8D7F983C4-             cdecl   puts, .s1                               ; puts(.s1);
   165 000006EB 02                 
   166                                  
   167                                          ;************************************************
   168                                          ; プロテクトモードで使用するフォントは、BIOSに内蔵された
   169                                          ; ものを流用する
   170                                          ;************************************************
   171 000006EC 68[0002]E8E6FB83C4-             cdecl   get_font_adr, FONT                      ; BIOSフォントアドレスを取得
   171 000006F4 02                 
   172                                  
   173                                          ;************************************************
   174                                          ; フォントアドレスの表示
   175                                          ;************************************************
   176 000006F5 6A046A106A0468-                 cdecl   itoa, word [FONT.seg], .p1, 4, 16, 0b0100
   176 000006FC [8807]FF36[0002]E8-
   176 00000703 07FB83C40A         
   177 00000708 6A046A106A0468-                 cdecl   itoa, word [FONT.off], .p2, 4, 16, 0b0100
   177 0000070F [8D07]FF36[0202]E8-
   177 00000716 F4FA83C40A         
   178 0000071B 68[7A07]E89FF983C4-             cdecl   puts, .s2
   178 00000723 02                 
   179                                  
   180                                          ;************************************************
   181                                          ; メモリ情報の取得と表示
   182                                          ;************************************************
   183 00000724 E8D1FB                          cdecl   get_mem_info                            ; get_mem_info();
   184                                  
   185 00000727 66A1[0402]                      mov     eax , [ACPI_DATA.adr]                   ; EAX = ACPI_DATA.adr;
   186 0000072B 6683F800                        cmp     eax , 0                                 ; if (EAX)
   187 0000072F 742D                    .10Q:   je      .10E                                    ;{
   188 00000731 6A046A106A0468-                 cdecl itoa, ax, .p4, 4, 16, 0b0100              ; itoa(AX); //下位Adr変換
   188 00000738 [A607]50E8CEFA83C4-
   188 00000740 0A                 
   189 00000741 66C1E810                        shr     eax , 16                                ; EAX >>= 16;
   190 00000745 6A046A106A0468-                 cdecl itoa, ax, .p3, 4, 16, 0b0100              ; itoa(AX); //上位Adr変換
   190 0000074C [A207]50E8BAFA83C4-
   190 00000754 0A                 
   191                                  
   192 00000755 68[9707]E865F983C4-             cdecl puts, .s3                                 ; puts(.s3);
   192 0000075D 02                 
   193                                  .10E:                                                   ; }
   194                                  
   195                                          ;************************************************
   196                                          ; 次のステージへ移行
   197                                          ;************************************************
   198 0000075E EB4D                            jmp     stage_4th                               ; 第四ステージへ移行
   199                                  
   200 00000760 2D2D2D2D2D2D2D2D0A-     .s0:    db  "--------", 0x0A, 0x0D, 0
   200 00000769 0D00               
   201 0000076B 337264207374616765-     .s1:    db  "3rd stage...", 0x0A, 0x0D, 0
   201 00000774 2E2E2E0A0D00       
   202                                  
   203 0000077A 20466F6E7420416464-     .s2:    db  " Font Address="
   203 00000783 726573733D         
   204 00000788 5A5A5A5A3A              .p1:    db  "ZZZZ:"
   205 0000078D 5A5A5A5A0A0D00          .p2:    db  "ZZZZ", 0x0A, 0x0D, 0
   206 00000794 0A0D00                          db  0x0A, 0x0D, 0
   207                                  
   208 00000797 204143504920444154-     .s3:    db  " ACPI DATA="
   208 000007A0 413D               
   209 000007A2 5A5A5A5A                .p3:    db  "ZZZZ"                                      ; 上位32ビット
   210 000007A6 5A5A5A5A0A0D00          .p4:    db  "ZZZZ", 0x0A, 0x0D, 0                       ; 下位32ビット
   211                                  
   212                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                                      ; ブートプログラムの第四ステージ ▽
   214                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   215                                  stage_4th:
   216                                          ;------------------------------------------------
   217                                          ; 文字列を表示
   218                                          ;------------------------------------------------
   219 000007AD 68[2A08]E80DF983C4-             cdecl   puts, .s0                               ; puts(.s0);
   219 000007B5 02                 
   220 000007B6 FA                              cli                                             ; //割り込み禁止
   221                                  
   222                                          ;------------------------------------------------
   223                                          ; A20ゲートの有効化
   224                                          ;------------------------------------------------
   225 000007B7 68AD00E83AFE83C402              cdecl   KBC_Cmd_Write, 0xAD                     ; //キーボード無効化
   226                                  
   227 000007C0 68D000E831FE83C402              cdecl   KBC_Cmd_Write, 0xD0                     ; //出力信号読み出しコマンド
   228 000007C9 68[2808]E802FE83C4-             cdecl   KBC_Data_Read, .key                     ; //出力信号のデータ読み込み
   228 000007D1 02                 
   229                                  
   230 000007D2 8A1E[2808]                      mov     bl , [.key]                             ; BL = key;
   231 000007D6 80CB02                          or      bl , 0x02                               ; BL |= 0x02; //A20Gate
   232                                  
   233 000007D9 68D100E818FE83C402              cdecl   KBC_Cmd_Write, 0xD1                     ; //出力信号書き込みコマンド
   234 000007E2 53E8CBFD83C402                  cdecl   KBC_Data_Write, bx                      ; //出力信号へ反映
   235                                  
   236 000007E9 83F800                          cmp     ax , 0                                  ; if (0 == AX)
   237 000007EC 7509                    .10Q:   jnz     .10E                                    ; {
   238 000007EE 68[4E08]E8CCF883C4-             cdecl   puts, .s2                               ;   puts(.s2);
   238 000007F6 02                 
   239                                  .10E:                                                   ; }
   240 000007F7 68AE00E8FAFD83C402              cdecl   KBC_Cmd_Write, 0xAE                     ; //キーボード有効化
   241 00000800 FB                              sti                                             ; //割り込み許可
   242                                  
   243 00000801 68[3908]E8B9F883C4-             cdecl   puts, .s1                               ; puts(.s1);
   243 00000809 02                 
   244                                  
   245                                          ;************************************************
   246                                          ; 数値を表示
   247                                          ;************************************************
   248 0000080A B8630F                          mov     ax , 3939                               ;
   249 0000080D 6A016A0A6A0868-                 cdecl itoa, ax, .39, 8, 10, 0b0001              ; itoa(AX)
   249 00000814 [6908]50E8F2F983C4-
   249 0000081C 0A                 
   250 0000081D 68[6908]E89DF883C4-             cdecl puts, .39                                 ; puts(.s1);
   250 00000825 02                 
   251                                  
   252 00000826 EBFE                            jmp     $                                       ; while (1); //　∞
   253                                  
   254 00000828 0000                    .key:   dw  0
   255 0000082A 347468207374616765-     .s0:    db  "4th stage...", 0x0A, 0x0D, 0
   255 00000833 2E2E2E0A0D00       
   256 00000839 204132302047617465-     .s1:    db  " A20 Gate Enabled.", 0x0A, 0x0D, 0
   256 00000842 20456E61626C65642E-
   256 0000084B 0A0D00             
   257 0000084E 204132302047617465-     .s2:    db  " A20 Gate could't Enable", 0x0A, 0x0D, 0
   257 00000857 20636F756C64277420-
   257 00000860 456E61626C650A0D00 
   258 00000869 2D2D2D2D2D2D2D2D0A-     .39:    db  "--------", 0x0A, 0x0D, 0
   258 00000872 0D00               
   259                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   260                                          ; パディング (このファイルは8Kバイトとする)
   261                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   262 00000874 00<rept>                        times (BOOT_SIZE - ($ - $$)) db 0x00            ; 8KByte
   263                                  ;(関数の概要())
   264                                  ; 0. メモリ情報の取得と表示を行います、同時にそれらを担当する関数を作成したので実装しました.
   265                                  ; 1. '.10Q' ACPI情報のアドレスを表示します、get_mem_info関数ではACPI情報を得ると0x7E04へ
   266                                  ;    値を保存するので、その値(ACPI_DATA.adr)をCMPにかけ文字列を表示するか否かを決定します.
