     1                                  ;boot()
     2                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     3                                  ; マクロ
     4                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                          %include "/home/m8ku/prog/src/include/macro.asm"
     1                              <1> ;cdecl(),drive()
     2                              <1> %macro  cdecl   1-*.nolist
     3                              <1> 
     4                              <1>     %rep %0 - 1
     5                              <1> 
     6                              <1>         push    %{-1 : -1}
     7                              <1>         %rotate -1
     8                              <1> 
     9                              <1>     %endrep
    10                              <1> 
    11                              <1>     %rotate -1
    12                              <1>     call    %1
    13                              <1> 
    14                              <1>     %if 1 < %0
    15                              <1> 
    16                              <1>         add     sp , (__BITS__>>3) * (%0 - 1)
    17                              <1> 
    18                              <1>     %endif
    19                              <1> 
    20                              <1> %endmacro
    21                              <1> ;(マクロの概要(関数呼び出しのための関数です))
    22                              <1> ; 1.cdeclとしてマクロを定義して、引数は１からの可変長として、リスト出力の抑止を指定する(.lst)
    23                              <1> ; 2.%repから、もらった引数から関数分を差し引いた %0 - 1 回として %endrep まで繰り返します
    24                              <1> ; 3.関数呼び出しに備えるために引数をスタックに積んでいきます、%{-1 : -1 }はもらった引数全体の
    25                              <1> ;   終端を表しています ですので、受け取った引数が putc , ax , bx だとして一回目のループでbx
    26                              <1> ;   がスタックに積ます、次の%rotateは引数を回転します例えば (1,2,3)が(3,1,2)になります今回
    27                              <1> ;   は右に回転させたいので-1と指定していますが左に回転させたい場合は+を指定してやります、そして
    28                              <1> ;   (bx,putc,ax)になり次のループで引数の終端axが積んでから引数を回転(ax,bx,putc)となります
    29                              <1> ;   そして今回の例だとここで繰り返しが終了します
    30                              <1> ; 3.今回の例の続きで引数を回転させて(putc,ax,bx)となって
    31                              <1> ; 4.第一引数の名前の関数を呼び出します、今回の例では第一引数はputcとなっているのでputcという関
    32                              <1> ;   数が呼び出されることとなります
    33                              <1> ; 5.後に関数に引数として積んだスタックを調整してやるのですがマクロに引数を一つもしてしていないの
    34                              <1> ;   にもかかわらずスタックポインタを調節されては困るから条件式に当てはまったら処理をするようにし
    35                              <1> ;   てあげます今回だと一つ以上の引数が指定されたらです
    36                              <1> ; 6.関数を呼び出したら呼び出し側がスタックを調節してやらなければいけないのでスタックを調節します
    37                              <1> ;   スタックポインタレジスタに,(__BITS__>>3)*(%0 - 1 )を計算して書き込みます、__BITS__の
    38                              <1> ;   意味はNASMに元々組み込まれているマクロで16bit,32bit,64bitの判定を行います、16bitのプロ
    39                              <1> ;   グラムだったとして16を左へ3回シフトして(>>のところ)2が得られます32だったら4、64だったら8
    40                              <1> ;   、そしてCPUアーキテクチャ単位でスタックの料理ができるようになります、(%0 - 1)で引数の数を
    41                              <1> ;   だして、さきほどだした2と今回出した2をかけて4,積んだ引数は2つなのでビンゴです、spに4を加算
    42                              <1> ;   して関数呼び出しのすべての処理が終わりました
    43                              <1> ; 7.条件処理を終えます
    44                              <1> ; 8.マクロの終了です
    45                              <1> 
    46                              <1> struc drive
    47 00000000 <res 00000002>      <1>         .no     resw    1                               ; ドライブ番号
    48 00000002 <res 00000002>      <1>         .cyln   resw    1                               ; シリンダ
    49 00000004 <res 00000002>      <1>         .head   resw    1                               ; ヘッド
    50 00000006 <res 00000002>      <1>         .sect   resw    1                               ; セクタ
    51                              <1> 
    52                              <1> endstruc
    53                              <1> ;(マクロの概要(構造体の定義をしています))
    54                              <1> ; 0. ディスクアクセスに必要な情報をソースコードに更新する形で利用します、
    55                              <1> ;    次に更新する例を示します
    56                              <1> ;   istruc drive
    57                              <1> ;       at .sect dw 2                                   ; S:セクタ
    58                              <1> ;   iend
     6                                          %include "/home/m8ku/prog/src/include/define.asm"
     1                              <1> ;define()
     2                              <1>         BOOT_LOAD       equ     (0x7C00)                 ; ブートプログラムロード位置
     3                              <1> 
     4                              <1>         BOOT_SIZE       equ     (1024 * 8)               ; ブートコードサイズ
     5                              <1>         SECT_SIZE       equ     (512)                    ; セクタサイズ 512B
     6                              <1>         BOOT_SECT       equ     (BOOT_SIZE / SECT_SIZE)  ; ブートプログラムのセクタ数
     7                              <1>         E820_RECORD_SIZE    equ 20                       ; メモリ情報の格納サイズ20B
     8                              <1>         KERNEL_LOAD     equ     0x0010_1000              ; カーネルのロード位置
     9                              <1>         KERNEL_SIZE     equ     (1024 * 8)               ; カーネルのサイズ
    10                              <1>         BOOT_END        equ     (BOOT_LOAD + BOOT_SIZE)  ; ブートコードの最終アドレス
    11                              <1>         KERNEL_SECT     equ     (KERNEL_SIZE / SECT_SIZE); カーネルのセクタ数
    12                              <1> 
    13                              <1> ; (定義の概要)
    14                              <1> ; 0. それぞれdefineしています、ソースコードにうまく取り込もう
     7                                  
     8                                          ORG     BOOT_LOAD                               ; プログラムの開始位置を設定
     9                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    10                                  ; エントリポイント
    11                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    12                                  entry:
    13                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                                          ; BPB( BIOS Parameter Block )
    15                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    16 00000000 EB58                            jmp     ipl                                     ; IPLラベルへ移動
    17 00000002 90<rept>                        times  90 - ( $ - $$ ) db 0x90                  ; BPB領域を確保
    18                                  ipl:
    19                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    20                                          ; IPL( Initial Program Loader )
    21                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    22 0000005A FA                              cli                                             ; //割り込み禁止
    23                                  
    24 0000005B B80000                          mov     ax , 0x0000                             ; AX=0x0000
    25 0000005E 8ED8                            mov     ds , ax                                 ; DS=0x0000
    26 00000060 8EC0                            mov     es , ax                                 ; ES=0x0000
    27 00000062 8ED0                            mov     ss , ax                                 ; SS=0x0000
    28 00000064 BC007C                          mov     sp , BOOT_LOAD                          ; SP=0x7c00
    29                                  
    30 00000067 FB                              sti                                             ; //割り込み許可
    31                                  
    32 00000068 8816[B800]                      mov     [BOOT + drive.no] , dl                  ; ドライブ番号
    33                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    34                                          ; 文字列を表示
    35                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    36 0000006C 68[9900]E84E0083C4-             cdecl   puts , .s0                              ; puts(.s0);//Booting...
    36 00000074 02                 
    37                                  
    38                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                                          ; 次の５１２バイトを読み込む
    40                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    41 00000075 BB0F00                          mov     bx , BOOT_SECT - 1                      ; BX = 残りのブートセクタ数
    42 00000078 B9007E                          mov     cx , BOOT_LOAD + SECT_SIZE              ; CX = 次のロードアドレス
    43                                  
    44 0000007B 515368[B800]E89D00-             cdecl   read_chs, BOOT,  bx, cx                 ; セクタ読み出し関数の発行
    44 00000083 83C406             
    45                                  
    46 00000086 39D8                            cmp     ax , bx                                 ; if(AX!=BX)
    47 00000088 740C                    .10Q:   jz      .10E                                    ; {
    48 0000008A 68[A600]E8300083C4-     .10T:   cdecl   puts, .e0                               ; puts(.e0); //メッセージ
    48 00000092 02                 
    49 00000093 E84B00                          call    reboot                                  ; reboot();  //再起動
    50                                  .10E:                                                   ; }
    51                                  
    52                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    53                                          ; 次のステージへ移行
    54                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    55 00000096 E92C06                          jmp     stage_2nd                               ;
    56                                  
    57                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    58                                          ; データ
    59                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    60 00000099 426F6F74696E672E2E-     .s0:    db  "Booting..." , 0x0A , 0x0D , 0              ;
    60 000000A2 2E0A0D00           
    61 000000A6 4572726F723A736563-     .e0:    db  "Error:sector read", 0                      ;
    61 000000AF 746F72207265616400 
    62                                  
    63                                          align       2       , db 0                      ;
    64                                  BOOT:
    65                                          istruc  drive
    66 000000B8 0000                                at drive.no,    dw  0                       ; ドライブ番号
    67 000000BA 0000                                at drive.cyln,  dw  0                       ; S:シリンダー
    68 000000BC 0000                                at drive.head,  dw  0                       ; H:ヘッド
    69 000000BE 0200                                at drive.sect,  dw  2                       ; S:セクタ
    70                                          iend
    71                                  
    72                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    73                                      ; モジュール
    74                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    75                                      %include "/home/m8ku/prog/src/modules/real/puts.asm"
     1                              <1> ;puts(str)
     2                              <1> puts:
     3 000000C0 55                  <1>         push    bp                                      ; スタックフレームを構築
     4 000000C1 89E5                <1>         mov     bp , sp                                 ;
     5                              <1> 
     6 000000C3 50                  <1>         push    ax                                      ; 各レジスタの退避
     7 000000C4 53                  <1>         push    bx                                      ;
     8 000000C5 56                  <1>         push    si                                      ;
     9 000000C6 9C                  <1>         pushf                                           ;
    10                              <1> 
    11 000000C7 8B7604              <1>         mov     si , [bp + 4]                           ; 第一引数へアクセス
    12 000000CA B40E                <1>         mov     ah , 0x0E                               ; AH=0x0E
    13 000000CC BB0000              <1>         mov     bx , 0x0000                             ; BX=0x0000
    14 000000CF FC                  <1>         cld                                             ; DF=0
    15                              <1> 
    16                              <1> .10L:                                                   ; do{
    17 000000D0 AC                  <1>         lodsb                                           ; AL = *SI++;
    18                              <1> 
    19 000000D1 3C00                <1>         cmp     al , 0                                  ; if(0 == AL)
    20 000000D3 7404                <1>         je      .10E                                    ; break;
    21                              <1> 
    22 000000D5 CD10                <1>         int     0x10                                    ; Int10(0x0E,AL)//文字出力
    23                              <1> 
    24 000000D7 EBF7                <1>         jmp     .10L                                    ; while (1);
    25                              <1> .10E:
    26                              <1> 
    27 000000D9 9D                  <1>         popf                                            ; 各レジスタの復帰
    28 000000DA 5E                  <1>         pop     si                                      ;
    29 000000DB 5B                  <1>         pop     bx                                      ;
    30 000000DC 58                  <1>         pop     ax                                      ;
    31                              <1> 
    32 000000DD 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    33 000000DF 5D                  <1>         pop     bp                                      ;
    34                              <1> 
    35 000000E0 C3                  <1>         ret                                             ; もとの処へ
    36                              <1> 
    37                              <1> ;(関数の概要(文字列を表示する関数です))
    38                              <1> ; 1. スタックフレームを構築します
    39                              <1> ; 2. 各レジスタを退避します
    40                              <1> ; 3. SIレジスタには後ほど利用する値を、AHレジスタに0x0EをBXレジスタには0をBIOSコールに備えて
    41                              <1> ;    書き込んでおきます
    42                              <1> ; 3. ストリング命令に備えてDFフラグを０を書き込みます
    43                              <1> ; 4. 先に引数の転送元をSIレジスタに書き込んだので転送元(メモリ)から転送先(ALレジスタ)へ値をを
    44                              <1> ;    転送します、この時にDIレジスタの値がインクリメントされます、
    45                              <1> ; 5. もしALレジスタに0が入ったら関数の終了アドレスへ移動します
    46                              <1> ; 6. そしたらALレジスタにはきっとASCII文字が書かれているので0x10番でBIOSコールをし表示します
    47                              <1> ; 7. .10Eのアドレスへ移動してALレジスタに0が入るまで文字を表示して結果的に文字列が表示できます
    48                              <1> ; 8. 各レジスタ復帰します
    49                              <1> ; 9. スッタックフレームを取り除いて
    50                              <1> ;10. 呼び出し元のアドレスまで移動します
    76                                      %include "/home/m8ku/prog/src/modules/real/reboot.asm"
     1                              <1> ;reboot()
     2                              <1> reboot:
     3                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1>         ; メッセージを表示
     5                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     6 000000E1 68[FD00]E8D9FF83C4- <1>         cdecl   puts, .s0                               ; //再起動メッセージを表示
     6 000000E9 02                  <1>
     7                              <1> 
     8                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     9                              <1>         ; キー入力待ち
    10                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    11                              <1> .10L:
    12                              <1> ;                                                       ; do
    13 000000EA B410                <1>         mov     ah , 0x10                               ; {
    14 000000EC CD16                <1>         int     0x16                                    ;   // キー入力待ち
    15                              <1> ;                                                       ;   AL=BIOS(0x16,0x10);
    16 000000EE 3C20                <1>         cmp     al , ' '                                ;   ZF = AL == ' ';
    17 000000F0 75F8                <1>         jne     .10L                                    ; } while(!ZF)
    18                              <1> 
    19                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    20                              <1>         ; 改行を出力
    21                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    22 000000F2 68[1B01]E8C8FF83C4- <1>         cdecl   puts, .s1                               ; //改行
    22 000000FA 02                  <1>
    23                              <1> 
    24                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    25                              <1>         ; 再起動
    26                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    27 000000FB CD19                <1>         int     0x19                                    ; BIOS(0x19); //reboot()
    28                              <1> 
    29                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1>         ; 文字列データ
    31                              <1>         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32 000000FD 0A0D50757368205350- <1> .s0 db 0x0A, 0x0D, "Push SPACE Key to Reboot...", 0     ;
    32 00000106 414345204B65792074- <1>
    32 0000010F 6F205265626F6F742E- <1>
    32 00000118 2E2E00              <1>
    33 0000011B 0A0D0A0D00          <1> .s1 db 0x0A, 0x0D, 0x0A, 0x0D, 0                        ;
    34                              <1> 
    35                              <1> ; (関数の概要(コンピューターを再起動する関数です))
    36                              <1> ; 1. "cdecl puts,.s0" 突然再起動されたらビックリするので再起動をする旨を伝えます
    37                              <1> ; 2. "10L" もしスペースキーが押下されたら再起動ができるように繰り返しを行います"mov ah,0x10"
    38                              <1> ;    は拡張キーボード用です
    39                              <1> ;   | int 0x16 | |      AH      | |      AL      |
    40                              <1> ;   |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    41                              <1> ;   |    入力   | |     0x00     |       ---      |
    42                              <1> ;   |    出力   | | スキャンコード |   アスキーコード  |
    43                              <1> ; 3. "cdecl puts,.s1" 改行を出力します
    44                              <1> ; 4. "int 0x19" 再起動をするBIOSコールを発行します
    45                              <1> ; 5. ".s0" ".s1" 表示する文字列をそれぞれ定義しています
    77                                      %include "/home/m8ku/prog/src/modules/real/read_chs.asm"
     1                              <1> ;read_chs(drive,sect,dst)
     2                              <1> read_chs:
     3                              <1>         ;________________________________________________
     4                              <1>         ; スタックフレームの構築
     5                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     6 00000120 55                  <1>         push    bp                                      ;
     7 00000121 89E5                <1>         mov     bp , sp                                 ;
     8 00000123 6A03                <1>         push    3                                       ; int retry = 3;
     9 00000125 6A00                <1>         push    0                                       ; int sect  = 0;
    10                              <1> 
    11                              <1>         ;________________________________________________
    12                              <1>         ;　レジスタの保存
    13                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    14 00000127 53                  <1>         push    bx                                      ;
    15 00000128 51                  <1>         push    cx                                      ;
    16 00000129 52                  <1>         push    dx                                      ;
    17 0000012A 06                  <1>         push    es                                      ;
    18 0000012B 56                  <1>         push    si                                      ;
    19 0000012C 9C                  <1>         pushf                                           ;
    20                              <1> 
    21                              <1>         ;________________________________________________
    22                              <1>         ; メインプログラム開始！
    23                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    24 0000012D 8B7604              <1>         mov     si , [bp + 4]                           ; SI = SRCバッファ;
    25                              <1> 
    26                              <1>         ;________________________________________________
    27                              <1>         ; CXレジスタの設定 (BIOSコールの呼び出しに適した形に変換)
    28                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    29 00000130 8A6C02              <1>         mov     ch , [si + drive.cyln + 0]              ; CH=シリンダ番号(下位バイト)
    30 00000133 8A4C03              <1>         mov     cl , [si + drive.cyln + 1]              ; CL=シリンダ番号(上位バイト)
    31 00000136 C0E106              <1>         shl     cl , 6                                  ; CL<<=6;//6ビット左へシフト
    32 00000139 0A4C06              <1>         or      cl , [si + drive.sect]                  ; CL|=セクタ番号;
    33                              <1> 
    34                              <1>         ;________________________________________________
    35                              <1>         ; DHレジスタの設定とコピー先の設定
    36                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    37 0000013C 8A7404              <1>         mov     dh , [si + drive.head ]                 ; DH = ヘッド番号;
    38 0000013F 8A14                <1>         mov     dl , [si + 0]                           ; DL = ドライブ番号;
    39                              <1> 
    40 00000141 B80000              <1>         mov     ax ,0x0000                              ; AX = 0x0000;
    41 00000144 8EC0                <1>         mov     es , ax                                 ; EX = セグメント
    42 00000146 8B5E08              <1>         mov     bx , [bp + 8]                           ; BX = コピー先
    43                              <1> 
    44                              <1>         ;________________________________________________
    45                              <1>         ; セクタの読み込み
    46                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    47                              <1> .10L:
    48 00000149 8A4606              <1>         mov     al , [bp + 6]                           ; AL = セクタ数
    49 0000014C B402                <1>         mov     ah , 0x02                               ; AH = セクタ読み込み;
    50                              <1> 
    51 0000014E CD13                <1>         int     0x13                                    ; CF = BIOS(0x13,0x02);
    52 00000150 7304                <1>         jnc     .11E                                    ; if(CF)
    53                              <1> ;                                                       ; {
    54 00000152 B000                <1>         mov     al , 0                                  ;   AL = 0;
    55 00000154 EB0C                <1>         jmp     .10E                                    ;   break;
    56                              <1> .11E:                                                   ; }
    57                              <1> 
    58 00000156 3C00                <1>         cmp     al , 0                                  ; if(セクタ読み込んだなら){
    59 00000158 7508                <1>         jne     .10E                                    ;   break;
    60                              <1> 
    61 0000015A B80000              <1>         mov     ax , 0                                  ;   ret = 0;//戻り値を設定
    62 0000015D FF4EFE              <1>         dec     word [bp - 2]                           ; }
    63 00000160 75E7                <1>         jnz     .10L                                    ; while (--retry)
    64                              <1> .10E:
    65 00000162 B400                <1>         mov     ah , 0                                  ; AH=0;//ステータス情報破棄
    66                              <1> 
    67                              <1>         ;________________________________________________
    68                              <1>         ; レジスタの復帰
    69                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    70 00000164 9D                  <1>         popf                                            ;
    71 00000165 5E                  <1>         pop     si                                      ;
    72 00000166 07                  <1>         pop     es                                      ;
    73 00000167 5A                  <1>         pop     dx                                      ;
    74 00000168 59                  <1>         pop     cx                                      ;
    75 00000169 5B                  <1>         pop     bx                                      ;
    76                              <1> 
    77                              <1>         ;________________________________________________
    78                              <1>         ; スタックフレームの破棄
    79                              <1>         ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    80 0000016A 89EC                <1>         mov     sp , bp                                 ;
    81 0000016C 5D                  <1>         pop     bp                                      ;
    82                              <1> 
    83 0000016D C3                  <1>         ret                                             ; もとのとこへ
    84                              <1> 
    85                              <1> ; (関数の概要(セクタを読み出す関数です))
    86                              <1> ; 0. BIOS(0x13,0x02)はAH(セクタ読み込み数),AL(0x13の引数),CH(シリンダ),CL(セクタ番号,な
    87                              <1> ;    お上位二ビットはシリンダ(CH)の9,10ビット目の役割),DH(ヘッド番号),DL(ドライブ番号)
    88                              <1> ;    driveは第一引数であるが(ドライブ番号,シリンダ,ヘッド,セクタ)への配列を渡す
    89                              <1> ; 1. スタックフレームの構築をして
    90                              <1> ; 2. レジスタの保存をして
    91                              <1> ; 3. "mov si,[bp+4]" 第一引数へアクセスします、受け取る引数には(nomber,cyln,head,sect)の
    92                              <1> ;    パラメーターが入ったアドレスが含まれています、siレジスを基にそれぞれの値へ次アクセスします
    93                              <1> ; 4. (CXレジスタの設定(BIOSコールへの準備))
    94                              <1> ;    CXレジスタの設定を行います、86CPUはリトルエディアンなプロセッサなので
    95                              <1> ;    メモリアクセスの際、上位レジスタが下位バイトへ下位レジスタが上位バイトへとメインメモリへと
    96                              <1> ;    書きこまれるので一バイトアクセスのときに注意します
    97                              <1> ; 5. (DHレジスタの設定とコピー先の設定(BIOSコールへの準備))
    98                              <1> ;    先程得たパラメーターを参照してBIOSコールを発行する準備をDHレジスタに施します
    99                              <1> ; 6. (セクタの読み込み(いざBIOSコールを発行します))
   100                              <1> ;    ALレジスタをそれぞれ設定してBIOSを呼び覚まします、発行したらCFを確認して成功したか非かを
   101                              <1> ;    確かめ、CFが0すなわち成功だったらALレジスタのセクタ読み込み数を確認し読み込んだセクタがあ
   102                              <1> ;    ったなら読み込みセクタ数を保持して関数の終了へ、もしALレジスタが0だったらセクタ読み出し数の
   103                              <1> ;    参照からretry変数分だけやり直します、戻り値は、AXレジスタが0です、CFが1すなわち失敗だった
   104                              <1> ;    ら戻り値に0を設定して関数の終了です
   105                              <1> ; 7. レジスタの復帰をして
   106                              <1> ; 8. スタックフレームを破棄して
   107                              <1> ; 9. もとのところへ戻っていきます
    78                                  
    79                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    80                                      ; ブートフラグの設定 (先頭512バイトの終了)
    81                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;p;;;;;;;;;;;;;;;;;;;;;;;;;;
    82 0000016E 00<rept>                        times 510 - ($ - $$) db 0x00                    ; IPL領域を浸す
    83 000001FE 55AA                            db      0x55 , 0xAA                             ; 0x55 0xAA
    84                                  
    85                                      ;****************************************************
    86                                      ; リアルモード時に取得した情報 絶対参照するため0x7E00へ配置
    87                                      ;****************************************************
    88                                  FONT:
    89 00000200 0000                    .seg:   dw  0                                           ; フォントadrの保存先(seg)
    90 00000202 0000                    .off:   dw  0                                           ; フォントadrの保存先(off)
    91                                  
    92                                  ACPI_DATA:                                              ; ACPI data
    93 00000204 00000000                .adr:   dd  0                                           ; ACPI data address
    94 00000208 00000000                .len:   dd  0                                           ; ACPI data lenght
    95                                  
    96                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    97                                      ; モジュール (先頭512バイト以降に配置)
    98                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    99                                      %include "/home/m8ku/prog/src/modules/real/itoa.asm"
     1                              <1> ;itoa(num,buff,size,radix,flags) //B0,値を符号付か  B1,+-付加するか B2,0で空白埋めるか
     2                              <1> itoa:
     3                              <1> ;                                                       ;    +12| フラグ
     4                              <1> ;                                                       ;    +10| 基数
     5                              <1> ;                                                       ;    + 8| バッファサイズ
     6                              <1> ;                                                       ;    + 6| バッファアドレス
     7                              <1> ;                                                       ;    + 4| 数値
     8                              <1> ;                                                       ;    + 2| IP(元の値)
     9 0000020C 55                  <1>         push    bp                                      ; BP + 0| BP(元の値)
    10 0000020D 89E5                <1>         mov     bp , sp                                 ; ------+--------
    11                              <1> 
    12 0000020F 50                  <1>         push    ax                                      ; //各レジスタの保存
    13 00000210 53                  <1>         push    bx                                      ;
    14 00000211 51                  <1>         push    cx                                      ;
    15 00000212 52                  <1>         push    dx                                      ;
    16 00000213 56                  <1>         push    si                                      ;
    17 00000214 57                  <1>         push    di                                      ;
    18 00000215 9C                  <1>         pushf                                           ;
    19                              <1> 
    20 00000216 8B4604              <1>         mov     ax , [bp + 4]                           ; // 第一引数へアクセス
    21 00000219 8B7606              <1>         mov     si , [bp + 6]                           ; // 第二引数へアクセス
    22 0000021C 8B4E08              <1>         mov     cx , [bp + 8]                           ; // 第三引数へアクセス
    23                              <1> 
    24 0000021F 89F7                <1>         mov     di , si                                 ; // バッファの終端
    25 00000221 01CF                <1>         add     di , cx                                 ; //dst = &dst-[size-1]
    26 00000223 4F                  <1>         dec     di                                      ; //buffを超えないようdec
    27                              <1> 
    28 00000224 8B5E0C              <1>         mov     bx , [bp + 12]                          ; //第五引数へアクセス
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> ; 符号付き判定
    31                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32 00000227 F7C30100            <1>         test    bx , 0b0001                             ; if(flags & 0x01)//判定
    33 0000022B 7408                <1> .10Q:   je      .10E                                    ; {
    34 0000022D 83F800              <1>         cmp     ax , 0                                  ;   if(val < 0)
    35 00000230 7D03                <1> .12Q:   jge     .10E                                    ;   {
    36 00000232 83CB02              <1>         or      bx , 0b0010                             ;     flags |= 2; //表示
    37                              <1> .12E:                                                   ;   }
    38                              <1> .10E:                                                   ; }
    39                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    40                              <1> ; 符号出力判定
    41                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    42 00000235 F7C30200            <1>         test    bx , 0b0010                             ; if(flags & 0x02)出力判定
    43 00000239 7410                <1> .20Q:   je      .20E                                    ; {
    44 0000023B 83F800              <1>         cmp     ax , 0                                  ;   if(val < 0)
    45 0000023E 7D07                <1> .22Q:   jge     .22F                                    ;   {
    46 00000240 F7D8                <1>         neg     ax                                      ;   val *= -1;//符号反転
    47 00000242 C6042D              <1>         mov     [si] , byte '-'                         ;   *dst = '-';//符号表示
    48 00000245 EB03                <1>         jmp     .22E                                    ;   }
    49                              <1> .22F:                                                   ;   else{
    50 00000247 C6042B              <1>         mov     [si] , byte '+'                         ;   　*dst = '+';//符号表示
    51                              <1> .22E:                                                   ;   }
    52 0000024A 49                  <1>         dec     cx                                      ;   size --;//バッファ減算
    53                              <1> .20E:                                                   ; }
    54                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    55                              <1> ; ASCII変換
    56                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    57 0000024B 8B5E0A              <1>         mov     bx , [bp+10]                            ; //第四引数へアクセス
    58                              <1> .30L:                                                   ; do
    59                              <1> ;                                                       ; {
    60 0000024E BA0000              <1>         mov     dx , 0                                  ;　
    61 00000251 F7F3                <1>         div     bx                                      ; AX=DX:AX / BX(基数);
    62                              <1> ;                                                       ; DX=DX:AX % BX(基数);
    63                              <1> ;                                                       ;
    64 00000253 89D6                <1>         mov     si , dx                                 ; // テーブル参照
    65 00000255 8A94[7E02]          <1>         mov     dl , byte [.ascii + si]                 ; DL=ASCII[DX];
    66                              <1> 
    67 00000259 8815                <1>         mov     [di] , dl                               ; dst* = DL;
    68 0000025B 4F                  <1>         dec     di                                      ; dst--    ;
    69                              <1> 
    70 0000025C 83F800              <1>         cmp     ax , 0                                  ;
    71 0000025F E0ED                <1>         loopnz .30L                                     ; } while (AX);
    72                              <1> .30E:
    73                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    74                              <1> ; 空白を埋める
    75                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    76 00000261 83F900              <1> .40Q:   cmp     cx , 0                                  ; if(size)
    77 00000264 740D                <1>         je      .40E                                    ; {
    78 00000266 B020                <1>         mov     al , ' '                                ; AL = ' ';//' 'で埋める
    79 00000268 837E0C04            <1>         cmp     [bp + 12] , word 0b0100                 ;  if(flags & 0x04)
    80 0000026C 7502                <1> .42Q:   jne     .42E                                    ;  {
    81 0000026E B030                <1>         mov     al , '0'                                ;  AL = '0';//'0'で埋める
    82                              <1> .42E:                                                   ;  }
    83 00000270 FD                  <1>         std                                             ; //DF = 1//(-方向)
    84 00000271 F3AA                <1>         rep     stosb                                   ; while(--CX) *DI--=' ';
    85                              <1> .40E:                                                   ; }
    86                              <1> 
    87 00000273 9D                  <1>     popf                                                ; //各レジスタの復帰
    88 00000274 5F                  <1>     pop     di                                          ;
    89 00000275 5E                  <1>     pop     si                                          ;
    90 00000276 5A                  <1>     pop     dx                                          ;
    91 00000277 59                  <1>     pop     cx                                          ;
    92 00000278 5B                  <1>     pop     bx                                          ;
    93 00000279 58                  <1>     pop     ax                                          ;
    94                              <1> 
    95 0000027A 89EC                <1>     mov     sp , bp                                     ; //スタックフレームの破棄
    96 0000027C 5D                  <1>     pop     bp                                          ;
    97                              <1> 
    98 0000027D C3                  <1>     ret                                                 ; //もとのとこへ
    99                              <1> 
   100 0000027E 303132333435363738- <1> .ascii: db      "0123456789ABCDEF"                      ; 変換テーブル
   100 00000287 39414243444546      <1>
   101                              <1> 
   102                              <1> ;(関数の概要(数値を文字列に変換する関数です))
   103                              <1> ; 1. スタックフレームを構築します
   104                              <1> ; 2. 各レジスタを保存します
   105                              <1> ; 3. 各引数へアクセスすると共に後に利用する値を練ります、この関数は右詰めに文字コードを保存して
   106                              <1> ;    いき左側を空白などで埋めます、そのためにバッファアドレスからバッファサイズを足して右端へア
   107                              <1> ;    ドレスを設定します、しかしこのままだと指定されたサイズを超えて一文字目を保存してしまいます
   108                              <1> ;    もし保存先バッファアドレスが0x3000保存先バッファサイズが3Byteだったとして下の図で考えて
   109                              <1> ;    いくと3000+3で3003になってバッファを超えた∇へアクセスしてオーバーフローが起きてしまうので
   110                              <1> ;    作った数値からデクリメントしてあげます     ↓
   111                              <1> ;    __________ __________ __________ __________
   112                              <1> ;   | 3000番地 || 3001番地 || 3002番地 ||3003番地 |
   113                              <1> ;    ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^
   114                              <1> ; (符号付き判定)
   115                              <1> ; 1. 引数として受け取る値の中にビット定義のフラグが含まれていますフォーマットはB0が"値を符号付
   116                              <1> ;    き変数として扱う"B1が"'+/-'記号を付加する"B2が"空白を'0'で埋める"です、そしてこれらの前
   117                              <1> ;    準備をこちらでします、ビット定義のフラグの引数はbxレジスタへ転送してあります
   118                              <1> ; 2. 'test bx,0b0001'ではフラグのB0を検査し符号付き整数として扱うかどうかを判断します、test
   119                              <1> ;    命令はdstとsrcのAND演算を行い結果に応じてZF(ゼロフラグ)を設定します'test 0b01,0b01'だ
   120                              <1> ;    ったらZFは1,"test 0b01,0b00"だったらZFは0が設定されます、そして"je .10E"で分岐をしま
   121                              <1> ;    す、jeはZFを検査して0だったらそのまま続いて1だったらオペランドのアドレスへジャンプします、
   122                              <1> ;    次'cmp ax,0'で比較して'jge .10E'で条件分岐を行いますjgeは符号付き条件分岐命令ですので
   123                              <1> ;    負の数値でも条件分岐ができます、もしaxが0より小さかったらbxレジスタを0b0010でor演算しB1
   124                              <1> ;    を設定します
   125                              <1> ; (符号出力判定)
   126                              <1> ; 1. test命令でB1を検査しB1が立っていたら後へ続きます、次'cmp ax,0'で比較して'jge .22F'
   127                              <1> ;    で条件分岐を行いますjgeは符号付き条件分岐命令ですので負の数値でも条件分岐ができます、もし
   128                              <1> ;    axが0より小さかったら'-'符号をもしaxが0より大きいなら'+'符号を付加します、もし負の数だっ
   129                              <1> ; 　 たとしては負の数値のままだと後のASCII変換で期待した値を取得できないのでneg命令で二の補数反
   130                              <1> ; 　 転をして符号を反転します、そしてバッファを一つ利用したので残りバッファ数を保持しているcxレジ
   131                              <1> ;    スタをデクリメントします
   132                              <1> ; (ASCII変換)
   133                              <1> ; 1. 基数を取得して後続のプログラムへ備えます
   134                              <1> ; 2. 数値を文字列に変換する系統です、どうやって変換するかというと、数値を基数で除算し数値が0とな
   135                              <1> ; 　 るまで繰り返します、基数が2なら2進数の値、奇数が10なら10進数の値といった具合で文字列が得ら
   136                              <1> ;    れます、そのとき除算の余りを元に文字列を組み立てていくのですが、ある数値を除算して得られた
   137                              <1> ;    余りの数を変換テーブルへの索引として文字変換しLOOPNZ命令により残りバッファサイズ(cx)と変
   138                              <1> ;    換する値(ax)がが0になるまで繰り返します加えてその時必要となる文字列変換テーブルをソースコ
   139                              <1> ;    ードの一番最後、関数の最後付近に定義しています
   140                              <1> ; 3. 'mov dx,0'でdxレジスタに0を転送していますがこれは繰り返し行う過程で除算による余りがdxレ
   141                              <1> ;    ジスタに転送されるのですがx86CPUの除算では"AX=DX:AX/オペランド"という具合に被演算子にdx
   142                              <1> ;    レジスタが含まれているので繰り返しの過程でdxレジスタを初期化してやります
   143                              <1> ; 4. 'div bx'でaxレジスタの値をbxレジスタの値(基数)で除算します、このとき余りはdxレジスタへ商
   144                              <1> ;     はaxレジスタへそれぞれ格納されます、得られた商をまた次の繰り返しで除算します
   145                              <1> ; 5. 'mov si,dx'で先程の除算で得られた余剰をsiレジスタへ転送します、
   146                              <1> ; 6. 'mov dl,byte [.ascii+si]'で得られた余剰から文字コードを取得します、余剰をインデックス
   147                              <1> ;    として[.axcii+si]といった具合で変換テーブルへアクセスして得られるASCII文字をdlレジスタ
   148                              <1> ;    へ書き込みます
   149                              <1> ; 7. 'mov [di],dl'として先程得た文字コードを転送先アドレスを保持するdiレジスタをメモリオペラ
   150                              <1> ;    ンドにしてメモリへ文字コードを転送します
   151                              <1> ; 8. 'dec di'で次に保存する値へ備えてアドレスをデクリメントして保存位置を左へ一つずらします
   152                              <1> ; 9. 'cmp ax,0'で比較をして次のloopnzへ備えます
   153                              <1> ;10. 'loopnz .30L'では繰り返しを続けるかの有無を判断します、loopnzはCX=0,ZF=0の時オペランド
   154                              <1> ;    で指定したオフセットへジャンプします、ですのでバッファを使い切るか数値が0になるまで除算した
   155                              <1> ;    なら文字変換の繰り返しは終了します、先のことを言い換えてloopnzの終了条件はCX=0,ZF=1とな
   156                              <1> ;    ります加えてloopzの終了条件はCX=0,ZF=0、また1/2をすると0になります、
   157                              <1> ;11. そして3から10を繰り返したならば文字列が出来上がります
   158                              <1> ; (空白を埋める);
   159                              <1> ; 1. 'cmp cx,0'で比較をして条件分岐に備えます
   160                              <1> ; 2. 'je .40E'で残りのバッファがなかったらそのまま関数の終了へ移動します
   161                              <1> ; 3. 'cmp [bp+12,word 0b0100]'と'jne .42E'でもしビット定義のフラグ,B3が立っていたら'0'で
   162                              <1> ;     残りバッファを埋めて立っていなかったら空白で埋める条件分岐をJump If not equal(ZF=0)で
   163                              <1> ;     します
   164                              <1> ; 4. 'std'と'rep stosb'で残りのバッファを埋めます、stdでDFフラグをセットして後続のストリング
   165                              <1> ;    命令へ備えます、stosbはalレジスタの内容をdiレジスタのメモリアドレスを一バイトずつ転送する
   166                              <1> ;    と共にDFフラグが1ならdiレジスタをインクリメントし0だったらデクリメントへすることでアドレス
   167                              <1> ;    の増減をサポートする命令でrepはcxレジスタの値が0だったら転送を止めるプレフィックスで、そう
   168                              <1> ;    して残りのバッファ分を埋めることができるようになります
   169                              <1> 
   170                              <1> ; 4. スタックを復帰して
   171                              <1> ; 5. スタックフレームを取り外して
   172                              <1> ; 6. 'ret'で前にいた番地へ戻ります
   100                                      %include "/home/m8ku/prog/src/modules/real/get_drive_param.asm"
     1                              <1> ;get_drive_para(drive) 引数((× AX=0) (〇 AX≠0))
     2                              <1> get_drive_param:
     3 0000028E 55                  <1>         push    bp                                      ; スタックフレームの構築
     4 0000028F 89E5                <1>         mov     bp , sp                                 ;
     5 00000291 6A03                <1>         push    3                                       ; int retry = 3;
     6                              <1> 
     7 00000293 53                  <1>         push    bx                                      ; 格レジスタの保存
     8 00000294 51                  <1>         push    cx                                      ;
     9 00000295 06                  <1>         push    es                                      ;
    10 00000296 56                  <1>         push    si                                      ;
    11 00000297 57                  <1>         push    di                                      ;
    12 00000298 9C                  <1>         pushf                                           ;
    13                              <1> 
    14 00000299 8B7604              <1>         mov     si , [bp + 4]                           ; SI = バッファ
    15 0000029C B80000              <1>         mov     ax , 0                                  ; DiskBaseTablePointer=0
    16 0000029F 8EC0                <1>         mov     es , ax                                 ; ES = 0;
    17 000002A1 89C7                <1>         mov     di , ax                                 ; DI = 0;
    18                              <1> 
    19                              <1> .10L:
    20 000002A3 B408                <1>         mov     ah , 0x8                                ; //Get drive parameters
    21 000002A5 8A14                <1>         mov     dl , [si + drive.no]                    ; DL = drive.no;
    22 000002A7 CD13                <1>         int     0x13                                    ; CF = BIOS(0x13,8);
    23 000002A9 721B                <1> .10Q:   jc      .10F                                    ; if (0 == CF)
    24                              <1> .10T:                                                   ; {
    25 000002AB 88C8                <1>         mov     al , cl                                 ;   AX = セクタ数
    26 000002AD 83E03F              <1>         and     ax , 0x3F                               ;   //下位6ビットのみ有効
    27                              <1> 
    28 000002B0 C0E906              <1>         shr     cl , 6                                  ;   CX = シリンダ数
    29 000002B3 C1C908              <1>         ror     cx , 8                                  ;
    30 000002B6 41                  <1>         inc     cx                                      ;
    31                              <1> 
    32 000002B7 0FB6DE              <1>         movzx   bx , dh                                 ;   BX = ヘッド数
    33 000002BA 43                  <1>         inc     bx                                      ;
    34                              <1> 
    35 000002BB 894C02              <1>         mov     [si + drive.cyln + 0] , cx              ;   drive.syln = CX; //C
    36 000002BE 895C04              <1>         mov     [si + drive.head] , bx                  ;   drive.head = BX; //H
    37 000002C1 894406              <1>         mov     [si + drive.sect] , ax                  ;   drive.sect = ax; //S
    38                              <1> 
    39 000002C4 EB08                <1>         jmp     .10E                                    ;   break;
    40                              <1> ;                                                         }elese{
    41                              <1> .10F:                                                   ;   AX = 0;
    42 000002C6 B80000              <1>         mov     ax , 0                                  ; }
    43 000002C9 FF4EFE              <1>         dec     word [bp - 2]                           ;
    44 000002CC 75D5                <1>         jnz     .10L                                    ; while (retry--)
    45                              <1> .10E:                                                   ;
    46                              <1> 
    47 000002CE 9D                  <1>         popf                                            ; レジスタの復帰
    48 000002CF 5F                  <1>         pop     di                                      ;　
    49 000002D0 5E                  <1>         pop     si                                      ;
    50 000002D1 07                  <1>         pop     es                                      ;
    51 000002D2 59                  <1>         pop     cx                                      ;
    52 000002D3 5B                  <1>         pop     bx                                      ;
    53                              <1> 
    54 000002D4 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    55 000002D6 5D                  <1>         pop     bp                                      ;
    56                              <1> 
    57 000002D7 C3                  <1>         ret                                             ; ただいま
    58                              <1> 
    59                              <1> ; 関数の概要(ドライブパラメータを取得する関数です)
    60                              <1> ; 0. AHレジスタに0x8番,0x13番のBIOSコールでディスクの情報をCX,DXレジスタにそれぞれ書き込んで
    61                              <1> ;    くれます、CF==0が成功です、ソースコード中ではAX,BX,CXレジスタに値を移動し上手く値を練って
    62                              <1> ;    最後にしてのメモリ領域に値を返します、そして引数はセクタ数が返され読込できなかったら0を返し
    63                              <1> ;    ます.
    64                              <1> ; 1. スタックフレームを作って.
    65                              <1> ; 2. レジスタを保存して.
    66                              <1> ; 3. 'mov si,[bp+4]'で取得した値を指定の領域に書き込むのための準備をします.
    67                              <1> ; 4. 'mov ah,0x8'でドライブパラメータの取得'mov dl,[si+drive.no]'でブートプログラムで既に
    68                              <1> ;     知っているドライブ番号を指定してバイオスコール12番を発行します、成功か否かで分岐します.
    69                              <1> ; 5.  'jc .10F'で成功か否かで行く先を決めてあげます、〇だったら後続のアドレスへ×だったなら当該
    70                              <1> ;     アドレスへジャンプします.
    71                              <1> ; 5. <ここからは、レジスタのビット単位で指定されている変則的な値を上手く整理していきます>
    72                              <1> 
    73                              <1> ;    (AX = セクタ数)
    74                              <1> ;    'mov al,cl'でセクタ数をALレジスタに連れてきます.
    75                              <1> ;    'and ax 0x3F'で下位6ビットのみ有効にします、なぜならばCLレジスタの6,7ビット目にシリンダ
    76                              <1> ;    の値をも含まれているからです、0x3Fは二進数で表すと 00111111 です.これでセクタの値だけを
    77                              <1> ;    取り出す事ができます.
    78                              <1> ;        ________     ________     ________
    79                              <1> ;       |11111111| × |00111111| = |00111111|
    80                              <1> ;        ^^^^^^^^     ^^^^^^^^     ^^^^^^^^
    81                              <1> 
    82                              <1> ;    (CX = シリンダ数)
    83                              <1> ;    シリンダ数はCXレジスタに含まれているのでCXレジスタの値をそのまま流用します
    84                              <1> ;    'shr cl,6'で6回ビットをシフトします、なぜならばCLレジスタの6,7ビット目に全体で見るシリン
    85                              <1> ;    ダ数の9,10ビット目が含まれているからです.
    86                              <1> ;    'ror cx,6'ではシリンダ数の真なる値をつくります、ror命令はシフトにより押し出された最上位
    87                              <1> ;    ビットを再下位ビットへ順次コピーしていく命令です、これによりビット循環を実現できます.
    88                              <1> ;          CH         CL                        CH         CL
    89                              <1> ;        ________   ________                  ________   ________
    90                              <1> ;       |11111111| |11000000| 'shl cl,6' →   |11111111| |00000011|
    91                              <1> ;        ^^^^^^^^   ^^^^^^^^                  ^^^^^^^^   ^^^^^^^^
    92                              <1> ;          CH         CL                              CX
    93                              <1> ;        ________   ________                  ________   ________
    94                              <1> ;       |11111111| |00000011| 'ror cx,8' →   |00000011| |11111111|
    95                              <1> ;        ^^^^^^^^   ^^^^^^^^                  ^^^^^^^^   ^^^^^^^^
    96                              <1> ;                                                    ∧ こっちに移動した
    97                              <1> ;    'inc cx'でCXレジスタの値をインクリメントします、というのもシリンダの番号の指定は0始まり
    98                              <1> ;    なのですが対してセクタの番号の指定は1始まりです、ですのでシリンダ数を一つ足してやります、
    99                              <1> ;    シリンダの最終番号ではなくシリンダがいくつ存在するかを知りたいためだと思います//.
   100                              <1> 
   101                              <1> ;    (BX = ヘッド数)
   102                              <1> ;    'movzx bx,dh'ではDHレジスタからBXレジスタへゼロ拡張転送を行います、movzx命令は1バイト
   103                              <1> ;    の第二オペランドを2バイトの第一オペランドへ拡大コピーします.拡大というのは1バイトレジスタ
   104                              <1> ;    の値を2バイトレジスタの下位バイトへ移動して空きを0で埋めことです.
   105                              <1> ;    "inc bx"で先程の(CX = シリンダ数)と同様の理由でインクリメントしてやります.
   106                              <1> ;          DH         DL                              BX
   107                              <1> ;        ________   ________                   ________________
   108                              <1> ;       |11111111| |00000000| 'movzx bx,dh' → |0000000011111111|
   109                              <1> ;        ^^^^^^^^   ^^^^^^^^                   ^^^^^^^^^^^^^^^^
   110                              <1> ; 6. 既に.3で書き込み場所は取得しているのでに定義している構造体の＜syln,head,sect＞を利用しな
   111                              <1> ;    がら整理した値をいよいよメモリへ書き込みます.
   112                              <1> ; 7. 'jmp .10E'CF==0だったときにすることはこれで終了ですので関数の終了まで連れていきます.
   113                              <1> ; 8. 'mov ax,0'~'jnz .10L'CF==1だったときはretry変数分だけバイオスコールから回るようにして
   114                              <1> ;     みました.
   115                              <1> ; 9. レジスタを復帰して.
   116                              <1> ;10. スタックフレームを壊して.
   117                              <1> ;11. ただいま.
   101                                      %include "/home/m8ku/prog/src/modules/real/get_font_adr.asm"
     1                              <1> ;get_font_adr(adr)
     2                              <1> get_font_adr:
     3 000002D8 55                  <1>         push    bp                                      ; スタックフレームの構築
     4 000002D9 89E5                <1>         mov     bp , sp                                 ;
     5                              <1> 
     6 000002DB 50                  <1>         push    ax                                      ; 各レジスタの保存
     7 000002DC 53                  <1>         push    bx                                      ;
     8 000002DD 56                  <1>         push    si                                      ;
     9 000002DE 06                  <1>         push    es                                      ;
    10 000002DF 55                  <1>         push    bp                                      ;
    11                              <1> 
    12                              <1> 
    13 000002E0 8B7604              <1>         mov     si , [bp + 4]                           ; dst=FONTアドレスの保存先;
    14                              <1> 
    15 000002E3 B83011              <1>         mov     ax , 0x1130                             ; //フォントアドレスの取得
    16 000002E6 B706                <1>         mov     bh , 0x06                               ; 8x16 font (vga/mcga)
    17 000002E8 CD10                <1>         int     10h                                     ; ES:BP=FONT ADDRESS;
    18                              <1> 
    19 000002EA 8C04                <1>         mov     [si + 0] , es                           ; dst[0]=セグメント;
    20 000002EC 896C02              <1>         mov     [si + 2] , bp                           ; dst[1]=オフセット;
    21                              <1> 
    22 000002EF 5D                  <1>         pop     bp                                      ; 各レジスタの復帰
    23 000002F0 07                  <1>         pop     es                                      ;
    24 000002F1 5E                  <1>         pop     si                                      ;
    25 000002F2 5B                  <1>         pop     bx                                      ;
    26 000002F3 58                  <1>         pop     ax                                      ;
    27                              <1> 
    28 000002F4 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    29 000002F6 5D                  <1>         pop     bp                                      ;
    30                              <1> 
    31 000002F7 C3                  <1>         ret                                             ; //もどっていきなさい
    32                              <1> 
    33                              <1> ;(関数の概要(フォントアドレスを所得する関数です))
    34                              <1> ; 0. BIOSサービスを利用してフォントアドレスを貰い指定の場所へ書き込みます.
    35                              <1> ; 1. スタックフレームの構築とレジスタの保存をし引数のアクセスへ備えます.
    36                              <1> ; 2. 'mov si,[bp+4]' フォンアドレスはES:BPへ書き込まれるので引数としてもらった[保存先+0]が
    37                              <1> ;    セグメントアドレス,[保存先+2]がオフセットアドレスとして書き込むこととします.
    38                              <1> ; 3. 'mov [si+x],XX'でBIOSからもらったフォントアドレスを書き込ます.
    39                              <1> ; 4. スタックの復帰とスタックフレームを破棄して関数の終了へ備えます.
    40                              <1> ; 5. もどっていきなさい.
   102                                      %include "/home/m8ku/prog/src/modules/real/get_mem_info.asm"
     1                              <1> ;get_mem_info()
     2                              <1> get_mem_info:
     3 000002F8 6650                <1>         push    eax                                     ; 各レジスタの保存
     4 000002FA 6653                <1>         push    ebx                                     ;
     5 000002FC 6651                <1>         push    ecx                                     ;
     6 000002FE 6652                <1>         push    edx                                     ;
     7 00000300 56                  <1>         push    si                                      ;
     8 00000301 57                  <1>         push    di                                      ;
     9 00000302 55                  <1>         push    bp                                      ;
    10 00000303 9C                  <1>         pushf                                           ;
    11                              <1> 
    12 00000304 BD0000              <1>         mov     bp , 0                                  ; lines = 0; //行数
    13 00000307 66BB00000000        <1>         mov     ebx , 0                                 ; index = 0; //インデックス
    14                              <1> 
    15 0000030D 68[9903]E8ADFD83C4- <1>         cdecl   puts, .s0                               ;
    15 00000315 02                  <1>
    16                              <1> .10L:                                                   ; do
    17                              <1> ;                                                       ; {
    18 00000316 66B820E80000        <1>         mov     eax , 0x0000E820                        ; EAX = 0x0000E820;
    19                              <1> ;                                                       ; EBX = インデックス
    20 0000031C 66B914000000        <1>         mov     ecx , E820_RECORD_SIZE                  ; ECX = 要求バイト数;
    21 00000322 66BA50414D53        <1>         mov     edx , 0x534D4150                        ; EDX = 'SMAP';
    22 00000328 BF[3004]            <1>         mov     di , .b0                                ; ES：DI ＝ バッファ;
    23 0000032B CD15                <1>         int     0x15                                    ; BIOS(0x15,0xE820);
    24                              <1> 
    25 0000032D 663D50414D53        <1>         cmp     eax , 'PAMS'                            ;
    26 00000333 7402                <1>         je      .12E                                    ;
    27 00000335 EB4C                <1>         jmp     .10E                                    ;
    28                              <1> .12E:
    29 00000337 7302                <1>         jnc     .14E                                    ; if (CF){
    30 00000339 EB48                <1>         jmp     .10E                                    ;   break;
    31                              <1> .14E:                                                   ; } //エラーなし?
    32 0000033B 57E8050183C402      <1>         cdecl   put_mem_info , di                       ; 1レコードのメモリ情報を表示
    33                              <1> 
    34                              <1> 
    35 00000342 668B4510            <1>         mov     eax , [di + 16]                         ; EAX = レコードタイプ;
    36 00000346 6683F803            <1>         cmp     eax , 3                                 ; if (3 == EAX)//ACPIData
    37 0000034A 750F                <1>         jne     .15E                                    ; {
    38                              <1> 
    39 0000034C 668B05              <1>         mov     eax , [di + 0]                          ; EAX = BASEアドレス
    40 0000034F 66A3[0402]          <1>         mov     [ACPI_DATA.adr] , eax                   ; ACPI_DATA.adr = EAX;
    41                              <1> 
    42 00000353 668B4508            <1>         mov     eax , [di + 8]                          ; EAX = Lenght;
    43 00000357 66A3[0802]          <1>         mov     [ACPI_DATA.len] , eax                   ; ACPI_DATA.len = EAX;
    44                              <1> .15E:                                                   ; }
    45 0000035B 6683FB00            <1>         cmp     ebx , 0                                 ; if (0 != EBX)
    46 0000035F 741C                <1> .16Q:   jz      .16E                                    ; {
    47                              <1> 
    48 00000361 45                  <1>         inc     bp                                      ;   lines++;
    49 00000362 83E507              <1>         and     bp , 0x07                               ;   lines &= 0x07;
    50 00000365 7516                <1>         jnz     .16E                                    ;   if (0 == lines)
    51                              <1> ;                                                       ;   {
    52 00000367 68[0D04]E853FD83C4- <1>         cdecl   puts, .s2                               ;       puts(.s2);
    52 0000036F 02                  <1>
    53 00000370 B410                <1>         mov     ah , 0x10                               ;       //キー入力待ち
    54 00000372 CD16                <1>         int     0x16                                    ;       AL=BIOS(0x16,0x10)
    55                              <1> 
    56 00000374 68[1804]E846FD83C4- <1>         cdecl   puts, .s3                               ;       puts(.s3);
    56 0000037C 02                  <1>
    57                              <1> ;                                                       ;   }
    58                              <1> .16E:                                                   ; }
    59 0000037D 6683FB00            <1>         cmp     ebx , 0                                 ;
    60 00000381 7593                <1> .10Q:   jne     .10L                                    ;
    61                              <1> .10E:                                                   ; while (0 != EBX)
    62 00000383 68[DD03]E837FD83C4- <1>         cdecl   puts, .s1                               ;
    62 0000038B 02                  <1>
    63                              <1> 
    64 0000038C 9D                  <1>         popf                                            ; 各レジスタの復帰
    65 0000038D 5D                  <1>         pop     bp                                      ;
    66 0000038E 5F                  <1>         pop     di                                      ;
    67 0000038F 5E                  <1>         pop     si                                      ;
    68 00000390 665A                <1>         pop     edx                                     ;
    69 00000392 6659                <1>         pop     ecx                                     ;
    70 00000394 665B                <1>         pop     ebx                                     ;
    71 00000396 6658                <1>         pop     eax                                     ;
    72                              <1> 
    73 00000398 C3                  <1>         ret                                             ; もとのとこへ
    74                              <1> 
    75 00000399 20453832305F524543- <1> .s0:    db  " E820_RECORD_SIZE:", 0x0A, 0x0D
    75 000003A2 4F52445F53495A453A- <1>
    75 000003AB 0A0D                <1>
    76 000003AD 20426173655F5F5F5F- <1>         db  " Base_____________ Length___________ Type____", 0x0A, 0x0D, 0
    76 000003B6 5F5F5F5F5F5F5F5F5F- <1>
    76 000003BF 204C656E6774685F5F- <1>
    76 000003C8 5F5F5F5F5F5F5F5F5F- <1>
    76 000003D1 20547970655F5F5F5F- <1>
    76 000003DA 0A0D00              <1>
    77 000003DD 202D2D2D2D2D2D2D2D- <1> .s1:    db  " --------------------------------------------", 0x0A, 0x0D, 0
    77 000003E6 2D2D2D2D2D2D2D2D2D- <1>
    77 000003EF 2D2D2D2D2D2D2D2D2D- <1>
    77 000003F8 2D2D2D2D2D2D2D2D2D- <1>
    77 00000401 2D2D2D2D2D2D2D2D2D- <1>
    77 0000040A 0A0D00              <1>
    78 0000040D 203C6D6F72652E2E2E- <1> .s2:    db  " <more...>", 0
    78 00000416 3E00                <1>
    79 00000418 0D2020202020202020- <1> .s3:    db  0x0D, "          ", 0x0D, 0
    79 00000421 20200D00            <1>
    80 00000425 414350496E6F770A0D- <1> .t1:    db  "ACPInow", 0x0A, 0x0D, 0
    80 0000042E 00                  <1>
    81                              <1> 
    82 0000042F 00                  <1>         align   4, db   0
    83 00000430 00<rept>            <1> .b0:    times E820_RECORD_SIZE db 0
    84                              <1> 
    85                              <1> ;put_mem_info(adr)
    86                              <1> put_mem_info:
    87 00000444 55                  <1>         push    bp                                      ; スタックフレームの構築
    88 00000445 89E5                <1>         mov     bp , sp                                 ;
    89                              <1> 
    90 00000447 53                  <1>         push    bx                                      ; 各レジスタの保存
    91 00000448 56                  <1>         push    si                                      ;
    92                              <1> 
    93 00000449 8B7604              <1>         mov     si , [bp + 4]                           ; SI = バッファアドレス;
    94                              <1> 
    95                              <1>         ;Base(64bit)                                    ; //ここから変換していく
    96 0000044C 6A046A106A0468-     <1>         cdecl itoa, word [si + 6], .p2 + 0, 4, 16, 0b0100
    96 00000453 [2305]FF7406E8B1FD- <1>
    96 0000045B 83C40A              <1>
    97 0000045E 6A046A106A0468-     <1>         cdecl itoa, word [si + 4], .p2 + 4, 4, 16, 0b0100
    97 00000465 [2705]FF7404E89FFD- <1>
    97 0000046D 83C40A              <1>
    98 00000470 6A046A106A0468-     <1>         cdecl itoa, word [si + 2], .p3 + 0, 4, 16, 0b0100
    98 00000477 [2C05]FF7402E88DFD- <1>
    98 0000047F 83C40A              <1>
    99 00000482 6A046A106A0468-     <1>         cdecl itoa, word [si + 0], .p3 + 4, 4, 16, 0b0100
    99 00000489 [3005]FF34E87CFD83- <1>
    99 00000491 C40A                <1>
   100                              <1> 
   101                              <1>         ;Length(64bit)
   102 00000493 6A046A106A0468-     <1>         cdecl itoa, word [si + 14], .p4 + 0, 4, 16, 0b0100
   102 0000049A [3505]FF740EE86AFD- <1>
   102 000004A2 83C40A              <1>
   103 000004A5 6A046A106A0468-     <1>         cdecl itoa, word [si + 12], .p4 + 4, 4, 16, 0b0100
   103 000004AC [3905]FF740CE858FD- <1>
   103 000004B4 83C40A              <1>
   104 000004B7 6A046A106A0468-     <1>         cdecl itoa, word [si + 10], .p5 + 0, 4, 16, 0b0100
   104 000004BE [3E05]FF740AE846FD- <1>
   104 000004C6 83C40A              <1>
   105 000004C9 6A046A106A0468-     <1>         cdecl itoa, word [si + 08], .p5 + 4, 4, 16, 0b0100
   105 000004D0 [4205]FF7408E834FD- <1>
   105 000004D8 83C40A              <1>
   106                              <1> 
   107                              <1>         ;Type(32bit)
   108 000004DB 6A046A106A0468-     <1>         cdecl itoa, word [si + 18], .p6 + 0, 4, 16, 0b0100
   108 000004E2 [4705]FF7412E822FD- <1>
   108 000004EA 83C40A              <1>
   109 000004ED 6A046A106A0468-     <1>         cdecl itoa, word [si + 16], .p6 + 4, 4, 16, 0b0100
   109 000004F4 [4B05]FF7410E810FD- <1>
   109 000004FC 83C40A              <1>
   110                              <1> 
   111 000004FF 68[2205]E8BBFB83C4- <1>         cdecl puts, .s1                                 ; レコード情報を表示
   111 00000507 02                  <1>
   112                              <1> ;                                                       ;
   113 00000508 8B5C10              <1>         mov     bx , [si + 16]                          ; 2バイトアドレス変換↓
   114 0000050B 83E307              <1>         and     bx , 0x07                               ; BX = Type(1 ~ 5)
   115 0000050E D1E3                <1>         shl     bx , 1                                  ; BX *= 2;
   116 00000510 81C3[A505]          <1>         add     bx , .t0                                ; BX += .t0;
   117 00000514 FF37E8A7FB83C402    <1>         cdecl puts, word [bx]                           ; puts(*BX);
   118                              <1> 
   119 0000051C 5E                  <1>         pop     si                                      ; 各レジスタの復帰
   120 0000051D 5B                  <1>         pop     bx                                      ;
   121                              <1> 
   122 0000051E 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
   123 00000520 5D                  <1>         pop     bp                                      ;
   124                              <1> 
   125 00000521 C3                  <1>         ret                                             ; おりゃー
   126                              <1> 
   127 00000522 20                  <1> .s1:    db  " "                                         ; 一レコード分のメモリ情報
   128 00000523 5A5A5A5A5A5A5A5A5F  <1> .p2:    db  "ZZZZZZZZ_"                                 ; ベース上位32ビット
   129 0000052C 5A5A5A5A5A5A5A5A20  <1> .p3:    db  "ZZZZZZZZ "                                 ; ベース下位32ビット
   130 00000535 5A5A5A5A5A5A5A5A5F  <1> .p4:    db  "ZZZZZZZZ_"                                 ; バイト長上位32ビット
   131 0000053E 5A5A5A5A5A5A5A5A20  <1> .p5:    db  "ZZZZZZZZ "                                 ; バイト長下位32ビット
   132 00000547 5A5A5A5A5A5A5A5A20- <1> .p6:    db  "ZZZZZZZZ ", 0                              ;　データタイプ32ビット
   132 00000550 00                  <1>
   133                              <1> 
   134 00000551 2028556E6B6E6F776E- <1> .s4:    db  " (Unknown)", 0x0A, 0x0D, 0
   134 0000055A 290A0D00            <1>
   135 0000055E 2028757361626C6529- <1> .s5:    db  " (usable)", 0x0A, 0x0D, 0
   135 00000567 0A0D00              <1>
   136 0000056A 202872657365727665- <1> .s6:    db  " (reserved)", 0x0A, 0x0D, 0
   136 00000573 64290A0D00          <1>
   137 00000578 202841435049206461- <1> .s7:    db  " (ACPI data)", 0x0A, 0x0D, 0
   137 00000581 7461290A0D00        <1>
   138 00000587 202841435049204E56- <1> .s8:    db  " (ACPI NVS)", 0x0A, 0x0D, 0
   138 00000590 53290A0D00          <1>
   139 00000595 2028626164206D656D- <1> .s9:    db  " (bad memory)", 0x0A, 0x0D, 0
   139 0000059E 6F7279290A0D00      <1>
   140                              <1> 
   141 000005A5 [5105][5E05][6A05]- <1> .t0:    dw  .s4, .s5, .s6, .s7, .s8, .s9
   141 000005AB [7805][8705][9505]  <1>
   142                              <1> 
   143                              <1> ;(関数の概要(メモリ情報の取得と表示をします))
   144                              <1> ; 0. 一つのソースファイルの中に２つの関数をつくっています.
   145                              <1> 
   146                              <1> ; <get_mem_info>
   147                              <1> ; 0. レコード情報の取得を行います、専用の表示関数のソースはこちらの関数の下につくっています.
   148                              <1> ; 1. 引数は貰わないのでレジスタの保存だけしちゃいます.
   149                              <1> ; 2. 'mov bp,0''mov ebx,0' 変数の初期化をします.
   150                              <1> ; 3. 'cdecl puts,.s0' ヘッダを表示します.
   151                              <1> ; 4. 'int 0x15' メモリ情報を取得するためにBIOSコールを呼びます、EAXにE820h、ECXに書き込み先
   152                              <1> ;     バイト数、EDXに"SMAP"が引数です.
   153                              <1> ; 5. コマンドが対応しているか検査してEBXが3だったらACPIのテーブルなので値を所定の位置へ書き込
   154                              <1> ;    みます.
   155                              <1> ; 6. 'cdecl put_mem_info,di' テーブル情報のアドレスを引数に専用の表示関数を呼び出します.
   156                              <1> ; 7. '.16Q' メモリ情報を8行分表示するたび注意を促します、ページ数をマスクして非零分岐をします
   157                              <1> ;    lineが8になる度にand命令によって4ビット目が0になり、0からまたlineが加算されていくことに
   158                              <1> ;    なるので8ページずつ文字列を表示することができます.
   159                              <1> ;     line(BP)       0x07
   160                              <1> ;     ________     ________
   161                              <1> ;    |00000001| X |00000111| → ZF = 0                           (ページが1)
   162                              <1> ;     ^^^^^^^^     ^^^^^^^^
   163                              <1> ;     ________     ________
   164                              <1> ;    |00001000| X |00000111| → ZF = 1   → "<more...>"を表示.     (ページが8)
   165                              <1> ;     ^^^^^^^^     ^^^^^^^^
   166                              <1> ;     ________     ________
   167                              <1> ;    |00000001| X |00000111| → ZF = 0                           (ページが9)
   168                              <1> ;     ^^^^^^^^     ^^^^^^^^
   169                              <1> ;     ________     ________
   170                              <1> ;    |00001000| X |00000111| → ZF = 1   → "<more...>"を表示.     (ページが16)
   171                              <1> ;     ^^^^^^^^     ^^^^^^^^
   172                              <1> ; 8. '.10Q' EBXに0が入ると最終レコードなので、それまでレコードの取得を繰り返しをします.
   173                              <1> ; 9. 'cdecl puts,.s1' フッダを表示します
   174                              <1> ;10. 保存しておいたレジスタの復帰をします
   175                              <1> ;11. 'ret' 関数の終了です.
   176                              <1> 
   177                              <1> ; <put_mem_info>
   178                              <1> ; 0. メモリ情報の表示をします、引数にレコードを取ります.
   179                              <1> ;    レコードの構造 > 0 ~ 8(BASEAdr) 8 ~ 16(Len) 16 ~ 20(Type)
   180                              <1> ; 1. スタックフレームの構築をします.
   181                              <1> ; 2. レジスタの保存をします.
   182                              <1> ; 3. 'mov si,[bp+4]' 第一引数をとります.
   183                              <1> ; 4. 'cdecl itoa,xxx' レコード情報を文字列に変換します、レコード長が64bitの値が書き込まれて
   184                              <1> ;    いてx86はリトルエディアンなので後ろから徐々に変換していき変換した文字列は前から配置していき
   185                              <1> ;    ます.
   186                              <1> ; 5. 'cdecl  puts,.s1' 変換した文字列を表示します.
   187                              <1> ; 6. 'mov bx,[si+16]' タイプ情報をとります、知りたいのは下位2Bなので左です.
   188                              <1> ; 7. 'and bx,0x07' マスクします.
   189                              <1> ; 8. 'shl bx,1' タイプ情報を左シフトして2バイトアドレッシングのインデックスにします.
   190                              <1> ; 9. 'add bx,.t0' 事前に定義している各文字列へのアドレスの始端(.t0)に先程つくった値を加算する
   191                              <1> ;    ことで対応した文字列のアドレスを得ることができます.
   192                              <1> ;10. 'cdecl puts,word[bx]' 文字列表示関数に先程つくった値を引数にわたします.
   193                              <1> ;11. お邪魔したのでレジスタを復帰します.
   194                              <1> ;12. 前関数に戻るためにスタックフレームを壊します.
   195                              <1> ;13. 'ret' 前関数へ戻ります.
   103                                      %include "/home/m8ku/prog/src/modules/real/kbc.asm"
     1                              <1> ;int KBC_Data_Write(data)
     2                              <1> KBC_Data_Write:
     3 000005B1 55                  <1>         push    bp                                      ; スタックフレームの構築
     4 000005B2 89E5                <1>         mov     bp , sp                                 ;
     5                              <1> 
     6 000005B4 51                  <1>         push    cx                                      ; 各レジスタの保存
     7 000005B5 9C                  <1>         pushf                                           ;
     8                              <1> 
     9 000005B6 B90300              <1>         mov     cx , 3                                  ; CX = 3; //最大カウント数
    10                              <1> .10L:                                                   ; do
    11                              <1> ;                                                       ; {
    12 000005B9 E464                <1>         in      al , 0x64                               ;   AL = inp(0x64);
    13 000005BB A802                <1>         test    al , 0x02                               ;   ZF = AL & 0x2;
    14                              <1> 
    15 000005BD E0FA                <1>         loopnz  .10L                                    ; } while (--CX && !ZF);
    16                              <1> 
    17 000005BF 83F900              <1>         cmp     cx , 0                                  ; if (CX)
    18 000005C2 7407                <1> .20Q:   jz      .20E                                    ; {
    19                              <1> 
    20 000005C4 8A4604              <1>         mov     al , [bp + 4]                           ;   AL = データ;
    21 000005C7 E660                <1>         out     0x60 , al                               ;   outp(0x60, AL);
    22                              <1> 
    23 000005C9 89C8                <1>         mov     ax , cx                                 ;   return CX;
    24                              <1> .20E:                                                   ; }
    25                              <1> 
    26 000005CB 9D                  <1>         popf                                            ; 各レジスタの復帰
    27 000005CC 59                  <1>         pop     cx                                      ;
    28                              <1> 
    29 000005CD 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    30 000005CF 5D                  <1>         pop     bp                                      ;
    31                              <1> 
    32 000005D0 C3                  <1>         ret                                             ; もとのとこへ
    33                              <1> 
    34                              <1> ;int KBC_Data_Read(data)
    35                              <1> KBC_Data_Read:
    36 000005D1 55                  <1>         push    bp                                      ; スタックフレームの構築
    37 000005D2 89E5                <1>         mov     bp , sp                                 ;
    38                              <1> 
    39 000005D4 51                  <1>         push    cx                                      ; 各レジスタの保存
    40 000005D5 57                  <1>         push    di                                      ;
    41 000005D6 9C                  <1>         pushf                                           ;
    42                              <1> 
    43 000005D7 B90300              <1>         mov     cx , 3                                  ; CX = 3; //最大カウント数
    44                              <1> .10L:                                                   ; do
    45                              <1> ;                                                       ; {
    46 000005DA E464                <1>         in      al , 0x64                               ; AL = inp(0x64);
    47 000005DC A801                <1>         test    al , 0x01                               ; ZF = AL & 0x1;
    48                              <1> 
    49 000005DE E1FA                <1>         loopz  .10L                                     ; } while (CX-- && !ZF);
    50                              <1> 
    51 000005E0 83F900              <1>         cmp     cx , 0                                  ; if (CX)
    52 000005E3 740B                <1> .20Q:   jz      .20E                                    ; {
    53                              <1> 
    54 000005E5 B400                <1>         mov     ah , 0x00                               ; AH = 0;
    55 000005E7 E460                <1>         in      al , 0x60                               ; AL = inp(0x60);
    56                              <1> 
    57 000005E9 8B7E04              <1>         mov     di , [bp + 4]                           ;
    58 000005EC 8905                <1>         mov     [di + 0] , ax                           ;
    59                              <1> 
    60 000005EE 89C8                <1>         mov     ax , cx                                 ; return CX;
    61                              <1> .20E:
    62 000005F0 9D                  <1>         popf                                            ; 各レジスタの復帰
    63 000005F1 5F                  <1>         pop     di                                      ;
    64 000005F2 59                  <1>         pop     cx                                      ;
    65                              <1> 
    66 000005F3 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    67 000005F5 5D                  <1>         pop     bp                                      ;
    68                              <1> 
    69 000005F6 C3                  <1>         ret                                             ; もとのとこへ
    70                              <1> 
    71                              <1> ;int KBC_Cmd_Write(cmd)
    72                              <1> KBC_Cmd_Write:
    73 000005F7 55                  <1>         push    bp                                      ; スタックフレームの構築
    74 000005F8 89E5                <1>         mov     bp , sp                                 ;
    75                              <1> 
    76 000005FA 51                  <1>         push    cx                                      ; 各レジスタの保存
    77 000005FB 9C                  <1>         pushf                                           ;
    78                              <1> 
    79 000005FC B90300              <1>         mov     cx , 3                                  ; CX = 3;//最大カウント数
    80                              <1> .10L:                                                   ; do
    81                              <1> ;                                                       ; {
    82 000005FF E464                <1>         in      al , 0x64                               ; AL = inp(0x64);
    83 00000601 A802                <1>         test    al , 0x02                               ; ZF = AL & 0x2;
    84                              <1> 
    85 00000603 E0FA                <1>         loopnz  .10L                                    ; } while (--CX && !ZF);
    86                              <1> 
    87 00000605 83F900              <1>         cmp     cx , 0                                  ; if(CX)
    88 00000608 7407                <1> .20Q:   jz      .20E                                    ; {
    89                              <1> 
    90 0000060A 8A4604              <1>         mov     al , [bp + 4]                           ; AL = コマンド;
    91 0000060D E664                <1>         out     0x64 , al                               ; outp(0x64, AL)
    92                              <1> 
    93 0000060F 89C8                <1>         mov     ax , cx                                 ; return CX;
    94                              <1> .20E:
    95 00000611 59                  <1>         pop     cx                                      ; 各レジスタの復帰
    96 00000612 9C                  <1>         pushf                                           ;
    97                              <1> 
    98 00000613 89EC                <1>         mov     sp , bp                                 ; スタックフレームの構築
    99 00000615 5D                  <1>         pop     bp                                      ;
   100                              <1> 
   101 00000616 C3                  <1>         ret                                             ; もとのとこへ
   102                              <1> 
   103                              <1> ; (関数の概要())
   104                              <1> ; 0. キーボードドライバの関数を集めました.
   105                              <1> ; <KBC_Data_Write>
   106                              <1> ; 0. KBCが接続されている0x60番のポートへデータを書き込む関数です.
   107                              <1> ; 1. スタックフレームを構築します.
   108                              <1> ; 2. 各レジスタを保存します.
   109                              <1> ; 3. '.10L' 実際にKBCへデータを送る前にするべきことがありそれは、KBCにデータを現在書き込める
   110                              <1> ;    かどうかを検査することです.
   111                              <1> ;    そしてそれを確認するためにはKBCのステータス・レジスタのビット1を確認して入力バッファが空か
   112                              <1> ;    どうかを検査します.
   113                              <1> ;    そのとき(BIT1==0)のときは入力バッファが空つまりKBCへデータを書き込むことができる状態そし
   114                              <1> ;    て(BIT1==1)のときは入力バッファにデータありつまりKBCへデータを書き込むことができない状態
   115                              <1> ;    となります.
   116                              <1> ;    'in al,0x64' KBCのステータス・レジスタを読み込みます.
   117                              <1> ;    'test al,0x02' 読み込んだ値のB1を検査します.
   118                              <1> ;    'loopnz .10L' もし入力バッファが空だったら先へ進みます.
   119                              <1> ;    B1==0 → and 1, 0 → ZF==1 → loopnzをスルー.
   120                              <1> ;    B1==1 → and 1, 1 → ZF==0 → loopnzに引っかかる.
   121                              <1> ;    入力バッファにデータありだったのなら、入力バッファが空になるまでウェイトします、このときCX
   122                              <1> ;    レジスタをカウンターとして3を設定しているので3回検査してバッファが空になるのを確認できなか
   123                              <1> ;    ったら関数の終了となります.
   124                              <1> ; 4. '.20Q' 入力バッファを検査する過程でタイムアウトしたか検査します.
   125                              <1> ;    タイムアウトしたのならCX==0となりKBCへデータを書き込むことができないので関数を終了します.
   126                              <1> ;    バッファが空だったのならKBCへデータを書き込むことができるので引数に書き込む値をとりKBCへ
   127                              <1> ;    データを書き込んだ後、戻り値にカウント数を渡して関数の終了となります.
   128                              <1> ; 5. 各レジスタを復帰します.
   129                              <1> ; 6. スタックフレームを破棄します.
   130                              <1> ; 7. スタックに積まれている戻り番地を基にもとのとこへ.
   131                              <1> 
   132                              <1> ; <KBC_Data_Read>
   133                              <1> ; 0. KBCが接続されている0x60番のポートからデータを読み込む関数です.
   134                              <1> ; 1. スタックフレームを構築します.
   135                              <1> ; 2. 各レジスタを保存します.
   136                              <1> ; 3. '.10L' 実際にKBCからデータを読み込む前にするべきことがありそれは、KBCからデータを現在読み
   137                              <1> ;    込めるかどうかを検査することです.
   138                              <1> ;    そしてそれを確認するためにはKBCのステータス・レジスタのビット0を確認して出力バッファに現在
   139                              <1> ;    読むこむべきデータがあるかどうかを検査します.
   140                              <1> ;    そのとき(BIT0==0)のときは出力バッファが空つまりKBCから読み込むべきデータがない状態そして
   141                              <1> ;    (BIT0==1)のときは出力バッファにデータありつまりKBCから読み込むべきデータがある状態となる
   142                              <1> ;    に加えてここでの読むこむべきデータとはキーボードからのデータがある状態やKBCからのレスポンス
   143                              <1> ;    がある状態をさします.
   144                              <1> ;    'in al,0x64' KBCのステータス・レジスタを読み込みます.
   145                              <1> ;    'test al,0x02' 読み込んだ値のB0を検査します.
   146                              <1> ;    'loopz .10L' もし出力バッファがデータありだったら先へ進みます.
   147                              <1> ;    B0==0 → and 1, 0 → ZF==1 → loopzに引っかかる.
   148                              <1> ;    B0==1 → and 1, 1 → ZF==0 → loopzをスルー.
   149                              <1> ;    出力バッファにデータがなかったのなら、出力バッファにデータありになるまでウェイトします、こ
   150                              <1> ;    のときCXレジスタをカウンターとして3を設定しているので3回検査してバッファにデータありになる
   151                              <1> ;    のを確認できなかったら関数の終了となります.
   152                              <1> ; 4. '.20Q' 出力バッファを検査する過程でタイムアウトしたか検査します.
   153                              <1> ;    タイムアウトしたのならCX==0となりKBCから読むこむべきデータがないので関数を終了します.
   154                              <1> ;    バッファにデータありだったのならKBCから読み込むべきデータがあるのでKBCからデータを読み込み
   155                              <1> ;    引数にアドレスをとり読み込んだ値を所定の位置へ書き込んだ後、戻り地にカウント数を渡して関数
   156                              <1> ;    の終了となります.
   157                              <1> ; 5. 各レジスタを復帰します.
   158                              <1> ; 6. スタックフレームを破棄します.
   159                              <1> ; 7. もとのとこへ.
   160                              <1> 
   161                              <1> ; <KBC_Cmd_Write>
   162                              <1> ; 0. コマンドを書き込みたいので'out 0x64 ,al'としました.
   104                                      %include "/home/m8ku/prog/src/modules/real/read_lba.asm"
     1                              <1> ;read_lba(drive, lba, sect, dst)
     2                              <1> read_lba:
     3 00000617 55                  <1>         push    bp                                      ; スタックフレームの構築
     4 00000618 89E5                <1>         mov     bp , sp                                 ;
     5                              <1> 
     6 0000061A 56                  <1>         push    si                                      ; 各レジスタの保存
     7 0000061B 9C                  <1>         pushf                                           ;
     8                              <1> 
     9 0000061C 8B7604              <1>         mov     si , [bp + 4]                           ; 第一引数へアクセス
    10                              <1> 
    11 0000061F 8B4606              <1>         mov     ax , [bp + 6]                           ; 第二引数へアクセス
    12                              <1> 
    13 00000622 5068[4706]56E82500- <1>         cdecl   lba_chs, si, .chs, ax                   ; lba_chs(drive,.chs,lba)
    13 0000062A 83C406              <1>
    14                              <1> 
    15 0000062D 8A04                <1>         mov     al , [si + drive.no]                    ; ドライブ番号をもってきて
    16 0000062F A2[4706]            <1>         mov     [.chs + drive.no] , al                  ; .chsへ書く
    17                              <1> 
    18 00000632 FF760AFF760868-     <1>         cdecl   read_chs, .chs, word [bp + 8], word [bp + 10]
    18 00000639 [4706]E8E2FA83C406  <1>
    19                              <1> 
    20 00000641 9D                  <1>         popf                                            ; 各レジスタの復帰
    21 00000642 5E                  <1>         pop     si                                      ;
    22                              <1> 
    23                              <1>         ;                                          AX = read_chs(drive,sect,dst)
    24 00000643 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    25 00000645 5D                  <1>         pop     bp                                      ;
    26                              <1> 
    27 00000646 C3                  <1>         ret                                             ; もとのとこへ
    28                              <1> 
    29 00000647 00<rept>            <1> .chs:   times drive_size    db  0                       ; 読み込みセクタに関する情報
    30                              <1> ;(関数の概要(lba方式でディスクアクセスをする関数です))
    31                              <1> ; 0. lba方式でディスクアクセスをしたいときに利用する関数です.
    32                              <1> ;    lba方式でディスクアクセスするように見えますが実はchs方式でアクセスしています.
    33                              <1> ; 1. スタックフレームを立てます.
    34                              <1> ; 2. それぞれの引数へアクセスします.
    35                              <1> ;    第一引数はドライブ情報が書き込んである構造体のアドレスです.
    36                              <1> ;    第二引数はlba方式でのセクタ番号です.
    37                              <1> ; 3. lba方式によるセクタ指定をchs方式よるセクタ指定に変換する関数を発行します.
    38                              <1> ; 4. ドライブ番号がまだ構造体に入っていないのでブートストラップの中で得た値を代用します.
    39                              <1> ; 5. lba方式をchs方式へ変換できたのでchs方式によるセクタ読み関数を発行します.
    40                              <1> ;    戻り値は読み込んだセクタ数です.
    41                              <1> ; 6. 各レジスタを復帰します.
    42                              <1> ; 7. スタックフレームを解体して.
    43                              <1> ; 8. もとのとこへ.
    44                              <1> 
    45                              <1> ;lba_chs(drive, drv_chs, lba)
    46                              <1> lba_chs:
    47 0000064F 55                  <1>         push    bp                                      ; スタックフレームの構築
    48 00000650 89E5                <1>         mov     bp , sp                                 ;
    49                              <1> 
    50 00000652 50                  <1>         push    ax                                      ; 各レジスタの保存
    51 00000653 53                  <1>         push    bx                                      ;
    52 00000654 52                  <1>         push    dx                                      ;
    53 00000655 56                  <1>         push    si                                      ;
    54 00000656 57                  <1>         push    di                                      ;
    55 00000657 9C                  <1>         pushf                                           ;
    56                              <1> 
    57 00000658 8B7604              <1>         mov     si , [bp + 4]                           ; 第一引数を取得
    58 0000065B 8B7E06              <1>         mov     di , [bp + 6]                           ; 第二引数を取得
    59                              <1> 
    60 0000065E 8A4404              <1>         mov     al , [si + drive.head]                  ; AL = 最大ヘッド数
    61 00000661 F66406              <1>         mul     byte [si + drive.sect]                  ; AX = AL * 最大セクタ数
    62 00000664 89C3                <1>         mov     bx , ax                                 ; BX = cylnあたりのセクタ数
    63                              <1> 
    64 00000666 8B4608              <1>         mov     ax , [bp + 8]                           ; 第三引数を取得
    65 00000669 BA0000              <1>         mov     dx , 0                                  ; DX = LBA (上位二バイト)
    66 0000066C F7F3                <1>         div     bx                                      ; AX=DX:AX/BX//シリンダ番号
    67                              <1>         ;                                               ; DX = DX:AX % BX //残り
    68 0000066E 894502              <1>         mov     [di + drive.cyln] , ax                  ; drv_chs.cyln=シリンダ番号
    69                              <1> 
    70 00000671 89D0                <1>         mov     ax , dx                                 ; AX = 残り
    71 00000673 F67406              <1>         div     byte [si + drive.sect]                  ; AL=AX / sect//ヘッド番号
    72                              <1>         ;                                               ; AH=AX % sect//セクタ番号
    73 00000676 0FB6D4              <1>         movzx   dx , ah                                 ; DX = セクタ番号
    74 00000679 42                  <1>         inc     dx                                      ; (セクタは1始まりだから+1)
    75                              <1> 
    76 0000067A B400                <1>         mov     ah , 0                                  ; AX = ヘッド位置
    77                              <1> 
    78 0000067C 894504              <1>         mov     [di + drive.head] , ax                  ; drv_chs.head = ヘッド番号
    79 0000067F 895506              <1>         mov     [di + drive.sect] , dx                  ; drv_chs.sect = セクタ番号
    80                              <1> 
    81 00000682 9D                  <1>         popf                                            ; 各レジスタの復帰
    82 00000683 5F                  <1>         pop     di                                      ;
    83 00000684 5E                  <1>         pop     si                                      ;
    84 00000685 5A                  <1>         pop     dx                                      ;
    85 00000686 5B                  <1>         pop     bx                                      ;
    86 00000687 58                  <1>         pop     ax                                      ;
    87                              <1> 
    88 00000688 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    89 0000068A 5D                  <1>         pop     bp                                      ;
    90                              <1> 
    91 0000068B C3                  <1>         ret                                             ; もとのとこへ
    92                              <1> 
    93                              <1> ;(関数の概要(lba方式をchs方式へ変換する関数です))
    94                              <1> ; 0. ディスクを最大限に活用するためにlba方式を利用したいところですが、互換性を考えてLBA方式によ
    95                              <1> ;    るセクタ指定をCHS方式へ変換する関数を作りました. driveはドライブ情報のアドレスをdrv_chs
    96                              <1> ;    は変換後の値をlbaはLBA方式によるセクタ番号を、３つを引数にとります.
    97                              <1> ;    変換前に必要となる構造体のアドレスはSIレジスタに書き込んでおきます.
    98                              <1> ;    変換後に書き込む構造体のアドレスはDIレジスタに書き込んでおきます.
    99                              <1> ;    [si + drive.no] [di + drive.no] このように変換前と変換後の区別をつけます.
   100                              <1> ; 1. スタックフレームを構築します.
   101                              <1> ; 2. 各レジスタを保存します.
   102                              <1> ; 3. シリンダあたりのセクタ数を導くためにすでに取得している最大ヘッド数と最大セクタ数を掛けます.
   103                              <1> ; 4. 次にシリンダ番号を導きます、シリンダ番号=LBA / シリンダあたりのセクタ数 によって導きます.
   104                              <1> ; 5. 次にヘッド番号とセクタ番号を導きます. シリンダ番号の演算をした時に出る余剰を基に導きます.
   105                              <1> ;    ヘッド番号 = シリンダ番号の余り / 最大セクタ数
   106                              <1> ;    セクタ番号 = ヘッド番号の余り + 1
   107                              <1> ; 6. こちらは、ヘッド番号=シリンダ番号 / 最大セクタ数  セクタ番号=シリンダ番号 % 最大セクタ数
   108                              <1> ;    ともいえます.
   109                              <1> ; 7. それぞれを変換後の構造体へ書き込みます.
   110                              <1> ;    movzxはゼロ拡張と呼ばれる動作をします. 1Bレジスタを2Bレジスタに転送する時に転送先の2B目を
   111                              <1> ;    ゼロで埋めます.
   112                              <1> ; 8. 各レジスタを復帰します.
   113                              <1> ; 9. スタックフレームを取ります.
   114                              <1> ;10. もとのとこへ戻ってもらいます.
   105                                      %include "/home/m8ku/prog/src/modules/real/apm.asm"
     1                              <1> ;;int status = apm_installation_check()
     2                              <1> apm_installation_check:
     3 0000068C 55                  <1>         push    bp                                      ; スタックフレームの構築
     4 0000068D 89E5                <1>         mov     bp , sp                                 ;
     5                              <1> 
     6 0000068F 53                  <1>         push    bx                                      ; 各レジスタの保存
     7 00000690 9C                  <1>         pushf                                           ;
     8                              <1> 
     9 00000691 B453                <1>         mov     ah , 0x53                               ; AH = 0x53;
    10 00000693 B000                <1>         mov     al , 0x00                               ; AL = 0x00;
    11 00000695 31DB                <1>         xor     bx , bx                                 ; BX = 0x00;
    12                              <1> 
    13 00000697 CD15                <1>         int     0x15                                    ; CF = BIOS(0x15,0x0053)
    14 00000699 7205                <1>         jc     .apm_error                               ; if (CF == 0) {
    15                              <1> 
    16 0000069B B80000              <1>             mov     ax , 0                              ; //ok
    17                              <1> 
    18 0000069E EB03                <1>         jmp    .end_check                               ; } else
    19                              <1> .apm_error:                                             ; {
    20                              <1> 
    21 000006A0 B80100              <1>             mov     ax , 1                              ; //error status
    22                              <1> 
    23                              <1> .end_check:                                             ; }
    24                              <1> 
    25 000006A3 9D                  <1>         popf                                            ;
    26 000006A4 5B                  <1>         pop     bx                                      ; 各レジスタの復帰
    27                              <1> 
    28 000006A5 89EC                <1>         mov     sp , bp                                 ; スッタックフレームの破棄
    29 000006A7 5D                  <1>         pop     bp                                      ;
    30                              <1> 
    31                              <1> 
    32 000006A8 C3                  <1>         ret                                             ; いってらっしゃい
    33                              <1> 
    34                              <1> ; 関数の概要(APMをサポートしているかをBIOSに尋ねる関数です)
    35                              <1> ; 1. スタックフレームを構築します.
    36                              <1> ; 2. 各レジスタを保存します. 戻り値を設定するのでAXレジスタは保存しません.
    37                              <1> ; 3. APMをサーポートしているか尋ねます.
    38                              <1> ;    AH=53h AL=00H BX=00H で15番でソフトウェア割り込みします.
    39                              <1> ;    ここで確認結果としてCFを確認します.
    40                              <1> ;    CF = 0 の場合はサポート○
    41                              <1> ;    CF = 1 の場合はサポート☓
    42                              <1> ;    で、それそれ戻り値に0と1を設定します.
    43                              <1> ; 4. 各レジスタを復帰します.
    44                              <1> ; 5. スタックフレームを破棄します.
    45                              <1> ; 6. ご主人様のとこへ
    46                              <1> 
    47                              <1> ;apm_shutdown()
    48                              <1> apm_shutdown:
    49 000006A9 55                  <1>         push    bp                                      ; スッタックフレームの構築
    50 000006AA 89E5                <1>         mov     bp , sp                                 ;
    51                              <1> 
    52 000006AC 53                  <1>         push    bx                                      ; 各レジスタの保存
    53 000006AD 51                  <1>         push    cx                                      ;
    54 000006AE 9C                  <1>         pushf                                           ;
    55                              <1> 
    56 000006AF B453                <1>         mov     ah , 0x53                               ; ぞれぞれの引数を書き込む
    57 000006B1 B007                <1>         mov     al , 0x07                               ;
    58 000006B3 BB0100              <1>         mov     bx , 0x01                               ;
    59 000006B6 B90300              <1>         mov     cx , 0x03                               ;
    60 000006B9 CD15                <1>         int     0x15                                    ;
    61                              <1> .error:
    62 000006BB B80100              <1>         mov     ax , 1                                  ; umm...
    63                              <1> 
    64 000006BE 9D                  <1>         popf                                            ; 各レジスタの復帰
    65 000006BF 59                  <1>         pop     cx                                      ;
    66 000006C0 5B                  <1>         pop     bx                                      ;
    67                              <1> 
    68 000006C1 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    69 000006C3 5D                  <1>         pop     bp                                      ;
    70                              <1> 
    71 000006C4 C3                  <1>         ret                                             ; おかえりなさいませ
    72                              <1> 
    73                              <1> ; 関数雨の概要(シャットダウンします)
    74                              <1> ; 0. ここではAPMによる電断をします.
    75                              <1> ;    実際にこの関数を呼び出す前に"apm_installation_check()"関数を発行してAPMに対応している
    76                              <1> ;    かを調べます.
    77                              <1> ;    APMへBIOSコールを介して対話します. それぞれの引数は
    78                              <1> ;
    79                              <1> ;    AH = 53h   ; APMのコマンド
    80                              <1> ;    AL = 07h   ; 電源のあれこれを決めるように
    81                              <1> ;    BX = 01h   ; コンピュータに対して
    82                              <1> ;    CX = 03h   ; シャットダウン
    83                              <1> ;    --ここでそれぞれ以下となる.
    84                              <1> ;    -- 03h = シャットダウン 02h = サスペンド 01h = スタンバイ
    85                              <1> ;    int 0x15   ; 15番でバイオスコール
    86                              <1> ;
    87                              <1> ;    と、なります.
    88                              <1> ;
    89                              <1> ; 1. スタックフレームを構築します.
    90                              <1> ; 2. 各レジスタを保存します. 戻り値を設定するのでAXレジスタは保存しません.
    91                              <1> ; 3. それぞれに引数を設定して電断します.
    92                              <1> ; 4. もし電断ができなくてもまだ大丈夫です.
    93                              <1> ; 5. エラーステータスの1を戻り値に設定して.
    94                              <1> ; 6. 各レジスタを復帰して.
    95                              <1> ; 7. ご主人様のもとへ.
   106                                  
   107                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   108                                      ; ブートプログラムの第二ステージ ▽
   109                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   110                                  stage_2nd:
   111                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   112                                          ; 文字列を表示
   113                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   114 000006C5 68[3F07]E8F5F983C4-             cdecl puts, .s0                                 ; puts(.s0);
   114 000006CD 02                 
   115                                  
   116                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   117                                          ; ドライブ情報を取得
   118                                          ;;;:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   119 000006CE 68[B800]E8BAFB83C4-             cdecl   get_drive_param, BOOT                   ; get_drive_param(BOOT);
   119 000006D6 02                 
   120 000006D7 83F800                          cmp     ax , 0                                  ; if (0 == AX)
   121 000006DA 750C                    .10Q:   jnz     .10E                                    ; {
   122 000006DC 68[7607]E8DEF983C4-     .10T:   cdecl   puts, .e0                               ;   puts(.e0);
   122 000006E4 02                 
   123 000006E5 E8F9F9                          call    reboot                                  ;   reboot(); //再起動
   124                                  .10E:                                                   ; }
   125                                  
   126                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   127                                          ; ドライブ情報を表示
   128                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   129 000006E8 A1[B800]                        mov     ax , [BOOT + drive.no]                  ; AX = ブートドライブ
   130 000006EB 6A046A106A0268-                 cdecl   itoa, ax, .p1, 2, 16, 0b0100            ;
   130 000006F2 [5707]50E814FB83C4-
   130 000006FA 0A                 
   131                                  
   132 000006FB A1[BA00]                        mov     ax , [BOOT + drive.cyln]                ; AX = シリンダ(トラック)数
   133 000006FE 6A046A106A0468-                 cdecl   itoa, ax, .p2, 4, 16, 0b0100            ;
   133 00000705 [5F07]50E801FB83C4-
   133 0000070D 0A                 
   134                                  
   135 0000070E A1[BC00]                        mov     ax , [BOOT + drive.head]                ; AX = ヘッド数
   136 00000711 6A046A106A0268-                 cdecl   itoa, ax, .p3, 2, 16, 0b0100            ;
   136 00000718 [6907]50E8EEFA83C4-
   136 00000720 0A                 
   137                                  
   138 00000721 A1[BE00]                        mov     ax , [BOOT + drive.sect]                ; AX=トラックあたりのセクタ数
   139 00000724 6A046A106A0268-                 cdecl   itoa, ax, .p4, 2, 16, 0b0100            ;
   139 0000072B [7107]50E8DBFA83C4-
   139 00000733 0A                 
   140                                  
   141 00000734 68[4E07]E886F983C4-             cdecl   puts, .s2                               ; puts(.s2); //情報を表示
   141 0000073C 02                 
   142                                  
   143                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   144                                          ; 次のステージへ移行
   145                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   146 0000073D EB52                            jmp     stage_3rd                               ; 第三ステージへ移行
   147                                  
   148                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   149                                          ; データ
   150                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   151 0000073F 326E64207374616765-     .s0:    db  "2nd stage...", 0x0A, 0x0D, 0
   151 00000748 2E2E2E0A0D00       
   152 0000074E 2044726976653A3078      .s2:    db  " Drive:0x"
   153 00000757 2D2D2C20433A3078        .p1:    db  "--, C:0x"
   154 0000075F 2D2D2D2D2C20483A30-     .p2:    db  "----, H:0x"
   154 00000768 78                 
   155 00000769 2D2D2C20533A3078        .p3:    db  "--, S:0x"
   156 00000771 2D2D0A0D00              .p4:    db  "--", 0x0A, 0x0D, 0
   157 00000776 4572726F723A43616E-     .e0:    db  "Error:Can't get parameter.", 0
   157 0000077F 277420676574207061-
   157 00000788 72616D657465722E00 
   158                                  
   159                                      ;****************************************************
   160                                      ; ブートプログラムの第三ステージ ▽
   161                                      ;****************************************************
   162                                  stage_3rd:
   163                                          ;************************************************
   164                                          ; 文字列を表示
   165                                          ;************************************************
   166 00000791 68[1908]E829F983C4-             cdecl   puts, .s1                               ; puts(.s1);
   166 00000799 02                 
   167                                  
   168                                          ;************************************************
   169                                          ; プロテクトモードで使用するフォントは、BIOSに内蔵された
   170                                          ; ものを流用する
   171                                          ;************************************************
   172 0000079A 68[0002]E838FB83C4-             cdecl   get_font_adr, FONT                      ; BIOSフォントアドレスを取得
   172 000007A2 02                 
   173                                  
   174                                          ;************************************************
   175                                          ; フォントアドレスの表示
   176                                          ;************************************************
   177 000007A3 6A046A106A0468-                 cdecl   itoa, word [FONT.seg], .p1, 4, 16, 0b0100
   177 000007AA [3608]FF36[0002]E8-
   177 000007B1 59FA83C40A         
   178 000007B6 6A046A106A0468-                 cdecl   itoa, word [FONT.off], .p2, 4, 16, 0b0100
   178 000007BD [3B08]FF36[0202]E8-
   178 000007C4 46FA83C40A         
   179 000007C9 68[2808]E8F1F883C4-             cdecl   puts, .s2
   179 000007D1 02                 
   180                                  
   181                                          ;************************************************
   182                                          ; メモリ情報の取得と表示
   183                                          ;************************************************
   184 000007D2 E823FB                          cdecl   get_mem_info                            ; get_mem_info();
   185                                  
   186 000007D5 66A1[0402]                      mov     eax , [ACPI_DATA.adr]                   ; EAX = ACPI_DATA.adr;
   187 000007D9 6683F800                        cmp     eax , 0                                 ; if (EAX)
   188 000007DD 742D                    .10Q:   je      .10E                                    ;{
   189 000007DF 6A046A106A0468-                 cdecl itoa, ax, .p4, 4, 16, 0b0100              ; itoa(AX); //下位Adr変換
   189 000007E6 [5408]50E820FA83C4-
   189 000007EE 0A                 
   190 000007EF 66C1E810                        shr     eax , 16                                ; EAX >>= 16;
   191 000007F3 6A046A106A0468-                 cdecl itoa, ax, .p3, 4, 16, 0b0100              ; itoa(AX); //上位Adr変換
   191 000007FA [5008]50E80CFA83C4-
   191 00000802 0A                 
   192                                  
   193 00000803 68[4508]E8B7F883C4-             cdecl puts, .s3                                 ; puts(.s3);
   193 0000080B 02                 
   194                                  .10E:                                                   ; }
   195                                  
   196                                          ;************************************************
   197                                          ; 次のステージへ移行
   198                                          ;************************************************
   199 0000080C EB4D                            jmp     stage_4th                               ; 第四ステージへ移行
   200                                  
   201 0000080E 2D2D2D2D2D2D2D2D0A-     .s0:    db  "--------", 0x0A, 0x0D, 0
   201 00000817 0D00               
   202 00000819 337264207374616765-     .s1:    db  "3rd stage...", 0x0A, 0x0D, 0
   202 00000822 2E2E2E0A0D00       
   203                                  
   204 00000828 20466F6E7420416464-     .s2:    db  " Font Address="
   204 00000831 726573733D         
   205 00000836 5A5A5A5A3A              .p1:    db  "ZZZZ:"
   206 0000083B 5A5A5A5A0A0D00          .p2:    db  "ZZZZ", 0x0A, 0x0D, 0
   207 00000842 0A0D00                          db  0x0A, 0x0D, 0
   208                                  
   209 00000845 204143504920444154-     .s3:    db  " ACPI DATA="
   209 0000084E 413D               
   210 00000850 5A5A5A5A                .p3:    db  "ZZZZ"                                      ; 上位32ビット
   211 00000854 5A5A5A5A0A0D00          .p4:    db  "ZZZZ", 0x0A, 0x0D, 0                       ; 下位32ビット
   212                                  
   213                                      ;----------------------------------------------------
   214                                      ; ブートプログラムの第四ステージ ▽
   215                                      ;----------------------------------------------------
   216                                  stage_4th:
   217                                          ;------------------------------------------------
   218                                          ; 文字列を表示
   219                                          ;------------------------------------------------
   220 0000085B 68[4609]E85FF883C4-             cdecl   puts, .s0                               ; puts(.s0);
   220 00000863 02                 
   221                                  
   222                                          ;------------------------------------------------
   223                                          ; A20ゲートの有効化
   224                                          ;------------------------------------------------
   225 00000864 FA                              cli                                             ; //割り込み禁止
   226                                  
   227 00000865 68AD00E88CFD83C402              cdecl   KBC_Cmd_Write, 0xAD                     ; //キーボード無効化
   228                                  
   229 0000086E 68D000E883FD83C402              cdecl   KBC_Cmd_Write, 0xD0                     ; //出力信号読み出しコマンド
   230 00000877 68[4209]E854FD83C4-             cdecl   KBC_Data_Read, .key                     ; //出力信号のデータ読み込み
   230 0000087F 02                 
   231                                  
   232 00000880 8A1E[4209]                      mov     bl , [.key]                             ; BL = key;
   233 00000884 80CB02                          or      bl , 0x02                               ; BL |= 0x02; //A20Gate
   234                                  
   235 00000887 68D100E86AFD83C402              cdecl   KBC_Cmd_Write, 0xD1                     ; //出力信号書き込みコマンド
   236 00000890 53E81DFD83C402                  cdecl   KBC_Data_Write, bx                      ; //出力信号へ反映
   237                                  
   238 00000897 83F800                          cmp     ax , 0                                  ; if (0 == AX)
   239 0000089A 7509                    .10Q:   jnz     .10E                                    ; {
   240 0000089C 68[6A09]E81EF883C4-             cdecl   puts, .s2                               ;   puts(.s2);
   240 000008A4 02                 
   241                                  .10E:                                                   ; }
   242 000008A5 68AE00E84CFD83C402              cdecl   KBC_Cmd_Write, 0xAE                     ; //キーボード有効化
   243                                  
   244 000008AE FB                              sti                                             ; //割り込み許可
   245                                  
   246                                          ;------------------------------------------------
   247                                          ; 文字列を表示
   248                                          ;------------------------------------------------
   249 000008AF 68[5509]E80BF883C4-             cdecl   puts, .s1                               ; puts(.s1);
   249 000008B7 02                 
   250                                  
   251                                          ;------------------------------------------------
   252                                          ; キーボードLEDのテスト
   253                                          ;------------------------------------------------
   254 000008B8 68[8509]E802F883C4-             cdecl   puts, .s3                               ; //開始の旨を表示
   254 000008C0 02                 
   255                                  
   256 000008C1 BB0000                          mov     bx , 0                                  ; BX = LEDの初期値;
   257 000008C4 B92700                          mov     cx , 39                                 ; テストの回数を制限
   258                                  .20L:                                                   ; do {
   259 000008C7 51                              push    cx                                      ; 回数カウンタの保存
   260 000008C8 B400                            mov     ah , 0x00                               ; AH = 0;
   261 000008CA CD16                            int     0x16                                    ; AL = BIOS(0x16,0x00)
   262                                  
   263 000008CC 3C31                            cmp     al , '1'                                ; if (AL < 1) {
   264 000008CE 7267                            jb      .20E                                    ;   break; }
   265                                  
   266 000008D0 3C33                            cmp     al, '3'                                 ; if (3 < AL) {
   267 000008D2 7763                            ja      .20E                                    ;   break; }
   268                                  
   269 000008D4 88C1                            mov     cl , al                                 ; CL = キー入力
   270 000008D6 FEC9                            dec     cl                                      ; CL --; //１減算
   271 000008D8 80E103                          and     cl , 0x03                               ; CL &= 0x03; //0~2に制限
   272 000008DB B80100                          mov     ax , 0x0001                             ; AX = 0x0001;//bit変換用
   273 000008DE D3E0                            shl     ax , cl                                 ; AX <<= CL;//0~2bitシフト
   274 000008E0 31C3                            xor     bx , ax                                 ; BX ^= ax; //ビット反転
   275                                  
   276 000008E2 FA                              cli                                             ; // 割り込み禁止
   277                                  
   278 000008E3 68AD00E80EFD83C402              cdecl KBC_Cmd_Write, 0xAD                       ; // キーボード無効化
   279                                  
   280 000008EC 68ED00E805FD83C402              cdecl KBC_Cmd_Write, 0xED                       ; // LEDコマンド
   281 000008F5 68[4209]E8D6FC83C4-             cdecl KBC_Data_Read, .key                       ; // 受信応答の取得
   281 000008FD 02                 
   282                                  
   283 000008FE 803E[4209]FA                    cmp     [.key] , byte 0xFA                      ; if (0xFA == key)
   284 00000903 7509                    .21Q:   jne     .21F                                    ; {
   285 00000905 53E8A8FC83C402                  cdecl KBC_Data_Write, bx                        ;   //LEDデータの書き込み
   286 0000090C EB1C                            jmp     .21E                                    ; } else
   287                                  .21F:                                                   ; {
   288 0000090E 6A006A106A0268-                 cdecl   itoa, word [.key], .e1, 2, 16, 0b0000   ; 受信コードの準備
   288 00000915 [AA09]FF36[4209]E8-
   288 0000091C EEF883C40A         
   289 00000921 68[A809]E899F783C4-             cdecl   puts, .e0                               ; 受信コードの表示
   289 00000929 02                 
   290                                  .21E:                                                   ; }
   291 0000092A 68AE00E8C7FC83C402              cdecl KBC_Cmd_Write, 0xAE                       ; キーボード有効化
   292                                  
   293 00000933 FB                              sti                                             ; 割り込み許可
   294                                  
   295 00000934 59                              pop     cx                                      ; 回数カウンタの復帰
   296 00000935 E290                            loop    .20L                                    ; while (--CX);
   297                                  .20E:
   298                                          ;------------------------------------------------
   299                                          ; 文字列を表示
   300                                          ;------------------------------------------------
   301 00000937 68[9B09]E883F783C4-             cdecl   puts, .s4                               ; //完了の旨を表示
   301 0000093F 02                 
   302                                  
   303                                          ;------------------------------------------------
   304                                          ; 次のステージへ！
   305                                          ;------------------------------------------------
   306 00000940 EB6E                            jmp     stage_5th                               ; 第五ステージへ移行
   307                                  
   308 00000942 0000                    .key:   dw  0
   309 00000944 0000                    .f1:    dw  0
   310 00000946 347468207374616765-     .s0:    db  "4th stage...", 0x0A, 0x0D, 0
   310 0000094F 2E2E2E0A0D00       
   311 00000955 204132302047617465-     .s1:    db  " A20 Gate Enabled.", 0x0A, 0x0D, 0
   311 0000095E 20456E61626C65642E-
   311 00000967 0A0D00             
   312 0000096A 204132302047617465-     .s2:    db  " A20 Gate could't Enable", 0x0A, 0x0D, 0
   312 00000973 20636F756C64277420-
   312 0000097C 456E61626C650A0D00 
   313 00000985 204B6579626F617264-     .s3:    db  " Keyboard LED Test...", 0
   313 0000098E 204C45442054657374-
   313 00000997 2E2E2E00           
   314 0000099B 2028646F6E65290A0D-     .s4:    db  " (done)", 0x0A, 0x0D, 0
   314 000009A4 00                 
   315 000009A5 0A0D00                  .s5:    db  0x0A, 0x0D, 0
   316 000009A8 205B                    .e0:    db  " ["
   317 000009AA 5A5A5D0A0D00            .e1:    db  "ZZ]", 0x0A, 0x0D, 0
   318                                  
   319                                      ;----------------------------------------------------
   320                                      ; ブートプログラムの第五ステージ ▽
   321                                      ;----------------------------------------------------
   322                                  stage_5th:
   323                                          ;------------------------------------------------
   324                                          ; 第五ステージへ来ました
   325                                          ;------------------------------------------------
   326 000009B0 68[DC09]E80AF783C4-             cdecl   puts, .s0
   326 000009B8 02                 
   327                                  
   328                                          ;------------------------------------------------
   329                                          ; カーネルを読み込む
   330                                          ;------------------------------------------------
   331 000009B9 68009C6A106A1068-               cdecl   read_lba, BOOT, BOOT_SECT, KERNEL_SECT, BOOT_END
   331 000009C1 [B800]E851FC83C408 
   332                                          ;                      read_lba(BOOT, BOOT_SECT, KERNEL_SECT, BOOT_END)
   333 000009C9 83F810                  .10Q:   cmp     ax , KERNEL_SECT                        ; if (AX != KERNEL_SECT)
   334 000009CC 740C                            jz      .10E                                    ; {
   335 000009CE 68[EB09]E8ECF683C4-     .10T:   cdecl   puts, .e0                               ;   puts(.e0);
   335 000009D6 02                 
   336 000009D7 E807F7                          call    reboot                                  ;   reboot();
   337                                  .10E:                                                   ; }
   338                                  
   339 000009DA EB28                            jmp     stage_6th                               ; while (1); //　∞
   340                                  
   341                                  
   342 000009DC 357468207374616765-     .s0:    db  "5th stage...", 0x0A, 0x0D, 0
   342 000009E5 2E2E2E0A0D00       
   343 000009EB 4661696C757265206C-     .e0:    db  "Failure load kernel...", 0x0A, 0x0D, 0
   343 000009F4 6F6164206B65726E65-
   343 000009FD 6C2E2E2E0A0D00     
   344                                  
   345                                  stage_6th:
   346                                          ;------------------------------------------------
   347                                          ; 第六ステージまできましたよー
   348                                          ;------------------------------------------------
   349 00000A04 68[9E0A]E8B6F683C4-             cdecl puts, .s1
   349 00000A0C 02                 
   350                                  
   351 00000A0D 68[AD0A]E8ADF683C4-             cdecl puts, .s0
   351 00000A15 02                 
   352                                  .10L:                                                   ; while (1)
   353                                          ;                                               ; {
   354 00000A16 B81000                          mov     ax , 0x10                               ; //キー入力待ち
   355 00000A19 CD16                            int     0x16                                    ; AL = BIOS(0x16, 0x10);
   356                                  
   357 00000A1B 3C70                            cmp     al , 'p'                                ; if (AL == 'p')
   358 00000A1D 7507                    .13Q:   jne     .13E                                    ; {
   359 00000A1F B81200                          mov     ax , 0x0012                             ;   //VGA 640×480
   360 00000A22 CD10                            int     0x10                                    ;   BIOS(0x10, 0x12);
   361 00000A24 EB5A                            jmp     .10E                                    ;   break;
   362                                  .13E:                                                   ; }
   363                                          ; 電断↓
   364 00000A26 3C73                            cmp     al , 's'                                ; if (AL == 's')
   365 00000A28 7554                    .20Q:   jne     .20E                                    ; {
   366                                  
   367 00000A2A E85FFC                          cdecl   apm_installation_check                  ;   AX = apm_installation_check();
   368 00000A2D 83F800                          cmp     ax , 0                                  ;   if (AX == 0)
   369 00000A30 7541                    .22Q:   jne     .22Q_F1                                 ;   {
   370                                  .22Q_T:
   371                                          ; 電断の再確認↓
   372 00000A32 68[FC0A]E888F683C4-             cdecl   puts, .apm_enable                       ;       puts(.apm_enable);
   372 00000A3A 02                 
   373 00000A3B 68[400B]E87FF683C4-             cdecl   puts, .apm_shutdown_wait                ;
   373 00000A43 02                 
   374 00000A44 B81000                          mov     ax , 0x10                               ;       //キー入力待ち
   375 00000A47 CD16                            int     0x16                                    ;       AL = BIOS(0x16, 0x10);
   376                                  
   377 00000A49 3C79                            cmp     al , 'y'                                ;       if (AX == 'y')
   378 00000A4B 7515                    .23Q:   jne     .23Q_F1                                 ;       {
   379                                  .23T:
   380                                          ; しゃっとだうん！                                 ;
   381 00000A4D E859FC                          cdecl   apm_shutdown                            ;           AX = apm_shutdown();
   382                                  
   383 00000A50 83F800                          cmp     ax , 0                                  ;           if (AX != 0)
   384 00000A53 740B                    .24Q    je      .24E                                    ;           {
   385 00000A55 68[0F0B]E865F683C4-             cdecl   puts, .apm_shutdown_error               ;               puts(.apm_shutdown_error);
   385 00000A5D 02                 
   386 00000A5E EB20                            jmp     .10E                                    ;               break;
   387                                  .24E:                                                   ;           }
   388                                  
   389 00000A60 EB0F                            jmp     .23E                                    ;       }
   390                                  .23Q_F1:                                                ;       else if (AX == 'n')
   391 00000A62 3C6E                            cmp     al , 'n'                                ;       {
   392 00000A64 750B                            jne     .23E                                    ;
   393 00000A66 68[720B]E854F683C4-             cdecl   puts, .apm_shutdown_continue            ;           puts(.apm_shutdown_continue);
   393 00000A6E 02                 
   394 00000A6F EB0F                            jmp     .10E                                    ;           break;
   395                                  .23E:                                                   ;       }
   396                                          ; 電断の再確認↑
   397 00000A71 EB0B                            jmp     .22E                                    ;   }
   398                                          ;                                               ;   else
   399                                  .22Q_F1:                                                ;   {
   400 00000A73 68[E40A]E847F683C4-             cdecl   puts, .apm_disable                      ;       puts(.apm_disable);
   400 00000A7B 02                 
   401 00000A7C EB02                            jmp     .10E                                    ;       break;
   402                                  .22E:                                                   ;   }
   403                                  .20E:                                                   ; }
   404                                  
   405 00000A7E EB96                            jmp     .10L                                    ;
   406                                  .10E:                                                   ; }
   407                                  
   408                                          ;------------------------------------------------
   409                                          ; 数値を表示
   410                                          ;------------------------------------------------
   411 00000A80 B8630F                          mov     ax , 3939                               ;
   412 00000A83 6A016A0A6A0868-                 cdecl itoa, ax, .39, 8, 10, 0b0001              ; itoa(AX)
   412 00000A8A [8C0B]50E87CF783C4-
   412 00000A92 0A                 
   413 00000A93 68[8C0B]E827F683C4-             cdecl puts, .39                                 ; puts(.s1);
   413 00000A9B 02                 
   414                                  
   415                                  
   416 00000A9C EBFE                            jmp     $                                       ;
   417                                  
   418 00000A9E 367468207374616765-     .s1:    db  "6th stage...", 0x0A, 0x0D, 0
   418 00000AA7 2E2E2E0A0D00       
   419 00000AAD 2028277027206B6579-     .s0:    db  " ('p' key to protect-mode) or ('s' key to shutdown)...", 0
   419 00000AB6 20746F2070726F7465-
   419 00000ABF 63742D6D6F64652920-
   419 00000AC8 6F722028277327206B-
   419 00000AD1 657920746F20736875-
   419 00000ADA 74646F776E292E2E2E-
   419 00000AE3 00                 
   420 00000AE4 202841504D206E6F74-     .apm_disable:     db  " (APM not supported)", 0x0A, 0x0D, 0x0A, 0
   420 00000AED 20737570706F727465-
   420 00000AF6 64290A0D0A00       
   421 00000AFC 202841504D20737570-     .apm_enable:    db  " (APM supported)", 0x0A, 0x0D, 0
   421 00000B05 706F72746564290A0D-
   421 00000B0E 00                 
   422 00000B0F 205468657265207761-     .apm_shutdown_error:    db " There was an error during shutdown (>_<)sorry", 0x0A, 0x0D, 0
   422 00000B18 7320616E206572726F-
   422 00000B21 7220647572696E6720-
   422 00000B2A 73687574646F776E20-
   422 00000B33 283E5F3C29736F7272-
   422 00000B3C 790A0D00           
   423 00000B40 2041726520796F7520-     .apm_shutdown_wait:     db " Are you really sure to shutdown (?_?)... (y,n)", 0x0A, 0x0D, 0
   423 00000B49 7265616C6C79207375-
   423 00000B52 726520746F20736875-
   423 00000B5B 74646F776E20283F5F-
   423 00000B64 3F292E2E2E2028792C-
   423 00000B6D 6E290A0D00         
   424 00000B72 204F6B2C20636F6E74-     .apm_shutdown_continue: db " Ok, continue power on!", 0x0A, 0x0D, 0
   424 00000B7B 696E756520706F7765-
   424 00000B84 72206F6E210A0D00   
   425 00000B8C 2D2D2D2D2D2D2D2D0A-     .39:    db  "--------", 0x0A, 0x0D, 0
   425 00000B95 0D00               
   426                                          ;------------------------------------------------
   427                                          ; パディング (このファイルは8Kバイトとする)
   428                                          ;------------------------------------------------
   429 00000B97 00<rept>                        times (BOOT_SIZE - ($ - $$)) db 0x00            ; 8KByte
   430                                  
   431                                  ;(関数の概要(ブートプログラムです))
   432                                  ; 0. プロテクトモードへ移行する準備をしてみました.
   433                                  ;    第六ステージにてプロテクトモードに移行するか、またはシャットダウンするかを選択します.
   434                                  ;    もしPが押下された場合はプロテクトモード、Sが押下された場合はシャットダウンします.
   435                                  ;
   436                                  ;                           (プロテクトモードについて)
   437                                  ;    .ここで実際にプロテクトモードに移行するのではなく下準備としてビデオモードの設定を行います.
   438                                  ;    .今回は640×480の解像度を利用したいのでBIOSコールによりこれを設定します.
   439                                  ;
   440                                  ;                           (シャットダウンについて)
   441                                  ;    .プロテクトモードに移らないで今すぐ電断を行いたい場合はここで電断します.
   442                                  ;    .今回はAPMによる電断を試みました.こちらもBIOSコールを発行します.
   443                                  ;    .APM専用の関数を作成したのでそちらに全てまとめてあります.細かいとこはそちらにまとめました.
   444                                  ;    .電断の流れはこちらです.
   445                                  ;
   446                                  ;             "S"が押下された
   447                                  ;                  ↓
   448                                  ;    APMをサポートしているか確認する(関数発行)
   449                                  ;                  ↓
   450                                  ;    　　さらに主に本当に電断するかを確認
   451                                  ;                  ↓
   452                                  ;             シャットダウン(関数発行)
   453                                  ;                  ↓
   454                                  ;                 完了
   455                                  
   456                                  ; 1. 走り書き
   457                                  ; else if 文の書き方 (多分)
   458                                  ;
   459                                  ;       mov     ax , 3                  ; AX=3
   460                                  ;
   461                                  ;       cmp     ax , 0                  ; if (AX == 0)
   462                                  ;       jne     .False                  ; {
   463                                  ;.True:
   464                                  ;
   465                                  ;       mov     bx , 69                 ;   BX=69;
   466                                  ;       jmp     .end                    ;
   467                                  ;
   468                                  ;.False:                                ; }
   469                                  ;       cmp     ax , 1                  ; else if (AX == 1)
   470                                  ;       jne     .False2                 ; {
   471                                  ;
   472                                  ;       mov     bx , 19                 ;   BX = 19;
   473                                  ;       jmp     .end                    ;
   474                                  ;
   475                                  ;.False2:                               ; {
   476                                  ;       cmp     ax , 2                  ; else if (AX == 2)
   477                                  ;       jne     .False3                 ; {
   478                                  ;
   479                                  ;       mov     bx , 9                  ;   BX = 9;
   480                                  ;       jmp     .end                    ;
   481                                  ;
   482                                  ;.False3:                               ; }
   483                                  ;       cmp     ax , 3                  ; else if (AX == 3)
   484                                  ;       jne     .No_much                ; {
   485                                  ;
   486                                  ;       mov     bx , 39                 ;   BX = 39;
   487                                  ;
   488                                  ;.No_much:                              ; }
   489                                  ;                                       ; else
   490                                  ;                                       ; {
   491                                  ;
   492                                  ;       mov     bx , 89                 ; BX = 89;
   493                                  ;
   494                                  ;.end                                   ; }
