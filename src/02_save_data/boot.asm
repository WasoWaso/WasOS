;boot()
ORG     0x7c00                                          ;

Entry:
        jmp     IPL                                     ; IPLラベルへ移動
BPB:
        BOOT_LOAD       equ         0x7c00              ; BOOT_LOAD=0x7c00

        nop                                             ;
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; BPB( BIOS Parameter Block )
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        timES  90 - ( $ - $$ ) db 0x90                  ; BPB領域を確保
IPL:
        cli                                             ; 割り込み禁止

        mov     ax , 0x0000                             ; AX=0x0000
        mov     ds , ax                                 ; DS=0x0000
        mov     es , ax                                 ; ES=0x0000
        mov     ss , ax                                 ; SS=0x0000
        mov     sp , BOOT_LOAD                          ; SP=0x7c00

        sti                                             ; 割り込み許可

        mov     [BOOT.DRIVE] , dl                       ;


        jmp     $                                       ; 処理の終了

        align       2       , db 0                      ;
BOOT:
        .DRIVE:
            dw      0x0000                              ;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; IPL( Initial Program Loader )
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        times 510 - ($ - $$) db 0x00                    ; IPL領域を浸す
        db      0x55 , 0xAA                      ;       ; 0x55 0xAA


;(関数の概要(ブートプログラムです))
; 1. ORGディレクティブ命令でプログラムのロードアドレス指定を行います
; 2. BPBはOSが活用するデータの集合領域ですので早速IPL（初期化プログラム）へ移動します
; 3. 後にspに書き込む値(0x7c00)をBPB領域にequで定数として書き込んでおきました
; 4. かっこいいのでnop書いておきました
; 5. 今回はBPB領域を90バイトとし90バイト目までtimes疑似操作で0x90つまりnopで浸します(BPB
;    領域を実行してもシステムを暴走させないため)
; 6. 後にレジスタの設定や割り込み込みの設定も施すのでそのときに割り込みをされてしまうと困るので
;    cliでIFフラグを0にします
; 7. セグメントレジスタへの転送では即値を指定しないでレジスタを介して各セグメントレジスタに値を
;    書き込みます、AXに0を書き込んだらDS,ES,SSにAXレジスタの値を転送します、スタック領域は
;    ブートプログラムの真上に配置したいので先ほど設定したBOOT_LOAD (0x7x00)を付随します
; 8. 一通り設定を施したのでstiでIFフラグを1にします
; 9. BIOSがDLレジスタにドライブ番号を書き込んでくれるのでその値をメモリに保存しておきます
; 10. jmp -2 を繰り返して繰り返しを施します
; 11. 次に値を保存するための領域を作るので、アライメントを2バイトで合わせます,nopで浸しときます
; 12. 新たなグローバルラベルの中にローカルラベルで値を保存するための領域(さっきのDLレジスタの値
;    をほぞんするための領域)を2バイト空けておきます
; 13. ブートプログラムは５１２バイトに収めることをしたいので一先ず５１０バイト目まで0で浸します
; 14. 最後にブートフラグ、0x55と0xAAを書き込んでブートプログラムの完成です

;(ちょっとメモメモ公録)
;    31行目でBOOT:で新たなグローバルラベルを作っているけど何なんだろうと考えてみた
;    まず Messege: db 'GoodNight!'っていうコードが書かれていたとして注意したいのは高級言語
;    でのMessege="GoodNight" とは本質が異なるってこと、じゃあなんなのかっていうとMessegeに
;    文字コードとしての"GoodNight"を代入しているのではなくて、新たなラベルをつけてデータ領域
;    の場所(アドレス)をはっきりさせようってこと、そもそも jmp func1 というコードが書かれてい
;　  るとしてその意味は”一番目の関数に移動して”ってことでアドレスを指すのfunc1っていう役割だ
;    func1: ...... と関数が存在したとして
;    その考えをもとにMessege: db 'GoodNight' を読み解くと グローバルラベルに文字コードが書
;    かれてるじゃん！ってなる、つまりソースコード内で利用できるMessegeという言葉はデータの開始
;    アドレスを示してるじゃん！ってなる、だからデータを保存しておきたいときはラベルをうまく活用
;    するようにするってことが大事
;    ORGはアドレス計算を0x7c00からやってねってアセンブラに教える
;    （こっからは自分なりの憶測）
;    さっき書いたソースコードには一応IPL領域というくくりの中にBOOTというラベルをつけてアドレス
;    を指し示そうって感じ、でもその中にローカルラベルDRIVEが書かれている、なんでかというとソー
;    スにBOOT_LOAD equ 0x7c00 と書かれている、スタックセグメントレジスタに設定するための値
;    を保存するためだ、もちろんBOOT: dw 0x0000 って書いても mov [BOOT] , dl とすればOKK
;    だと思う、そしたらBOOT_LOADとBOOTができる、でもBOOTって何？って感じで直感的に支える、BO
;    OT_LOADとBOOT_DRIVEならしっくりくる、だからローカルラベルを利用してBOOT.DRIVEでドライ
;    ブ番号を指すことにしょうってことだと思う
