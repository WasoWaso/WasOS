     1                                  ;boot()
     2                                  
     3                                  ORG     0x7c00                                          ;
     4                                  
     5                                          %include "/home/m8ku/prog/src/include/macro.asm"; マクロ
     1                              <1> ;cdecl()
     2                              <1> %macro  cdecl   1-*.nolist
     3                              <1> 
     4                              <1>     %rep %0 - 1
     5                              <1> 
     6                              <1>         push    %{-1 : -1}
     7                              <1>         %rotate -1
     8                              <1> 
     9                              <1>     %endrep
    10                              <1> 
    11                              <1>     %rotate -1
    12                              <1>     call    %1
    13                              <1> 
    14                              <1>     %if 1 < %0
    15                              <1> 
    16                              <1>         add     sp , (__BITS__>>3) * (%0 - 1)
    17                              <1> 
    18                              <1>     %endif
    19                              <1> 
    20                              <1> %endmacro
    21                              <1> 
    22                              <1> ;(マクロの概要(関数呼び出しのための関数です))
    23                              <1> ; 1.cdeclとしてマクロを定義して、引数は１からの可変長として、リスト出力の抑止を指定する(.lst)
    24                              <1> ; 2.%repから、もらった引数から関数分を差し引いた %0 - 1 回として %endrep まで繰り返します
    25                              <1> ; 3.関数呼び出しに備えるために引数をスタックに積んでいきます、%{-1 : -1 }はもらった引数全体の
    26                              <1> ;   終端を表しています ですので、受け取った引数が putc , ax , bx だとして一回目のループでbx
    27                              <1> ;   がスタックに積ます、次の%rotateは引数を回転します例えば (1,2,3)が(3,1,2)になります今回
    28                              <1> ;   は右に回転させたいので-1と指定していますが左に回転させたい場合は+を指定してやります、そして
    29                              <1> ;   (bx,putc,ax)になり次のループで引数の終端axが積んでから引数を回転(ax,bx,putc)となります
    30                              <1> ;   そして今回の例だとここで繰り返しが終了します
    31                              <1> ; 3.今回の例の続きで引数を回転させて(putc,ax,bx)となって
    32                              <1> ; 4.第一引数の名前の関数を呼び出します、今回の例では第一引数はputcとなっているのでputcという関
    33                              <1> ;   数が呼び出されることとなります
    34                              <1> ; 5.後に関数に引数として積んだスタックを調整してやるのですがマクロに引数を一つもしてしていないの
    35                              <1> ;   にもかかわらずスタックポインタを調節されては困るから条件式に当てはまったら処理をするようにし
    36                              <1> ;   てあげます今回だと一つ以上の引数が指定されたらです
    37                              <1> ; 6.関数を呼び出したら呼び出し側がスタックを調節してやらなければいけないのでスタックを調節します
    38                              <1> ;   スタックポインタレジスタに,(__BITS__>>3)*(%0 - 1 )を計算して書き込みます、__BITS__の
    39                              <1> ;   意味はNASMに元々組み込まれているマクロで16bit,32bit,64bitの判定を行います、16bitのプロ
    40                              <1> ;   グラムだったとして16を左へ3回シフトして(>>のところ)2が得られます32だったら4、64だったら8
    41                              <1> ;   、そしてCPUアーキテクチャ単位でスタックの料理ができるようになります、(%0 - 1)で引数の数を
    42                              <1> ;   だして、さきほどだした2と今回出した2をかけて4,積んだ引数は2つなのでビンゴです、spに4を加算
    43                              <1> ;   して関数呼び出しのすべての処理が終わりました
    44                              <1> ; 7.条件処理を終えます
    45                              <1> ; 8.マクロの終了です
     6                                  
     7                                  Entry:
     8 00000000 EB58                            jmp     IPL                                     ; IPLラベルへ移動
     9                                  BPB:
    10                                          BOOT_LOAD       equ         0x7c00              ; BOOT_LOAD=0x7c00
    11                                  
    12 00000002 90                              nop                                             ;
    13                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                                          ; BPB( BIOS Parameter Block )
    15                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    16                                  
    17 00000003 90<rept>                        times  90 - ( $ - $$ ) db 0x90                  ; BPB領域を確保
    18                                  IPL:
    19 0000005A FA                              cli                                             ; 割り込み禁止
    20                                  
    21 0000005B B80000                          mov     ax , 0x0000                             ; AX=0x0000
    22 0000005E 8ED8                            mov     ds , ax                                 ; DS=0x0000
    23 00000060 8EC0                            mov     es , ax                                 ; ES=0x0000
    24 00000062 8ED0                            mov     ss , ax                                 ; SS=0x0000
    25 00000064 BC007C                          mov     sp , BOOT_LOAD                          ; SP=0x7c00
    26                                  
    27 00000067 FB                              sti                                             ; 割り込み許可
    28                                  
    29 00000068 8816[8600]                      mov     [BOOT.DRIVE] , dl                       ;
    30                                  
    31                                          ;;//push    word 'A'                                ;
    32 0000006C 6A58E8170083C402                cdecl   putc , word 'X'                         ;
    33 00000074 6A59E80F0083C402                cdecl   putc , word 'Y'                         ;
    34 0000007C 6A5AE8070083C402                cdecl   putc , word 'Z'                         ;
    35                                  
    36 00000084 EBFE                            jmp     $                                       ; 処理の終了
    37                                  
    38                                          align       2       , db 0                      ;
    39                                  BOOT:
    40                                          .DRIVE:
    41 00000086 0000                                dw      0x0000                              ;
    42                                  
    43                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    44                                          ; IPL( Initial Program Loader )
    45                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    46                                  
    47                                          %include "/home/m8ku/prog/src/modules/real/putc.asm"; モジュール
     1                              <1> ;putc(ch)
     2                              <1> putc:
     3 00000088 55                  <1>         push    bp                                      ; スタックフレームの構築
     4 00000089 89E5                <1>         mov     bp , sp                                 ;
     5                              <1> 
     6 0000008B 50                  <1>         push    ax                                      ; 各レジスタの退避
     7 0000008C 53                  <1>         push    bx                                      ;
     8                              <1> 
     9 0000008D 8A4604              <1>         mov     al , [bp + 4]                           ; 一文字表示
    10 00000090 B40E                <1>         mov     ah , 0x0E                               ;
    11 00000092 BB0000              <1>         mov     bx , 0x0000                             ;　
    12 00000095 CD10                <1>         int     0x10                                    ;
    13                              <1> 
    14 00000097 5B                  <1>         pop     bx                                      ; 各レジスタの復帰
    15 00000098 58                  <1>         pop     ax                                      ;
    16                              <1> 
    17 00000099 89EC                <1>         mov     sp , bp                                 ; スタックフレームの取り外し
    18 0000009B 5D                  <1>         pop     bp                                      ;
    19                              <1> 
    20 0000009C C3                  <1>         ret                                             ; もとの処へ
    21                              <1> 
    22                              <1> ;(関数の概要(位置文字を表示する関数です))
    23                              <1> ; 1. スタックフレームをつくります
    24                              <1> ; 2. 各レジスタを退避させます
    25                              <1> ; 3. 文字列を第一引数を参照してALレジスタに書き込みます
    26                              <1> ; 4. AHレジスタに0x0Eを書き込んでテレタイプ位置文字出力を指定します
    27                              <1> ; 5. BXにレジスタに0x0を書き込んでまとめてページ番号と文字色を設定します(BHがページBLが文色)
    28                              <1> ; 6. 施した設定をもとにBIOSコールをします
    29                              <1> ; 7. 各レジスタを復帰させます
    30                              <1> ; 8. スタックフレームを取り外します
    31                              <1> ; 9. 元番地へ戻します
    48                                  
    49 0000009D 00<rept>                        times 510 - ($ - $$) db 0x00                    ; IPL領域を浸す
    50 000001FE 55AA                            db      0x55 , 0xAA                             ; 0x55 0xAA
    51                                  
    52                                  
    53                                  ;(関数の概要(ブートプログラムです))
    54                                  ; 0. 今回利用する'putc'関数と'macro'マクロをそれぞれ取り込みます
    55                                  ; 1. ORGディレクティブ命令でプログラムのロードアドレス指定を行います
    56                                  ; 2. BPBはOSが活用するデータの集合領域ですので早速IPL（初期化プログラム）へ移動します
    57                                  ; 3. 後にspに書き込む値(0x7c00)をBPB領域にequで定数として書き込んでおきました
    58                                  ; 4. かっこいいのでnop書いておきました
    59                                  ; 5. 今回はBPB領域を90バイトとし90バイト目までtimes疑似操作で0x90つまりnopで浸します(BPB
    60                                  ;    領域を実行してもシステムを暴走させないため)
    61                                  ; 6. 後にレジスタの設定や割り込み込みの設定も施すのでそのときに割り込みをされてしまうと困るので
    62                                  ;    cliでIFフラグを0にします
    63                                  ; 7. セグメントレジスタへの転送では即値を指定しないでレジスタを介して各セグメントレジスタに値を
    64                                  ;    書き込みます、AXに0を書き込んだらDS,ES,SSにAXレジスタの値を転送します、スタック領域は
    65                                  ;    ブートプログラムの真上に配置したいので先ほど設定したBOOT_LOAD (0x7x00)を付随します
    66                                  ; 8. 一通り設定を施したのでstiでIFフラグを1にします
    67                                  ; 9. BIOSがDLレジスタにドライブ番号を書き込んでくれるのでその値をメモリに保存しておきます
    68                                  ; 10. macroファイル中のcdeclへputc関数と表示したい文字をを渡して文字を表示します
    69                                  ; 11. jmp -2 を繰り返して繰り返しを施します
    70                                  ; 11. 次に値を保存するための領域を作るので、アライメントを2バイトで合わせます,nopで浸しときます
    71                                  ; 12. 新たなグローバルラベルの中にローカルラベルで値を保存するための領域(さっきのDLレジスタの値
    72                                  ;    をほぞんするための領域)を2バイト空けておきます
    73                                  ; 13. ブートプログラムは５１２バイトに収めることをしたいので一先ず５１０バイト目まで0で浸します
    74                                  ; 14. 最後にブートフラグ、0x55と0xAAを書き込んでブートプログラムの完成です
