;cdecl(),drive()
%macro  cdecl   1-*.nolist

    %rep %0 - 1

        push    %{-1 : -1}
        %rotate -1

    %endrep

    %rotate -1
    call    %1

    %if 1 < %0

        add     sp , (__BITS__>>3) * (%0 - 1)

    %endif

%endmacro
;(マクロの概要(関数呼び出しのための関数です))
; 1.cdeclとしてマクロを定義して、引数は１からの可変長として、リスト出力の抑止を指定する(.lst)
; 2.%repから、もらった引数から関数分を差し引いた %0 - 1 回として %endrep まで繰り返します
; 3.関数呼び出しに備えるために引数をスタックに積んでいきます、%{-1 : -1 }はもらった引数全体の
;   終端を表しています ですので、受け取った引数が putc , ax , bx だとして一回目のループでbx
;   がスタックに積ます、次の%rotateは引数を回転します例えば (1,2,3)が(3,1,2)になります今回
;   は右に回転させたいので-1と指定していますが左に回転させたい場合は+を指定してやります、そして
;   (bx,putc,ax)になり次のループで引数の終端axが積んでから引数を回転(ax,bx,putc)となります
;   そして今回の例だとここで繰り返しが終了します
; 3.今回の例の続きで引数を回転させて(putc,ax,bx)となって
; 4.第一引数の名前の関数を呼び出します、今回の例では第一引数はputcとなっているのでputcという関
;   数が呼び出されることとなります
; 5.後に関数に引数として積んだスタックを調整してやるのですがマクロに引数を一つもしてしていないの
;   にもかかわらずスタックポインタを調節されては困るから条件式に当てはまったら処理をするようにし
;   てあげます今回だと一つ以上の引数が指定されたらです
; 6.関数を呼び出したら呼び出し側がスタックを調節してやらなければいけないのでスタックを調節します
;   スタックポインタレジスタに,(__BITS__>>3)*(%0 - 1 )を計算して書き込みます、__BITS__の
;   意味はNASMに元々組み込まれているマクロで16bit,32bit,64bitの判定を行います、16bitのプロ
;   グラムだったとして16を左へ3回シフトして(>>のところ)2が得られます32だったら4、64だったら8
;   、そしてCPUアーキテクチャ単位でスタックの料理ができるようになります、(%0 - 1)で引数の数を
;   だして、さきほどだした2と今回出した2をかけて4,積んだ引数は2つなのでビンゴです、spに4を加算
;   して関数呼び出しのすべての処理が終わりました
; 7.条件処理を終えます
; 8.マクロの終了です

struc drive
        .no     resw    1                               ; ドライブ番号
        .cyln   resw    1                               ; シリンダ
        .head   resw    1                               ; ヘッド
        .sect   resw    1                               ; セクタ

endstruc
;(マクロの概要(構造体の定義をしています))
; 0. ディスクアクセスに必要な情報をソースコードに更新する形で利用します、
;    次に更新する例を示します
;   istruc drive
;       at .sect dw 2                                   ; S:セクタ
;   iend
