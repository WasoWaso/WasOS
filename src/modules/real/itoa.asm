;itoa(num,buff,size,radix,flags) //B0,値を符号付か  B1,+-付加するか B2,0で空白埋めるか
itoa:
;                                                       ;    +12| フラグ
;                                                       ;    +10| 基数
;                                                       ;    + 8| バッファサイズ
;                                                       ;    + 6| バッファアドレス
;                                                       ;    + 4| 数値
;                                                       ;    + 2| IP(元の値)
        push    bp                                      ; BP + 0| BP(元の値)
        mov     bp , sp                                 ; ------+--------

        push    ax                                      ; //各レジスタの保存
        push    bx                                      ;
        push    cx                                      ;
        push    dx                                      ;
        push    si                                      ;
        push    di                                      ;
        pushf                                           ;

        mov     ax , [bp + 4]                           ; // 第一引数へアクセス
        mov     si , [bp + 6]                           ; // 第二引数へアクセス
        mov     cx , [bp + 8]                           ; // 第三引数へアクセス

        mov     di , si                                 ; // バッファの終端
        add     di , cx                                 ; //dst = &dst-[size-1]
        dec     di                                      ; //buffを超えないようdec

        mov     bx , [bp + 12]                          ; //第五引数へアクセス
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 符号付き判定
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        test    bx , 0b0001                             ; if(flags & 0x01)//判定
.10Q:   je      .10E                                    ; {
        cmp     ax , 0                                  ;   if(val < 0)
.12Q:   jge     .10E                                    ;   {
        or      bx , 0b0010                             ;     flags |= 2; //表示
.12E:                                                   ;   }
.10E:                                                   ; }
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 符号出力判定
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        test    bx , 0b0010                             ; if(flags & 0x02)出力判定
.20Q:   je      .20E                                    ; {
        cmp     ax , 0                                  ;   if(val < 0)
.22Q:   jge     .22F                                    ;   {
        neg     ax                                      ;   val *= -1;//符号反転
        mov     [si] , byte '-'                         ;   *dst = '-';//符号表示
        jmp     .22E                                    ;   }
.22F:                                                   ;   else{
        mov     [si] , byte '+'                         ;   　*dst = '+';//符号表示
.22E:                                                   ;   }
        dec     cx                                      ;   size --;//バッファ減算
.20E:                                                   ; }
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ASCII変換
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        mov     bx , [bp+10]                            ; //第四引数へアクセス
.30L:                                                   ; do
;                                                       ; {
        mov     dx , 0                                  ;　
        div     bx                                      ; AX=DX:AX / BX(基数);
;                                                       ; DX=DX:AX % BX(基数);
;                                                       ;
        mov     si , dx                                 ; // テーブル参照
        mov     dl , byte [.ascii + si]                 ; DL=ASCII[DX];

        mov     [di] , dl                               ; dst* = DL;
        dec     di                                      ; dst--    ;

        cmp     ax , 0                                  ;
        loopnz .30L                                     ; } while (AX);
.30E:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 空白を埋める
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.40Q:   cmp     cx , 0                                  ; if(size)
        je      .40E                                    ; {
        mov     al , ' '                                ; AL = ' ';//' 'で埋める
        cmp     [bp + 12] , word 0b0100                 ;  if(flags & 0x04)
.42Q:   jne     .42E                                    ;  {
        mov     al , '0'                                ;  AL = '0';//'0'で埋める
.42E:                                                   ;  }
        std                                             ; //DF = 1//(-方向)
        rep     stosb                                   ; while(--CX) *DI--=' ';
.40E:                                                   ; }

    popf                                                ; //各レジスタの復帰
    pop     di                                          ;
    pop     si                                          ;
    pop     dx                                          ;
    pop     cx                                          ;
    pop     bx                                          ;
    pop     ax                                          ;

    mov     sp , bp                                     ; //スタックフレームの破棄
    pop     bp                                          ;

    ret                                                 ; //もとのとこへ

.ascii: db      "0123456789ABCDEF"                      ; 変換テーブル

;(関数の概要(数値を文字列に変換する関数です))
; 1. スタックフレームを構築します
; 2. 各レジスタを保存します
; 3. 各引数へアクセスすると共に後に利用する値を練ります、この関数は右詰めに文字コードを保存して
;    いき左側を空白などで埋めます、そのためにバッファアドレスからバッファサイズを足して右端へア
;    ドレスを設定します、しかしこのままだと指定されたサイズを超えて一文字目を保存してしまいます
;    もし保存先バッファアドレスが0x3000保存先バッファサイズが3Byteだったとして下の図で考えて
;    いくと3000+3で3003になってバッファを超えた∇へアクセスしてオーバーフローが起きてしまうので
;    作った数値からデクリメントしてあげます     ↓
;    __________ __________ __________ __________
;   | 3000番地 || 3001番地 || 3002番地 ||3003番地 |
;    ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^
; (符号付き判定)
; 1. 引数として受け取る値の中にビット定義のフラグが含まれていますフォーマットはB0が"値を符号付
;    き変数として扱う"B1が"'+/-'記号を付加する"B2が"空白を'0'で埋める"です、そしてこれらの前
;    準備をこちらでします、ビット定義のフラグの引数はbxレジスタへ転送してあります
; 2. 'test bx,0b0001'ではフラグのB0を検査し符号付き整数として扱うかどうかを判断します、test
;    命令はdstとsrcのAND演算を行い結果に応じてZF(ゼロフラグ)を設定します'test 0b01,0b01'だ
;    ったらZFは1,"test 0b01,0b00"だったらZFは0が設定されます、そして"je .10E"で分岐をしま
;    す、jeはZFを検査して0だったらそのまま続いて1だったらオペランドのアドレスへジャンプします、
;    次'cmp ax,0'で比較して'jge .10E'で条件分岐を行いますjgeは符号付き条件分岐命令ですので
;    負の数値でも条件分岐ができます、もしaxが0より小さかったらbxレジスタを0b0010でor演算しB1
;    を設定します
; (符号出力判定)
; 1. test命令でB1を検査しB1が立っていたら後へ続きます、次'cmp ax,0'で比較して'jge .22F'
;    で条件分岐を行いますjgeは符号付き条件分岐命令ですので負の数値でも条件分岐ができます、もし
;    axが0より小さかったら'-'符号をもしaxが0より大きいなら'+'符号を付加します、もし負の数だっ
; 　 たとしては負の数値のままだと後のASCII変換で期待した値を取得できないのでneg命令で二の補数反
; 　 転をして符号を反転します、そしてバッファを一つ利用したので残りバッファ数を保持しているcxレジ
;    スタをデクリメントします
; (ASCII変換)
; 1. 基数を取得して後続のプログラムへ備えます
; 2. 数値を文字列に変換する系統です、どうやって変換するかというと、数値を基数で除算し数値が0とな
; 　 るまで繰り返します、基数が2なら2進数の値、奇数が10なら10進数の値といった具合で文字列が得ら
;    れます、そのとき除算の余りを元に文字列を組み立てていくのですが、ある数値を除算して得られた
;    余りの数を変換テーブルへの索引として文字変換しLOOPNZ命令により残りバッファサイズ(cx)と変
;    換する値(ax)がが0になるまで繰り返します加えてその時必要となる文字列変換テーブルをソースコ
;    ードの一番最後、関数の最後付近に定義しています
; 3. 'mov dx,0'でdxレジスタに0を転送していますがこれは繰り返し行う過程で除算による余りがdxレ
;    ジスタに転送されるのですがx86CPUの除算では"AX=DX:AX/オペランド"という具合に被演算子にdx
;    レジスタが含まれているので繰り返しの過程でdxレジスタを初期化してやります
; 4. 'div bx'でaxレジスタの値をbxレジスタの値(基数)で除算します、このとき余りはdxレジスタへ商
;     はaxレジスタへそれぞれ格納されます、得られた商をまた次の繰り返しで除算します
; 5. 'mov si,dx'で先程の除算で得られた余剰をsiレジスタへ転送します、
; 6. 'mov dl,byte [.ascii+si]'で得られた余剰から文字コードを取得します、余剰をインデックス
;    として[.axcii+si]といった具合で変換テーブルへアクセスして得られるASCII文字をdlレジスタ
;    へ書き込みます
; 7. 'mov [di],dl'として先程得た文字コードを転送先アドレスを保持するdiレジスタをメモリオペラ
;    ンドにしてメモリへ文字コードを転送します
; 8. 'dec di'で次に保存する値へ備えてアドレスをデクリメントして保存位置を左へ一つずらします
; 9. 'cmp ax,0'で比較をして次のloopnzへ備えます
;10. 'loopnz .30L'では繰り返しを続けるかの有無を判断します、loopnzはCX=0,ZF=0の時オペランド
;    で指定したオフセットへジャンプします、ですのでバッファを使い切るか数値が0になるまで除算した
;    なら文字変換の繰り返しは終了します、先のことを言い換えてloopnzの終了条件はCX=0,ZF=1とな
;    ります加えてloopzの終了条件はCX=0,ZF=0、また1/2をすると0になります、
;11. そして3から10を繰り返したならば文字列が出来上がります
; (空白を埋める);
; 1. 'cmp cx,0'で比較をして条件分岐に備えます
; 2. 'je .40E'で残りのバッファがなかったらそのまま関数の終了へ移動します
; 3. 'cmp [bp+12,word 0b0100]'と'jne .42E'でもしビット定義のフラグ,B3が立っていたら'0'で
;     残りバッファを埋めて立っていなかったら空白で埋める条件分岐をJump If not equal(ZF=0)で
;     します
; 4. 'std'と'rep stosb'で残りのバッファを埋めます、stdでDFフラグをセットして後続のストリング
;    命令へ備えます、stosbはalレジスタの内容をdiレジスタのメモリアドレスを一バイトずつ転送する
;    と共にDFフラグが1ならdiレジスタをインクリメントし0だったらデクリメントへすることでアドレス
;    の増減をサポートする命令でrepはcxレジスタの値が0だったら転送を止めるプレフィックスで、そう
;    して残りのバッファ分を埋めることができるようになります

; 4. スタックを復帰して
; 5. スタックフレームを取り外して
; 6. 'ret'で前にいた番地へ戻ります
