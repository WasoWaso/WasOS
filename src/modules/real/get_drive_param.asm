;get_drive_para(drive) 引数((× AX=0) (〇 AX≠0))
get_drive_param:
        push    bp                                      ; スタックフレームの構築
        mov     bp , sp                                 ;
        push    3                                       ; int retry = 3;

        push    bx                                      ; 格レジスタの保存
        push    cx                                      ;
        push    es                                      ;
        push    si                                      ;
        push    di                                      ;
        pushf                                           ;

        mov     si , [bp + 4]                           ; SI = バッファ
        mov     ax , 0                                  ; DiskBaseTablePointer=0
        mov     es , ax                                 ; ES = 0;
        mov     di , ax                                 ; DI = 0;

.10L:
        mov     ah , 0x8                                ; //Get drive parameters
        mov     dl , [si + drive.no]                    ; DL = drive.no;
        int     0x13                                    ; CF = BIOS(0x13,8);
.10Q:   jc      .10F                                    ; if (0 == CF)
.10T:                                                   ; {
        mov     al , cl                                 ;   AX = セクタ数
        and     ax , 0x3F                               ;   //下位6ビットのみ有効

        shr     cl , 6                                  ;   CX = シリンダ数
        ror     cx , 8                                  ;
        inc     cx                                      ;

        movzx   bx , dh                                 ;   BX = ヘッド数
        inc     bx                                      ;

        mov     [si + drive.cyln + 0] , cx              ;   drive.syln = CX; //C
        mov     [si + drive.head] , bx                  ;   drive.head = BX; //H
        mov     [si + drive.sect] , ax                  ;   drive.sect = ax; //S

        jmp     .10E                                    ;   break;
;                                                         }elese{
.10F:                                                   ;   AX = 0;
        mov     ax , 0                                  ; }
        dec     word [bp - 2]                           ;
        jnz     .10L                                    ; while (retry--)
.10E:                                                   ;

        popf                                            ; レジスタの復帰
        pop     di                                      ;　
        pop     si                                      ;
        pop     es                                      ;
        pop     cx                                      ;
        pop     bx                                      ;

        mov     sp , bp                                 ; スタックフレームの破棄
        pop     bp                                      ;

        ret                                             ; ただいま

; 関数の概要(ドライブパラメータを取得する関数です)
; 0. AHレジスタに0x8番,0x13番のBIOSコールでディスクの情報をCX,DXレジスタにそれぞれ書き込んで
;    くれます、CF==0が成功です、ソースコード中ではAX,BX,CXレジスタに値を移動し上手く値を練って
;    最後にしてのメモリ領域に値を返します、そして引数はセクタ数が返され読込できなかったら0を返し
;    ます.
; 1. スタックフレームを作って.
; 2. レジスタを保存して.
; 3. 'mov si,[bp+4]'で取得した値を指定の領域に書き込むのための準備をします.
; 4. 'mov ah,0x8'でドライブパラメータの取得'mov dl,[si+drive.no]'でブートプログラムで既に
;     知っているドライブ番号を指定してバイオスコール12番を発行します、成功か否かで分岐します.
; 5.  'jc .10F'で成功か否かで行く先を決めてあげます、〇だったら後続のアドレスへ×だったなら当該
;     アドレスへジャンプします.
; 5. <ここからは、レジスタのビット単位で指定されている変則的な値を上手く整理していきます>

;    (AX = セクタ数)
;    'mov al,cl'でセクタ数をALレジスタに連れてきます.
;    'and ax 0x3F'で下位6ビットのみ有効にします、なぜならばCLレジスタの6,7ビット目にシリンダ
;    の値をも含まれているからです、0x3Fは二進数で表すと 00111111 です.これでセクタの値だけを
;    取り出す事ができます.
;        ________     ________     ________
;       |11111111| × |00111111| = |00111111|
;        ^^^^^^^^     ^^^^^^^^     ^^^^^^^^

;    (CX = シリンダ数)
;    シリンダ数はCXレジスタに含まれているのでCXレジスタの値をそのまま流用します
;    'shr cl,6'で6回ビットをシフトします、なぜならばCLレジスタの6,7ビット目に全体で見るシリン
;    ダ数の9,10ビット目が含まれているからです.
;    'ror cx,6'ではシリンダ数の真なる値をつくります、ror命令はシフトにより押し出された最上位
;    ビットを再下位ビットへ順次コピーしていく命令です、これによりビット循環を実現できます.
;          CH         CL                        CH         CL
;        ________   ________                  ________   ________
;       |11111111| |11000000| 'shl cl,6' →   |11111111| |00000011|
;        ^^^^^^^^   ^^^^^^^^                  ^^^^^^^^   ^^^^^^^^
;          CH         CL                              CX
;        ________   ________                  ________   ________
;       |11111111| |00000011| 'ror cx,8' →   |00000011| |11111111|
;        ^^^^^^^^   ^^^^^^^^                  ^^^^^^^^   ^^^^^^^^
;                                                    ∧ こっちに移動した
;    'inc cx'でCXレジスタの値をインクリメントします、というのもシリンダの番号の指定は0始まり
;    なのですが対してセクタの番号の指定は1始まりです、ですのでシリンダ数を一つ足してやります、
;    シリンダの最終番号ではなくシリンダがいくつ存在するかを知りたいためだと思います//.

;    (BX = ヘッド数)
;    'movzx bx,dh'ではDHレジスタからBXレジスタへゼロ拡張転送を行います、movzx命令は1バイト
;    の第二オペランドを2バイトの第一オペランドへ拡大コピーします.拡大というのは1バイトレジスタ
;    の値を2バイトレジスタの下位バイトへ移動して空きを0で埋めことです.
;    "inc bx"で先程の(CX = シリンダ数)と同様の理由でインクリメントしてやります.
;          DH         DL                              BX
;        ________   ________                   ________________
;       |11111111| |00000000| 'movzx bx,dh' → |0000000011111111|
;        ^^^^^^^^   ^^^^^^^^                   ^^^^^^^^^^^^^^^^
; 6. 既に.3で書き込み場所は取得しているのでに定義している構造体の＜syln,head,sect＞を利用しな
;    がら整理した値をいよいよメモリへ書き込みます.
; 7. 'jmp .10E'CF==0だったときにすることはこれで終了ですので関数の終了まで連れていきます.
; 8. 'mov ax,0'~'jnz .10L'CF==1だったときはretry変数分だけバイオスコールから回るようにして
;     みました
; 9. レジスタを復帰して.
;10. スタックフレームを壊して.
;11. ただいま.
