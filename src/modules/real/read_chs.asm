;read_chs(drive,sect,dst)
read_chs:
        ;________________________________________________
        ; スタックフレームの構築
        ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        push    bp                                      ;
        mov     bp , sp                                 ;
        push    3                                       ; int retry = 3;
        push    0                                       ; int sect  = 0;

        ;________________________________________________
        ;　レジスタの保存
        ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        push    bx                                      ;
        push    cx                                      ;
        push    dx                                      ;
        push    es                                      ;
        push    si                                      ;
        pushf                                           ;

        ;________________________________________________
        ; メインプログラム開始！
        ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        mov     si , [bp + 4]                           ; SI = SRCバッファ;

        ;________________________________________________
        ; CXレジスタの設定 (BIOSコールの呼び出しに適した形に変換)
        ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        mov     ch , [si + drive.cyln + 0]              ; CH=シリンダ番号(下位バイト)
        mov     cl , [si + drive.cyln + 1]              ; CL=シリンダ番号(上位バイト)
        shl     cl , 6                                  ; CL<<=6;//6ビット左へシフト
        or      cl , [si + drive.sect]                  ; CL|=セクタ番号;

        ;________________________________________________
        ; DHレジスタの設定とコピー先の設定
        ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        mov     dh , [si + drive.head ]                 ; DH = ヘッド番号;
        mov     dl , [si + 0]                           ; DL = ドライブ番号;

        mov     ax ,0x0000                              ; AX = 0x0000;
        mov     es , ax                                 ; EX = セグメント
        mov     bx , [bp + 8]                           ; BX = コピー先

        ;________________________________________________
        ; セクタの読み込み
        ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.10L:
        mov     al , [bp + 6]                           ; AL = セクタ数
        mov     ah , 0x02                               ; AH = セクタ読み込み;

        int     0x13                                    ; CF = BIOS(0x13,0x02);
        jnc     .11E                                    ; if(CF)
;                                                       ; {
        mov     al , 0                                  ;   AL = 0;
        jmp     .10E                                    ;   break;
.11E:                                                   ; }

        cmp     al , 0                                  ; if(セクタ読み込んだなら){
        jne     .10E                                    ;   break;

        mov     ax , 0                                  ;   ret = 0;//戻り値を設定
        dec     word [bp - 2]                           ; }
        jnz     .10L                                    ; while (--retry)
.10E:
        mov     ah , 0                                  ; AH=0;//ステータス情報破棄

        ;________________________________________________
        ; レジスタの復帰
        ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        popf                                            ;
        pop     si                                      ;
        pop     es                                      ;
        pop     dx                                      ;
        pop     cx                                      ;
        pop     bx                                      ;

        ;________________________________________________
        ; スタックフレームの破棄
        ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        mov     sp , bp                                 ;
        pop     bp                                      ;

        ret                                             ; もとのとこへ

; (関数の概要(セクタを読み出す関数です))
; 0. BIOS(0x13,0x02)はAH(セクタ読み込み数),AL(0x13の引数),CH(シリンダ),CL(セクタ番号,な
;    お上位二ビットはシリンダ(CH)の9,10ビット目の役割),DH(ヘッド番号),DL(ドライブ番号)
;    driveは第一引数であるが(ドライブ番号,シリンダ,ヘッド,セクタ)への配列を渡す
; 1. スタックフレームの構築をして
; 2. レジスタの保存をして
; 3. "mov si,[bp+4]" 第一引数へアクセスします、受け取る引数には(nomber,cyln,head,sect)の
;    パラメーターが入ったアドレスが含まれています、siレジスを基にそれぞれの値へ次アクセスします
; 4. (CXレジスタの設定(BIOSコールへの準備))
;    CXレジスタの設定を行います、86CPUはリトルエディアンなプロセッサなので
;    メモリアクセスの際、上位レジスタが下位バイトへ下位レジスタが上位バイトへとメインメモリへと
;    書きこまれるので一バイトアクセスのときに注意します
; 5. (DHレジスタの設定とコピー先の設定(BIOSコールへの準備))
;    先程得たパラメーターを参照してBIOSコールを発行する準備をDHレジスタに施します
; 6. (セクタの読み込み(いざBIOSコールを発行します))
;    ALレジスタをそれぞれ設定してBIOSを呼び覚まします、発行したらCFを確認して成功したか非かを
;    確かめ、CFが0すなわち成功だったらALレジスタのセクタ読み込み数を確認し読み込んだセクタがあ
;    ったなら読み込みセクタ数を保持して関数の終了へ、もしALレジスタが0だったらセクタ読み出し数の
;    参照からretry変数分だけやり直します、戻り値は、AXレジスタが0です、CFが1すなわち失敗だった
;    ら戻り値に0を設定して関数の終了です
; 7. レジスタの復帰をして
; 8. スタックフレームを破棄して
; 9. もとのところへ戻っていきます
