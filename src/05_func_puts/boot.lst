     1                                  ;boot()
     2                                  
     3                                          ORG     0x7c00                                  ;
     4                                  
     5                                          %include "/home/m8ku/prog/src/include/macro.asm"; マクロ
     1                              <1> ;cdecl()
     2                              <1> %macro  cdecl   1-*.nolist
     3                              <1> 
     4                              <1>     %rep %0 - 1
     5                              <1> 
     6                              <1>         push    %{-1 : -1}
     7                              <1>         %rotate -1
     8                              <1> 
     9                              <1>     %endrep
    10                              <1> 
    11                              <1>     %rotate -1
    12                              <1>     call    %1
    13                              <1> 
    14                              <1>     %if 1 < %0
    15                              <1> 
    16                              <1>         add     sp , (__BITS__>>3) * (%0 - 1)
    17                              <1> 
    18                              <1>     %endif
    19                              <1> 
    20                              <1> %endmacro
    21                              <1> 
    22                              <1> ;(マクロの概要(関数呼び出しのための関数です))
    23                              <1> ; 1.cdeclとしてマクロを定義して、引数は１からの可変長として、リスト出力の抑止を指定する(.lst)
    24                              <1> ; 2.%repから、もらった引数から関数分を差し引いた %0 - 1 回として %endrep まで繰り返します
    25                              <1> ; 3.関数呼び出しに備えるために引数をスタックに積んでいきます、%{-1 : -1 }はもらった引数全体の
    26                              <1> ;   終端を表しています ですので、受け取った引数が putc , ax , bx だとして一回目のループでbx
    27                              <1> ;   がスタックに積ます、次の%rotateは引数を回転します例えば (1,2,3)が(3,1,2)になります今回
    28                              <1> ;   は右に回転させたいので-1と指定していますが左に回転させたい場合は+を指定してやります、そして
    29                              <1> ;   (bx,putc,ax)になり次のループで引数の終端axが積んでから引数を回転(ax,bx,putc)となります
    30                              <1> ;   そして今回の例だとここで繰り返しが終了します
    31                              <1> ; 3.今回の例の続きで引数を回転させて(putc,ax,bx)となって
    32                              <1> ; 4.第一引数の名前の関数を呼び出します、今回の例では第一引数はputcとなっているのでputcという関
    33                              <1> ;   数が呼び出されることとなります
    34                              <1> ; 5.後に関数に引数として積んだスタックを調整してやるのですがマクロに引数を一つもしてしていないの
    35                              <1> ;   にもかかわらずスタックポインタを調節されては困るから条件式に当てはまったら処理をするようにし
    36                              <1> ;   てあげます今回だと一つ以上の引数が指定されたらです
    37                              <1> ; 6.関数を呼び出したら呼び出し側がスタックを調節してやらなければいけないのでスタックを調節します
    38                              <1> ;   スタックポインタレジスタに,(__BITS__>>3)*(%0 - 1 )を計算して書き込みます、__BITS__の
    39                              <1> ;   意味はNASMに元々組み込まれているマクロで16bit,32bit,64bitの判定を行います、16bitのプロ
    40                              <1> ;   グラムだったとして16を左へ3回シフトして(>>のところ)2が得られます32だったら4、64だったら8
    41                              <1> ;   、そしてCPUアーキテクチャ単位でスタックの料理ができるようになります、(%0 - 1)で引数の数を
    42                              <1> ;   だして、さきほどだした2と今回出した2をかけて4,積んだ引数は2つなのでビンゴです、spに4を加算
    43                              <1> ;   して関数呼び出しのすべての処理が終わりました
    44                              <1> ; 7.条件処理を終えます
    45                              <1> ; 8.マクロの終了です
     6                                  
     7                                  Entry:
     8 00000000 EB58                            jmp     IPL                                     ; IPLラベルへ移動
     9                                  BPB:
    10                                          BOOT_LOAD       equ         0x7c00              ; BOOT_LOAD=0x7c00
    11                                  
    12 00000002 90                              nop                                             ;
    13                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                                          ; BPB( BIOS Parameter Block )
    15                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    16                                  
    17 00000003 90<rept>                        times  90 - ( $ - $$ ) db 0x90                  ; BPB領域を確保
    18                                  IPL:
    19                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    20                                          ; IPL( Initial Program Loader )
    21                                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    22 0000005A FA                              cli                                             ; 割り込み禁止
    23                                  
    24 0000005B B80000                          mov     ax , 0x0000                             ; AX=0x0000
    25 0000005E 8ED8                            mov     ds , ax                                 ; DS=0x0000
    26 00000060 8EC0                            mov     es , ax                                 ; ES=0x0000
    27 00000062 8ED0                            mov     ss , ax                                 ; SS=0x0000
    28 00000064 BC007C                          mov     sp , BOOT_LOAD                          ; SP=0x7c00
    29                                  
    30 00000067 FB                              sti                                             ; 割り込み許可
    31                                  
    32 00000068 8816[8400]                      mov     [BOOT.DRIVE] , dl                       ;
    33                                  
    34 0000006C 68[7700]E8140083C4-             cdecl   puts , .s0                              ;
    34 00000074 02                 
    35                                  
    36 00000075 EBFE                            jmp     $                                       ; 処理の終了
    37                                  
    38 00000077 426F6F74696E672E2E-     .s0     db  "Booting..." , 0x0A , 0x0D , 0              ; データ
    38 00000080 2E0A0D00           
    39                                  
    40                                  
    41                                          align       2       , db 0                      ;
    42                                  BOOT:
    43                                          .DRIVE:
    44 00000084 0000                                dw      0x0000                              ; ドライブ番号
    45                                  
    46                                      %include "/home/m8ku/prog/src/modules/real/puts.asm"; モジュール
     1                              <1> ;puts(str)
     2                              <1> puts:
     3 00000086 55                  <1>         push    bp                                      ; スタックフレームを構築
     4 00000087 89E5                <1>         mov     bp , sp                                 ;
     5                              <1> 
     6 00000089 50                  <1>         push    ax                                      ; 各レジスタの退避
     7 0000008A 53                  <1>         push    bx                                      ;
     8 0000008B 56                  <1>         push    si                                      ;
     9 0000008C 9C                  <1>         pushf                                           ;
    10                              <1> 
    11 0000008D 8B7604              <1>         mov     si , [bp + 4]                           ; 第一引数へアクセス
    12 00000090 B40E                <1>         mov     ah , 0x0E                               ; AH=0x0E
    13 00000092 BB0000              <1>         mov     bx , 0x0000                             ; BX=0x0000
    14 00000095 FC                  <1>         cld                                             ; DF=0
    15                              <1> 
    16                              <1> .10L:                                                   ; do{
    17 00000096 AC                  <1>         lodsb                                           ; AL = *SI++;
    18                              <1> 
    19 00000097 3C00                <1>         cmp     al , 0                                  ; if(0 == AL)
    20 00000099 7404                <1>         je      .10E                                    ; break;
    21                              <1> 
    22 0000009B CD10                <1>         int     0x10                                    ; Int10(0x0E,AL)//文字出力
    23                              <1> 
    24 0000009D EBF7                <1>         jmp     .10L                                    ; while (1);
    25                              <1> .10E:
    26                              <1> 
    27 0000009F 9D                  <1>         popf                                            ; 各レジスタの復帰
    28 000000A0 5E                  <1>         pop     si                                      ;
    29 000000A1 5B                  <1>         pop     bx                                      ;
    30 000000A2 58                  <1>         pop     ax                                      ;
    31                              <1> 
    32 000000A3 89EC                <1>         mov     sp , bp                                 ; スタックフレームの破棄
    33 000000A5 5D                  <1>         pop     bp                                      ;
    34                              <1> 
    35 000000A6 C3                  <1>         ret                                             ; もとの処へ
    36                              <1> 
    37                              <1> ;(関数の概要(文字列を表示する関数です))
    38                              <1> ; 1. スタックフレームを構築します
    39                              <1> ; 2. 各レジスタを退避します
    40                              <1> ; 3. SIレジスタには後ほど利用する値を、AHレジスタに0x0EをBXレジスタには0をBIOSコールに備えて
    41                              <1> ;    書き込んでおきます
    42                              <1> ; 3. ストリング命令に備えてDFフラグを０を書き込みます
    43                              <1> ; 4. 先に引数の転送元をSIレジスタに書き込んだので転送元(メモリ)から転送先(ALレジスタ)へ値をを
    44                              <1> ;    転送します、この時にDIレジスタの値がインクリメントされます、
    45                              <1> ; 5. もしALレジスタに0が入ったら関数の終了アドレスへ移動します
    46                              <1> ; 6. そしたらALレジスタにはきっとASCII文字が書かれているので0x10番でBIOSコールをし表示します
    47                              <1> ; 7. .10Eのアドレスへ移動してALレジスタに0が入るまで文字を表示して結果的に文字列が表示できます
    48                              <1> ; 8. 各レジスタ復帰します
    49                              <1> ; 9. スッタックフレームを取り除いて
    50                              <1> ;10. 呼び出し元のアドレスまで移動します
    47                                  
    48 000000A7 00<rept>                        times 510 - ($ - $$) db 0x00                    ; IPL領域を浸す
    49 000001FE 55AA                            db      0x55 , 0xAA                             ; 0x55 0xAA
    50                                  
    51                                  
    52                                  ;(関数の概要(ブートプログラムです))
    53                                  ; 0. ソースファイル中の%includeで今回利用する'puts'関数と'macro'マクロをそれぞれ取り込みます
    54                                  ; 1. ORGディレクティブ命令でプログラムのロードアドレス指定を行います
    55                                  ; 2. BPBはOSが活用するデータの集合領域ですので早速IPL（初期化プログラム）へ移動します
    56                                  ; 3. 後にspに書き込む値(0x7c00)をBPB領域にequで定数として書き込んでおきました
    57                                  ; 4. かっこいいのでnop書いておきました
    58                                  ; 5. 今回はBPB領域を90バイトとし90バイト目までtimes疑似操作で0x90つまりnopで浸します(BPB
    59                                  ;    領域を実行してもシステムを暴走させないため)
    60                                  ; 6. 後にレジスタの設定や割り込み込みの設定も施すのでそのときに割り込みをされてしまうと困るので
    61                                  ;    cliでIFフラグを0にします
    62                                  ; 7. セグメントレジスタへの転送では即値を指定しないでレジスタを介して各セグメントレジスタに値を
    63                                  ;    書き込みます、AXに0を書き込んだらDS,ES,SSにAXレジスタの値を転送します、スタック領域は
    64                                  ;    ブートプログラムの真上に配置したいので先ほど設定したBOOT_LOAD (0x7x00)を付随します
    65                                  ; 8. 一通り設定を施したのでstiでIFフラグを1にします
    66                                  ; 9. BIOSがDLレジスタにドライブ番号を書き込んでくれるのでその値をメモリに保存しておきます
    67                                  ;10. macroファイル中のcdeclへputc関数と表示したい文字列をを渡して文字列を表示します
    68                                  ;11. jmp -2 を繰り返して繰り返しを施します
    69                                  ;12. 表示したい文字データを書き込みます、0x0AはLF(カーソルを一行下げて)0x0DはCR(カーソルを左
    70                                  ;    端へ戻します)
    71                                  ;13. 次に値を保存するための領域を作るので、アライメントを2バイトで合わせます
    72                                  ;14. 新たなグローバルラベルの中にローカルラベルで値を保存するための領域(さっきのDLレジスタの値
    73                                  ;    をほぞんするための領域)を2バイト空けておきます
    74                                  ;15. ブートプログラムは５１２バイトに収めることをしたいので一先ず５１０バイト目まで0で浸します
    75                                  ;16. 最後にブートフラグ、0x55と0xAAを書き込んでブートプログラムの完成です
